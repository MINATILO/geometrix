//
//! Copyright © 2008-2011
//! Brandon Kohn
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

namespace geometrix {

#define DIMENSION BOOST_PP_ITERATION()

//! define the constructors via the preprocessor.
template <typename T>
boost::array<T,DIMENSION> make_array( BOOST_PP_ENUM_PARAMS(DIMENSION, const T& a) )        
{
    boost::array<T,DIMENSION> numericSequence = { BOOST_PP_ENUM_PARAMS(DIMENSION, a) };
    return numericSequence;
}

/////////////////////////////////////////////////////////////////////////////
//
// CLASS numeric_sequence
//! A template class for specifying numeric_sequence which can be compile time
//! and runtime indexed conforming to random access for both and can support
//! vector and scalar arithmetic.
//!
template <typename NumericType>
class numeric_sequence<NumericType,DIMENSION> //: public boost::array< NumericType, DIMENSION >
{
public:

    typedef NumericType                             numeric_type;
    typedef dimension<DIMENSION>                    dimension_type;
    typedef boost::array< NumericType, DIMENSION >  numeric_array;
    typedef typename numeric_array::value_type      value_type;
    typedef typename numeric_array::reference       reference;
    typedef typename numeric_array::const_reference const_reference;
    
    numeric_sequence(){}

    //! define the constructors via the preprocessor.
    numeric_sequence( BOOST_PP_ENUM_PARAMS(DIMENSION, const numeric_type& a) )
        : m_sequence( make_array( BOOST_PP_ENUM_PARAMS(DIMENSION, a) ) )
    {
    }

    numeric_sequence( const numeric_array& a )
        : m_sequence( a )
    {}

    template <unsigned int D>
    const numeric_type& get() const
    {
        BOOST_MPL_ASSERT_MSG
        (
           ( dimension< D >::value >= 0 && dimension< D >::value < dimension_type::value )
           , NUMERIC_SEQUENCE_GET_CALLED_WITH_INDEX_OUT_OF_BOUNDS
           , ( dimension< D > )
        );

        return m_sequence[D];
    }

    template <unsigned int D>
    numeric_type& get()
    {        
        BOOST_MPL_ASSERT_MSG
        (
           ( dimension< D >::value >= 0 && dimension< D >::value < dimension_type::value )
           , NUMERIC_SEQUENCE_GET_CALLED_WITH_INDEX_OUT_OF_BOUNDS
           , ( dimension< D > )
        );

        return m_sequence[D];
    }

    const numeric_type& get( std::size_t i ) const
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return m_sequence[i];
    }

    numeric_type& get( std::size_t i )
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return m_sequence[i];
    }

    const numeric_type& operator[]( std::size_t i ) const
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return m_sequence[i];
    }

    numeric_type& operator[]( std::size_t i )
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return m_sequence[i];
    }

protected:

    //! Operator interface    
    numeric_sequence& operator+= ( const numeric_sequence& p )
    {
        typedef boost::fusion::vector<numeric_array&, const numeric_sequence&> sequences;
        boost::fusion::for_each( boost::fusion::zip_view<sequences>( sequences( m_sequence, p ) ), make_fused_procedure( boost::lambda::_1 += boost::lambda::_2 ) );
        return *this;
    }

    // numeric_sequence operator+(numeric_sequence, const numeric_sequence&) automatically
    // generated by addable.

    numeric_sequence& operator-= ( const numeric_sequence& p )
    {
        typedef boost::fusion::vector<numeric_array&, const numeric_sequence&> sequences;
        boost::fusion::for_each( boost::fusion::zip_view<sequences>( sequences( m_sequence, p ) ), make_fused_procedure( boost::lambda::_1 -= boost::lambda::_2 ) );
        return *this;
    }
    // numeric_sequence operator-(numeric_sequence, const numeric_sequence&) automatically
    // generated by subtractable.

    numeric_sequence& operator*= ( const numeric_type& v )
    {
        boost::fusion::for_each( m_sequence, boost::lambda::_1 *= v );
        return *this;
    }
    // numeric_sequence operator*(numeric_sequence, const T&) and
    // numeric_sequence operator*(const T&, numeric_sequence) auto-generated
    // by multipliable.

    numeric_sequence& operator/= ( const numeric_type& v ) 
    {
        boost::fusion::for_each( m_sequence, boost::lambda::_1 /= v );
        return *this;
    }
    // numeric_sequence operator/(numeric_sequence, const T&) auto-generated
    // by dividable.

    numeric_array m_sequence;

};
          
}//namespace geometrix;

#undef DIMENSION
