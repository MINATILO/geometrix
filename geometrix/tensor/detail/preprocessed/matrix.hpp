    //
    //! Copyright © 2008-2011
    //! Brandon Kohn
    //
    //  Distributed under the Boost Software License, Version 1.0. (See
    //  accompanying file LICENSE_1_0.txt or copy at
    //  http://www.boost.org/LICENSE_1_0.txt)
    //
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 1> >
{
    
    static boost::array< boost::array<T,1>, 1 > make_matrix_arrays( const T& a0 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 1 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 1> >
{ 
    static matrix<N, 1, 1> construct( const N& a0 )
    {
        matrix<N, 1, 1> r = { a0 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 1> r = { ( geometrix::get<0 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 2> >
{
    
    static boost::array< boost::array<T,2>, 1 > make_matrix_arrays( const T& a0 , const T& a1 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 1 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 2> >
{ 
    static matrix<N, 1, 2> construct( const N& a0 , const N& a1 )
    {
        matrix<N, 1, 2> r = { a0 , a1 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 3> >
{
    
    static boost::array< boost::array<T,3>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 1 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 3> >
{ 
    static matrix<N, 1, 3> construct( const N& a0 , const N& a1 , const N& a2 )
    {
        matrix<N, 1, 3> r = { a0 , a1 , a2 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 4> >
{
    
    static boost::array< boost::array<T,4>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 1 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 4> >
{ 
    static matrix<N, 1, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 )
    {
        matrix<N, 1, 4> r = { a0 , a1 , a2 , a3 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 5> >
{
    
    static boost::array< boost::array<T,5>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 1 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 5> >
{ 
    static matrix<N, 1, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 )
    {
        matrix<N, 1, 5> r = { a0 , a1 , a2 , a3 , a4 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 6> >
{
    
    static boost::array< boost::array<T,6>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 1 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 6> >
{ 
    static matrix<N, 1, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 )
    {
        matrix<N, 1, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 7> >
{
    
    static boost::array< boost::array<T,7>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 1 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 7> >
{ 
    static matrix<N, 1, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 )
    {
        matrix<N, 1, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 8> >
{
    
    static boost::array< boost::array<T,8>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 1 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 8> >
{ 
    static matrix<N, 1, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 )
    {
        matrix<N, 1, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 9> >
{
    
    static boost::array< boost::array<T,9>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 1 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 9> >
{ 
    static matrix<N, 1, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 )
    {
        matrix<N, 1, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,1, 10> >
{
    
    static boost::array< boost::array<T,10>, 1 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 1 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 1, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 1 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 1, 10> >
{ 
    static matrix<N, 1, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 )
    {
        matrix<N, 1, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 1, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 1, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<1, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 1> >
{
    
    static boost::array< boost::array<T,1>, 2 > make_matrix_arrays( const T& a0 , const T& a1 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 2 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 1> >
{ 
    static matrix<N, 2, 1> construct( const N& a0 , const N& a1 )
    {
        matrix<N, 2, 1> r = { a0 , a1 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 2> >
{
    
    static boost::array< boost::array<T,2>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 2 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 2> >
{ 
    static matrix<N, 2, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 )
    {
        matrix<N, 2, 2> r = { a0 , a1 , a2 , a3 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 3> >
{
    
    static boost::array< boost::array<T,3>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 2 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 3> >
{ 
    static matrix<N, 2, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 )
    {
        matrix<N, 2, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 4> >
{
    
    static boost::array< boost::array<T,4>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 2 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 4> >
{ 
    static matrix<N, 2, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 )
    {
        matrix<N, 2, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 5> >
{
    
    static boost::array< boost::array<T,5>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 2 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 5> >
{ 
    static matrix<N, 2, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 )
    {
        matrix<N, 2, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 6> >
{
    
    static boost::array< boost::array<T,6>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 2 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 6> >
{ 
    static matrix<N, 2, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 )
    {
        matrix<N, 2, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 7> >
{
    
    static boost::array< boost::array<T,7>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 2 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 7> >
{ 
    static matrix<N, 2, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 )
    {
        matrix<N, 2, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 8> >
{
    
    static boost::array< boost::array<T,8>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 2 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 8> >
{ 
    static matrix<N, 2, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 )
    {
        matrix<N, 2, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 9> >
{
    
    static boost::array< boost::array<T,9>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 2 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 9> >
{ 
    static matrix<N, 2, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 )
    {
        matrix<N, 2, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,2, 10> >
{
    
    static boost::array< boost::array<T,10>, 2 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 2 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 2, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 2 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 2, 10> >
{ 
    static matrix<N, 2, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 )
    {
        matrix<N, 2, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 2, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 2, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<2, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 1> >
{
    
    static boost::array< boost::array<T,1>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 3 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 1> >
{ 
    static matrix<N, 3, 1> construct( const N& a0 , const N& a1 , const N& a2 )
    {
        matrix<N, 3, 1> r = { a0 , a1 , a2 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 2> >
{
    
    static boost::array< boost::array<T,2>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 3 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 2> >
{ 
    static matrix<N, 3, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 )
    {
        matrix<N, 3, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 3> >
{
    
    static boost::array< boost::array<T,3>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 3 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 3> >
{ 
    static matrix<N, 3, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 )
    {
        matrix<N, 3, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 4> >
{
    
    static boost::array< boost::array<T,4>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 3 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 4> >
{ 
    static matrix<N, 3, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 )
    {
        matrix<N, 3, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 5> >
{
    
    static boost::array< boost::array<T,5>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 3 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 5> >
{ 
    static matrix<N, 3, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 )
    {
        matrix<N, 3, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 6> >
{
    
    static boost::array< boost::array<T,6>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 3 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 6> >
{ 
    static matrix<N, 3, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 )
    {
        matrix<N, 3, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 7> >
{
    
    static boost::array< boost::array<T,7>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 3 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 7> >
{ 
    static matrix<N, 3, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 )
    {
        matrix<N, 3, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 8> >
{
    
    static boost::array< boost::array<T,8>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 3 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 8> >
{ 
    static matrix<N, 3, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 )
    {
        matrix<N, 3, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 9> >
{
    
    static boost::array< boost::array<T,9>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 3 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 9> >
{ 
    static matrix<N, 3, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 )
    {
        matrix<N, 3, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,3, 10> >
{
    
    static boost::array< boost::array<T,10>, 3 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 3 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 3, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 3 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 3, 10> >
{ 
    static matrix<N, 3, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 )
    {
        matrix<N, 3, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 3, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 3, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<3, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 1> >
{
    
    static boost::array< boost::array<T,1>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 4 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 1> >
{ 
    static matrix<N, 4, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 )
    {
        matrix<N, 4, 1> r = { a0 , a1 , a2 , a3 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 2> >
{
    
    static boost::array< boost::array<T,2>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 4 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 2> >
{ 
    static matrix<N, 4, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 )
    {
        matrix<N, 4, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 3> >
{
    
    static boost::array< boost::array<T,3>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 4 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 3> >
{ 
    static matrix<N, 4, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 )
    {
        matrix<N, 4, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 4> >
{
    
    static boost::array< boost::array<T,4>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 4 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 4> >
{ 
    static matrix<N, 4, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 )
    {
        matrix<N, 4, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 5> >
{
    
    static boost::array< boost::array<T,5>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 4 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 5> >
{ 
    static matrix<N, 4, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 )
    {
        matrix<N, 4, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 6> >
{
    
    static boost::array< boost::array<T,6>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 4 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 6> >
{ 
    static matrix<N, 4, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 )
    {
        matrix<N, 4, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 7> >
{
    
    static boost::array< boost::array<T,7>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 4 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 7> >
{ 
    static matrix<N, 4, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 )
    {
        matrix<N, 4, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 8> >
{
    
    static boost::array< boost::array<T,8>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 4 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 8> >
{ 
    static matrix<N, 4, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 )
    {
        matrix<N, 4, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 9> >
{
    
    static boost::array< boost::array<T,9>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 4 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 9> >
{ 
    static matrix<N, 4, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 )
    {
        matrix<N, 4, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,4, 10> >
{
    
    static boost::array< boost::array<T,10>, 4 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 4 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 4, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 4 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 4, 10> >
{ 
    static matrix<N, 4, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 )
    {
        matrix<N, 4, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 4, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 4, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<4, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 1> >
{
    
    static boost::array< boost::array<T,1>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 5 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 1> >
{ 
    static matrix<N, 5, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 )
    {
        matrix<N, 5, 1> r = { a0 , a1 , a2 , a3 , a4 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 2> >
{
    
    static boost::array< boost::array<T,2>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 5 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 2> >
{ 
    static matrix<N, 5, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 )
    {
        matrix<N, 5, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 3> >
{
    
    static boost::array< boost::array<T,3>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 5 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 3> >
{ 
    static matrix<N, 5, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 )
    {
        matrix<N, 5, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 4> >
{
    
    static boost::array< boost::array<T,4>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 5 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 4> >
{ 
    static matrix<N, 5, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 )
    {
        matrix<N, 5, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 5> >
{
    
    static boost::array< boost::array<T,5>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 5 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 5> >
{ 
    static matrix<N, 5, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 )
    {
        matrix<N, 5, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 6> >
{
    
    static boost::array< boost::array<T,6>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 5 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 6> >
{ 
    static matrix<N, 5, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 )
    {
        matrix<N, 5, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 7> >
{
    
    static boost::array< boost::array<T,7>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 5 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 7> >
{ 
    static matrix<N, 5, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 )
    {
        matrix<N, 5, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 8> >
{
    
    static boost::array< boost::array<T,8>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 5 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 8> >
{ 
    static matrix<N, 5, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 )
    {
        matrix<N, 5, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 9> >
{
    
    static boost::array< boost::array<T,9>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 5 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 9> >
{ 
    static matrix<N, 5, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 )
    {
        matrix<N, 5, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,5, 10> >
{
    
    static boost::array< boost::array<T,10>, 5 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 5 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 5, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 5 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 5, 10> >
{ 
    static matrix<N, 5, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 )
    {
        matrix<N, 5, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 5, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 5, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<5, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 1> >
{
    
    static boost::array< boost::array<T,1>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 6 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 1> >
{ 
    static matrix<N, 6, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 )
    {
        matrix<N, 6, 1> r = { a0 , a1 , a2 , a3 , a4 , a5 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<5 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 2> >
{
    
    static boost::array< boost::array<T,2>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 6 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 2> >
{ 
    static matrix<N, 6, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 )
    {
        matrix<N, 6, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 3> >
{
    
    static boost::array< boost::array<T,3>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 6 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 3> >
{ 
    static matrix<N, 6, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 )
    {
        matrix<N, 6, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 4> >
{
    
    static boost::array< boost::array<T,4>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 6 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 4> >
{ 
    static matrix<N, 6, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 )
    {
        matrix<N, 6, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 5> >
{
    
    static boost::array< boost::array<T,5>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 6 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 5> >
{ 
    static matrix<N, 6, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 )
    {
        matrix<N, 6, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 6> >
{
    
    static boost::array< boost::array<T,6>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 6 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 6> >
{ 
    static matrix<N, 6, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 )
    {
        matrix<N, 6, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 7> >
{
    
    static boost::array< boost::array<T,7>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 6 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 7> >
{ 
    static matrix<N, 6, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 )
    {
        matrix<N, 6, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 8> >
{
    
    static boost::array< boost::array<T,8>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 6 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 8> >
{ 
    static matrix<N, 6, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 )
    {
        matrix<N, 6, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 9> >
{
    
    static boost::array< boost::array<T,9>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 6 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 9> >
{ 
    static matrix<N, 6, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 )
    {
        matrix<N, 6, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,6, 10> >
{
    
    static boost::array< boost::array<T,10>, 6 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 6 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 6, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 6 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 6, 10> >
{ 
    static matrix<N, 6, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 )
    {
        matrix<N, 6, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 6, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 6, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<5 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<6, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<5 , 9> ( lhs , geometrix::get<5 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 1> >
{
    
    static boost::array< boost::array<T,1>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 7 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 1> >
{ 
    static matrix<N, 7, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 )
    {
        matrix<N, 7, 1> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<6 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 2> >
{
    
    static boost::array< boost::array<T,2>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 7 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 2> >
{ 
    static matrix<N, 7, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 )
    {
        matrix<N, 7, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 3> >
{
    
    static boost::array< boost::array<T,3>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 7 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 3> >
{ 
    static matrix<N, 7, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 )
    {
        matrix<N, 7, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 4> >
{
    
    static boost::array< boost::array<T,4>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 7 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 4> >
{ 
    static matrix<N, 7, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 )
    {
        matrix<N, 7, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 5> >
{
    
    static boost::array< boost::array<T,5>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 7 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 5> >
{ 
    static matrix<N, 7, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 )
    {
        matrix<N, 7, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 6> >
{
    
    static boost::array< boost::array<T,6>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 7 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 6> >
{ 
    static matrix<N, 7, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 )
    {
        matrix<N, 7, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 7> >
{
    
    static boost::array< boost::array<T,7>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 7 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 7> >
{ 
    static matrix<N, 7, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 )
    {
        matrix<N, 7, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 8> >
{
    
    static boost::array< boost::array<T,8>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 7 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 8> >
{ 
    static matrix<N, 7, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 )
    {
        matrix<N, 7, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 9> >
{
    
    static boost::array< boost::array<T,9>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 7 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 9> >
{ 
    static matrix<N, 7, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 )
    {
        matrix<N, 7, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,7, 10> >
{
    
    static boost::array< boost::array<T,10>, 7 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 7 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 7, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 7 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 7, 10> >
{ 
    static matrix<N, 7, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 )
    {
        matrix<N, 7, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 7, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 7, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<5 , 9> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<6 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<7, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<5 , 9> ( lhs , geometrix::get<5 , 9> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<6 , 9> ( lhs , geometrix::get<6 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 1> >
{
    
    static boost::array< boost::array<T,1>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 8 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 1> >
{ 
    static matrix<N, 8, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 )
    {
        matrix<N, 8, 1> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<7 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 2> >
{
    
    static boost::array< boost::array<T,2>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 8 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 2> >
{ 
    static matrix<N, 8, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 )
    {
        matrix<N, 8, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 3> >
{
    
    static boost::array< boost::array<T,3>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 8 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 3> >
{ 
    static matrix<N, 8, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 )
    {
        matrix<N, 8, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 4> >
{
    
    static boost::array< boost::array<T,4>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 8 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 4> >
{ 
    static matrix<N, 8, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 )
    {
        matrix<N, 8, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 5> >
{
    
    static boost::array< boost::array<T,5>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 8 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 5> >
{ 
    static matrix<N, 8, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 )
    {
        matrix<N, 8, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 6> >
{
    
    static boost::array< boost::array<T,6>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 8 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 6> >
{ 
    static matrix<N, 8, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 )
    {
        matrix<N, 8, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 7> >
{
    
    static boost::array< boost::array<T,7>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 8 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 7> >
{ 
    static matrix<N, 8, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 )
    {
        matrix<N, 8, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 8> >
{
    
    static boost::array< boost::array<T,8>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 8 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 8> >
{ 
    static matrix<N, 8, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 )
    {
        matrix<N, 8, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 9> >
{
    
    static boost::array< boost::array<T,9>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 8 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 9> >
{ 
    static matrix<N, 8, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 )
    {
        matrix<N, 8, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,8, 10> >
{
    
    static boost::array< boost::array<T,10>, 8 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 8 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 8, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 8 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 8, 10> >
{ 
    static matrix<N, 8, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 )
    {
        matrix<N, 8, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 8, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 8, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<5 , 9> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<6 , 9> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ), ( geometrix::get<7 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<8, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<5 , 9> ( lhs , geometrix::get<5 , 9> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<6 , 9> ( lhs , geometrix::get<6 , 9> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) ); geometrix::set<7 , 9> ( lhs , geometrix::get<7 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 1> >
{
    
    static boost::array< boost::array<T,1>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 9 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 1> >
{ 
    static matrix<N, 9, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 )
    {
        matrix<N, 9, 1> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<8 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 2> >
{
    
    static boost::array< boost::array<T,2>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 9 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 2> >
{ 
    static matrix<N, 9, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 )
    {
        matrix<N, 9, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 3> >
{
    
    static boost::array< boost::array<T,3>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 9 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 3> >
{ 
    static matrix<N, 9, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 )
    {
        matrix<N, 9, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 4> >
{
    
    static boost::array< boost::array<T,4>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 9 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 4> >
{ 
    static matrix<N, 9, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 )
    {
        matrix<N, 9, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 5> >
{
    
    static boost::array< boost::array<T,5>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 9 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 5> >
{ 
    static matrix<N, 9, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 )
    {
        matrix<N, 9, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 6> >
{
    
    static boost::array< boost::array<T,6>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 9 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 6> >
{ 
    static matrix<N, 9, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 )
    {
        matrix<N, 9, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 7> >
{
    
    static boost::array< boost::array<T,7>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 9 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 7> >
{ 
    static matrix<N, 9, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 )
    {
        matrix<N, 9, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 8> >
{
    
    static boost::array< boost::array<T,8>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 9 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 8> >
{ 
    static matrix<N, 9, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 )
    {
        matrix<N, 9, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 9> >
{
    
    static boost::array< boost::array<T,9>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 , const T& a80 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 9 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 9> >
{ 
    static matrix<N, 9, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 , const N& a80 )
    {
        matrix<N, 9, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ), ( geometrix::get<8 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) ); geometrix::set<8 , 8> ( lhs , geometrix::get<8 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,9, 10> >
{
    
    static boost::array< boost::array<T,10>, 9 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 , const T& a80 , const T& a81 , const T& a82 , const T& a83 , const T& a84 , const T& a85 , const T& a86 , const T& a87 , const T& a88 , const T& a89 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 9 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 9, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 9 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 9, 10> >
{ 
    static matrix<N, 9, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 , const N& a80 , const N& a81 , const N& a82 , const N& a83 , const N& a84 , const N& a85 , const N& a86 , const N& a87 , const N& a88 , const N& a89 )
    {
        matrix<N, 9, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 9, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 9, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<5 , 9> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<6 , 9> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ), ( geometrix::get<7 , 9> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ), ( geometrix::get<8 , 8> ( m ) ), ( geometrix::get<8 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<9, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<5 , 9> ( lhs , geometrix::get<5 , 9> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<6 , 9> ( lhs , geometrix::get<6 , 9> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) ); geometrix::set<7 , 9> ( lhs , geometrix::get<7 , 9> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) ); geometrix::set<8 , 8> ( lhs , geometrix::get<8 , 8> ( rhs ) ); geometrix::set<8 , 9> ( lhs , geometrix::get<8 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 1> >
{
    
    static boost::array< boost::array<T,1>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 )
    {
        typedef boost::array< T, 1 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 1>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 1>, 10 > m;
    boost::array<T,1>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,1>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 1> >
{ 
    static matrix<N, 10, 1> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 )
    {
        matrix<N, 10, 1> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 1> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 1> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<9 , 0> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 1>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 2> >
{
    
    static boost::array< boost::array<T,2>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 )
    {
        typedef boost::array< T, 2 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 2>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 2>, 10 > m;
    boost::array<T,2>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,2>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 2> >
{ 
    static matrix<N, 10, 2> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 )
    {
        matrix<N, 10, 2> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 2> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 2> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 2>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 3> >
{
    
    static boost::array< boost::array<T,3>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 )
    {
        typedef boost::array< T, 3 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 3>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 3>, 10 > m;
    boost::array<T,3>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,3>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 3> >
{ 
    static matrix<N, 10, 3> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 )
    {
        matrix<N, 10, 3> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 3> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 3> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 3>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 4> >
{
    
    static boost::array< boost::array<T,4>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 )
    {
        typedef boost::array< T, 4 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 4>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 4>, 10 > m;
    boost::array<T,4>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,4>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 4> >
{ 
    static matrix<N, 10, 4> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 )
    {
        matrix<N, 10, 4> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 4> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 4> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 4>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 5> >
{
    
    static boost::array< boost::array<T,5>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 )
    {
        typedef boost::array< T, 5 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 5>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 5>, 10 > m;
    boost::array<T,5>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,5>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 5> >
{ 
    static matrix<N, 10, 5> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 )
    {
        matrix<N, 10, 5> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 5> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 5> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 5>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 6> >
{
    
    static boost::array< boost::array<T,6>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 )
    {
        typedef boost::array< T, 6 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 6>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 6>, 10 > m;
    boost::array<T,6>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,6>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 6> >
{ 
    static matrix<N, 10, 6> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 )
    {
        matrix<N, 10, 6> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 6> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 6> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ), ( geometrix::get<9 , 5> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 6>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) ); geometrix::set<9 , 5> ( lhs , geometrix::get<9 , 5> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 7> >
{
    
    static boost::array< boost::array<T,7>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 )
    {
        typedef boost::array< T, 7 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 7>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 7>, 10 > m;
    boost::array<T,7>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,7>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 7> >
{ 
    static matrix<N, 10, 7> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 )
    {
        matrix<N, 10, 7> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 7> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 7> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ), ( geometrix::get<9 , 5> ( m ) ), ( geometrix::get<9 , 6> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 7>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) ); geometrix::set<9 , 5> ( lhs , geometrix::get<9 , 5> ( rhs ) ); geometrix::set<9 , 6> ( lhs , geometrix::get<9 , 6> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 8> >
{
    
    static boost::array< boost::array<T,8>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 )
    {
        typedef boost::array< T, 8 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 8>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 8>, 10 > m;
    boost::array<T,8>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,8>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 8> >
{ 
    static matrix<N, 10, 8> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 )
    {
        matrix<N, 10, 8> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 8> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 8> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ), ( geometrix::get<9 , 5> ( m ) ), ( geometrix::get<9 , 6> ( m ) ), ( geometrix::get<9 , 7> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 8>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) ); geometrix::set<9 , 5> ( lhs , geometrix::get<9 , 5> ( rhs ) ); geometrix::set<9 , 6> ( lhs , geometrix::get<9 , 6> ( rhs ) ); geometrix::set<9 , 7> ( lhs , geometrix::get<9 , 7> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 9> >
{
    
    static boost::array< boost::array<T,9>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 , const T& a80 , const T& a81 , const T& a82 , const T& a83 , const T& a84 , const T& a85 , const T& a86 , const T& a87 , const T& a88 , const T& a89 )
    {
        typedef boost::array< T, 9 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 9>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 9>, 10 > m;
    boost::array<T,9>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,9>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 9> >
{ 
    static matrix<N, 10, 9> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 , const N& a80 , const N& a81 , const N& a82 , const N& a83 , const N& a84 , const N& a85 , const N& a86 , const N& a87 , const N& a88 , const N& a89 )
    {
        matrix<N, 10, 9> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 9> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 9> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ), ( geometrix::get<8 , 8> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ), ( geometrix::get<9 , 5> ( m ) ), ( geometrix::get<9 , 6> ( m ) ), ( geometrix::get<9 , 7> ( m ) ), ( geometrix::get<9 , 8> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 9>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) ); geometrix::set<8 , 8> ( lhs , geometrix::get<8 , 8> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) ); geometrix::set<9 , 5> ( lhs , geometrix::get<9 , 5> ( rhs ) ); geometrix::set<9 , 6> ( lhs , geometrix::get<9 , 6> ( rhs ) ); geometrix::set<9 , 7> ( lhs , geometrix::get<9 , 7> ( rhs ) ); geometrix::set<9 , 8> ( lhs , geometrix::get<9 , 8> ( rhs ) );;
            return lhs;
        }
    };
}
}
namespace geometrix {
    
template <typename T>
struct make_matrix_dispatch< matrix<T,10, 10> >
{
    
    static boost::array< boost::array<T,10>, 10 > make_matrix_arrays( const T& a0 , const T& a1 , const T& a2 , const T& a3 , const T& a4 , const T& a5 , const T& a6 , const T& a7 , const T& a8 , const T& a9 , const T& a10 , const T& a11 , const T& a12 , const T& a13 , const T& a14 , const T& a15 , const T& a16 , const T& a17 , const T& a18 , const T& a19 , const T& a20 , const T& a21 , const T& a22 , const T& a23 , const T& a24 , const T& a25 , const T& a26 , const T& a27 , const T& a28 , const T& a29 , const T& a30 , const T& a31 , const T& a32 , const T& a33 , const T& a34 , const T& a35 , const T& a36 , const T& a37 , const T& a38 , const T& a39 , const T& a40 , const T& a41 , const T& a42 , const T& a43 , const T& a44 , const T& a45 , const T& a46 , const T& a47 , const T& a48 , const T& a49 , const T& a50 , const T& a51 , const T& a52 , const T& a53 , const T& a54 , const T& a55 , const T& a56 , const T& a57 , const T& a58 , const T& a59 , const T& a60 , const T& a61 , const T& a62 , const T& a63 , const T& a64 , const T& a65 , const T& a66 , const T& a67 , const T& a68 , const T& a69 , const T& a70 , const T& a71 , const T& a72 , const T& a73 , const T& a74 , const T& a75 , const T& a76 , const T& a77 , const T& a78 , const T& a79 , const T& a80 , const T& a81 , const T& a82 , const T& a83 , const T& a84 , const T& a85 , const T& a86 , const T& a87 , const T& a88 , const T& a89 , const T& a90 , const T& a91 , const T& a92 , const T& a93 , const T& a94 , const T& a95 , const T& a96 , const T& a97 , const T& a98 , const T& a99 )
    {
        typedef boost::array< T, 10 > row_type;
        typedef boost::array< row_type, 10 > matrix_type;
        matrix_type m = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 };
        return m;
    } 
};
template <typename T>
struct matrix<T, 10, 10>
{
    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
        
    boost::array< boost::array<T, 10>, 10 > m;
    boost::array<T,10>& operator[]( std::size_t i ) { return m[i]; }
    const boost::array<T,10>& operator[]( std::size_t i ) const { return m[i]; }
    
    template <int Row, int Column>
    const_reference get() const { return m[Row][Column]; }
    template <int Row, int Column>
    reference get(){ return m[Row][Column]; }
    const_reference get( int Row, int Column ) const { return m[Row][Column]; }
    reference get( int Row, int Column ){ return m[Row][Column]; }
};
template <typename N>
struct construction_policy< matrix< N, 10, 10> >
{ 
    static matrix<N, 10, 10> construct( const N& a0 , const N& a1 , const N& a2 , const N& a3 , const N& a4 , const N& a5 , const N& a6 , const N& a7 , const N& a8 , const N& a9 , const N& a10 , const N& a11 , const N& a12 , const N& a13 , const N& a14 , const N& a15 , const N& a16 , const N& a17 , const N& a18 , const N& a19 , const N& a20 , const N& a21 , const N& a22 , const N& a23 , const N& a24 , const N& a25 , const N& a26 , const N& a27 , const N& a28 , const N& a29 , const N& a30 , const N& a31 , const N& a32 , const N& a33 , const N& a34 , const N& a35 , const N& a36 , const N& a37 , const N& a38 , const N& a39 , const N& a40 , const N& a41 , const N& a42 , const N& a43 , const N& a44 , const N& a45 , const N& a46 , const N& a47 , const N& a48 , const N& a49 , const N& a50 , const N& a51 , const N& a52 , const N& a53 , const N& a54 , const N& a55 , const N& a56 , const N& a57 , const N& a58 , const N& a59 , const N& a60 , const N& a61 , const N& a62 , const N& a63 , const N& a64 , const N& a65 , const N& a66 , const N& a67 , const N& a68 , const N& a69 , const N& a70 , const N& a71 , const N& a72 , const N& a73 , const N& a74 , const N& a75 , const N& a76 , const N& a77 , const N& a78 , const N& a79 , const N& a80 , const N& a81 , const N& a82 , const N& a83 , const N& a84 , const N& a85 , const N& a86 , const N& a87 , const N& a88 , const N& a89 , const N& a90 , const N& a91 , const N& a92 , const N& a93 , const N& a94 , const N& a95 , const N& a96 , const N& a97 , const N& a98 , const N& a99 )
    {
        matrix<N, 10, 10> r = { a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 };
        return r;
    }
    template <typename Matrix> 
    static matrix<N, 10, 10> construct( const Matrix& m )
    { 
        boost::function_requires< CompileTimeAccessConcept< Matrix > >(); 
        matrix<N, 10, 10> r = { ( geometrix::get<0 , 0> ( m ) ), ( geometrix::get<0 , 1> ( m ) ), ( geometrix::get<0 , 2> ( m ) ), ( geometrix::get<0 , 3> ( m ) ), ( geometrix::get<0 , 4> ( m ) ), ( geometrix::get<0 , 5> ( m ) ), ( geometrix::get<0 , 6> ( m ) ), ( geometrix::get<0 , 7> ( m ) ), ( geometrix::get<0 , 8> ( m ) ), ( geometrix::get<0 , 9> ( m ) ), ( geometrix::get<1 , 0> ( m ) ), ( geometrix::get<1 , 1> ( m ) ), ( geometrix::get<1 , 2> ( m ) ), ( geometrix::get<1 , 3> ( m ) ), ( geometrix::get<1 , 4> ( m ) ), ( geometrix::get<1 , 5> ( m ) ), ( geometrix::get<1 , 6> ( m ) ), ( geometrix::get<1 , 7> ( m ) ), ( geometrix::get<1 , 8> ( m ) ), ( geometrix::get<1 , 9> ( m ) ), ( geometrix::get<2 , 0> ( m ) ), ( geometrix::get<2 , 1> ( m ) ), ( geometrix::get<2 , 2> ( m ) ), ( geometrix::get<2 , 3> ( m ) ), ( geometrix::get<2 , 4> ( m ) ), ( geometrix::get<2 , 5> ( m ) ), ( geometrix::get<2 , 6> ( m ) ), ( geometrix::get<2 , 7> ( m ) ), ( geometrix::get<2 , 8> ( m ) ), ( geometrix::get<2 , 9> ( m ) ), ( geometrix::get<3 , 0> ( m ) ), ( geometrix::get<3 , 1> ( m ) ), ( geometrix::get<3 , 2> ( m ) ), ( geometrix::get<3 , 3> ( m ) ), ( geometrix::get<3 , 4> ( m ) ), ( geometrix::get<3 , 5> ( m ) ), ( geometrix::get<3 , 6> ( m ) ), ( geometrix::get<3 , 7> ( m ) ), ( geometrix::get<3 , 8> ( m ) ), ( geometrix::get<3 , 9> ( m ) ), ( geometrix::get<4 , 0> ( m ) ), ( geometrix::get<4 , 1> ( m ) ), ( geometrix::get<4 , 2> ( m ) ), ( geometrix::get<4 , 3> ( m ) ), ( geometrix::get<4 , 4> ( m ) ), ( geometrix::get<4 , 5> ( m ) ), ( geometrix::get<4 , 6> ( m ) ), ( geometrix::get<4 , 7> ( m ) ), ( geometrix::get<4 , 8> ( m ) ), ( geometrix::get<4 , 9> ( m ) ), ( geometrix::get<5 , 0> ( m ) ), ( geometrix::get<5 , 1> ( m ) ), ( geometrix::get<5 , 2> ( m ) ), ( geometrix::get<5 , 3> ( m ) ), ( geometrix::get<5 , 4> ( m ) ), ( geometrix::get<5 , 5> ( m ) ), ( geometrix::get<5 , 6> ( m ) ), ( geometrix::get<5 , 7> ( m ) ), ( geometrix::get<5 , 8> ( m ) ), ( geometrix::get<5 , 9> ( m ) ), ( geometrix::get<6 , 0> ( m ) ), ( geometrix::get<6 , 1> ( m ) ), ( geometrix::get<6 , 2> ( m ) ), ( geometrix::get<6 , 3> ( m ) ), ( geometrix::get<6 , 4> ( m ) ), ( geometrix::get<6 , 5> ( m ) ), ( geometrix::get<6 , 6> ( m ) ), ( geometrix::get<6 , 7> ( m ) ), ( geometrix::get<6 , 8> ( m ) ), ( geometrix::get<6 , 9> ( m ) ), ( geometrix::get<7 , 0> ( m ) ), ( geometrix::get<7 , 1> ( m ) ), ( geometrix::get<7 , 2> ( m ) ), ( geometrix::get<7 , 3> ( m ) ), ( geometrix::get<7 , 4> ( m ) ), ( geometrix::get<7 , 5> ( m ) ), ( geometrix::get<7 , 6> ( m ) ), ( geometrix::get<7 , 7> ( m ) ), ( geometrix::get<7 , 8> ( m ) ), ( geometrix::get<7 , 9> ( m ) ), ( geometrix::get<8 , 0> ( m ) ), ( geometrix::get<8 , 1> ( m ) ), ( geometrix::get<8 , 2> ( m ) ), ( geometrix::get<8 , 3> ( m ) ), ( geometrix::get<8 , 4> ( m ) ), ( geometrix::get<8 , 5> ( m ) ), ( geometrix::get<8 , 6> ( m ) ), ( geometrix::get<8 , 7> ( m ) ), ( geometrix::get<8 , 8> ( m ) ), ( geometrix::get<8 , 9> ( m ) ), ( geometrix::get<9 , 0> ( m ) ), ( geometrix::get<9 , 1> ( m ) ), ( geometrix::get<9 , 2> ( m ) ), ( geometrix::get<9 , 3> ( m ) ), ( geometrix::get<9 , 4> ( m ) ), ( geometrix::get<9 , 5> ( m ) ), ( geometrix::get<9 , 6> ( m ) ), ( geometrix::get<9 , 7> ( m ) ), ( geometrix::get<9 , 8> ( m ) ), ( geometrix::get<9 , 9> ( m ) ) };
        return r;
    }
};
namespace detail
{
    template <>
    struct matrix_assign_helper<10, 10>
    { 
        template <typename LHS, typename RHS>
        static LHS& assign(LHS& lhs, const RHS& rhs)
        {
            geometrix::set<0 , 0> ( lhs , geometrix::get<0 , 0> ( rhs ) ); geometrix::set<0 , 1> ( lhs , geometrix::get<0 , 1> ( rhs ) ); geometrix::set<0 , 2> ( lhs , geometrix::get<0 , 2> ( rhs ) ); geometrix::set<0 , 3> ( lhs , geometrix::get<0 , 3> ( rhs ) ); geometrix::set<0 , 4> ( lhs , geometrix::get<0 , 4> ( rhs ) ); geometrix::set<0 , 5> ( lhs , geometrix::get<0 , 5> ( rhs ) ); geometrix::set<0 , 6> ( lhs , geometrix::get<0 , 6> ( rhs ) ); geometrix::set<0 , 7> ( lhs , geometrix::get<0 , 7> ( rhs ) ); geometrix::set<0 , 8> ( lhs , geometrix::get<0 , 8> ( rhs ) ); geometrix::set<0 , 9> ( lhs , geometrix::get<0 , 9> ( rhs ) ); geometrix::set<1 , 0> ( lhs , geometrix::get<1 , 0> ( rhs ) ); geometrix::set<1 , 1> ( lhs , geometrix::get<1 , 1> ( rhs ) ); geometrix::set<1 , 2> ( lhs , geometrix::get<1 , 2> ( rhs ) ); geometrix::set<1 , 3> ( lhs , geometrix::get<1 , 3> ( rhs ) ); geometrix::set<1 , 4> ( lhs , geometrix::get<1 , 4> ( rhs ) ); geometrix::set<1 , 5> ( lhs , geometrix::get<1 , 5> ( rhs ) ); geometrix::set<1 , 6> ( lhs , geometrix::get<1 , 6> ( rhs ) ); geometrix::set<1 , 7> ( lhs , geometrix::get<1 , 7> ( rhs ) ); geometrix::set<1 , 8> ( lhs , geometrix::get<1 , 8> ( rhs ) ); geometrix::set<1 , 9> ( lhs , geometrix::get<1 , 9> ( rhs ) ); geometrix::set<2 , 0> ( lhs , geometrix::get<2 , 0> ( rhs ) ); geometrix::set<2 , 1> ( lhs , geometrix::get<2 , 1> ( rhs ) ); geometrix::set<2 , 2> ( lhs , geometrix::get<2 , 2> ( rhs ) ); geometrix::set<2 , 3> ( lhs , geometrix::get<2 , 3> ( rhs ) ); geometrix::set<2 , 4> ( lhs , geometrix::get<2 , 4> ( rhs ) ); geometrix::set<2 , 5> ( lhs , geometrix::get<2 , 5> ( rhs ) ); geometrix::set<2 , 6> ( lhs , geometrix::get<2 , 6> ( rhs ) ); geometrix::set<2 , 7> ( lhs , geometrix::get<2 , 7> ( rhs ) ); geometrix::set<2 , 8> ( lhs , geometrix::get<2 , 8> ( rhs ) ); geometrix::set<2 , 9> ( lhs , geometrix::get<2 , 9> ( rhs ) ); geometrix::set<3 , 0> ( lhs , geometrix::get<3 , 0> ( rhs ) ); geometrix::set<3 , 1> ( lhs , geometrix::get<3 , 1> ( rhs ) ); geometrix::set<3 , 2> ( lhs , geometrix::get<3 , 2> ( rhs ) ); geometrix::set<3 , 3> ( lhs , geometrix::get<3 , 3> ( rhs ) ); geometrix::set<3 , 4> ( lhs , geometrix::get<3 , 4> ( rhs ) ); geometrix::set<3 , 5> ( lhs , geometrix::get<3 , 5> ( rhs ) ); geometrix::set<3 , 6> ( lhs , geometrix::get<3 , 6> ( rhs ) ); geometrix::set<3 , 7> ( lhs , geometrix::get<3 , 7> ( rhs ) ); geometrix::set<3 , 8> ( lhs , geometrix::get<3 , 8> ( rhs ) ); geometrix::set<3 , 9> ( lhs , geometrix::get<3 , 9> ( rhs ) ); geometrix::set<4 , 0> ( lhs , geometrix::get<4 , 0> ( rhs ) ); geometrix::set<4 , 1> ( lhs , geometrix::get<4 , 1> ( rhs ) ); geometrix::set<4 , 2> ( lhs , geometrix::get<4 , 2> ( rhs ) ); geometrix::set<4 , 3> ( lhs , geometrix::get<4 , 3> ( rhs ) ); geometrix::set<4 , 4> ( lhs , geometrix::get<4 , 4> ( rhs ) ); geometrix::set<4 , 5> ( lhs , geometrix::get<4 , 5> ( rhs ) ); geometrix::set<4 , 6> ( lhs , geometrix::get<4 , 6> ( rhs ) ); geometrix::set<4 , 7> ( lhs , geometrix::get<4 , 7> ( rhs ) ); geometrix::set<4 , 8> ( lhs , geometrix::get<4 , 8> ( rhs ) ); geometrix::set<4 , 9> ( lhs , geometrix::get<4 , 9> ( rhs ) ); geometrix::set<5 , 0> ( lhs , geometrix::get<5 , 0> ( rhs ) ); geometrix::set<5 , 1> ( lhs , geometrix::get<5 , 1> ( rhs ) ); geometrix::set<5 , 2> ( lhs , geometrix::get<5 , 2> ( rhs ) ); geometrix::set<5 , 3> ( lhs , geometrix::get<5 , 3> ( rhs ) ); geometrix::set<5 , 4> ( lhs , geometrix::get<5 , 4> ( rhs ) ); geometrix::set<5 , 5> ( lhs , geometrix::get<5 , 5> ( rhs ) ); geometrix::set<5 , 6> ( lhs , geometrix::get<5 , 6> ( rhs ) ); geometrix::set<5 , 7> ( lhs , geometrix::get<5 , 7> ( rhs ) ); geometrix::set<5 , 8> ( lhs , geometrix::get<5 , 8> ( rhs ) ); geometrix::set<5 , 9> ( lhs , geometrix::get<5 , 9> ( rhs ) ); geometrix::set<6 , 0> ( lhs , geometrix::get<6 , 0> ( rhs ) ); geometrix::set<6 , 1> ( lhs , geometrix::get<6 , 1> ( rhs ) ); geometrix::set<6 , 2> ( lhs , geometrix::get<6 , 2> ( rhs ) ); geometrix::set<6 , 3> ( lhs , geometrix::get<6 , 3> ( rhs ) ); geometrix::set<6 , 4> ( lhs , geometrix::get<6 , 4> ( rhs ) ); geometrix::set<6 , 5> ( lhs , geometrix::get<6 , 5> ( rhs ) ); geometrix::set<6 , 6> ( lhs , geometrix::get<6 , 6> ( rhs ) ); geometrix::set<6 , 7> ( lhs , geometrix::get<6 , 7> ( rhs ) ); geometrix::set<6 , 8> ( lhs , geometrix::get<6 , 8> ( rhs ) ); geometrix::set<6 , 9> ( lhs , geometrix::get<6 , 9> ( rhs ) ); geometrix::set<7 , 0> ( lhs , geometrix::get<7 , 0> ( rhs ) ); geometrix::set<7 , 1> ( lhs , geometrix::get<7 , 1> ( rhs ) ); geometrix::set<7 , 2> ( lhs , geometrix::get<7 , 2> ( rhs ) ); geometrix::set<7 , 3> ( lhs , geometrix::get<7 , 3> ( rhs ) ); geometrix::set<7 , 4> ( lhs , geometrix::get<7 , 4> ( rhs ) ); geometrix::set<7 , 5> ( lhs , geometrix::get<7 , 5> ( rhs ) ); geometrix::set<7 , 6> ( lhs , geometrix::get<7 , 6> ( rhs ) ); geometrix::set<7 , 7> ( lhs , geometrix::get<7 , 7> ( rhs ) ); geometrix::set<7 , 8> ( lhs , geometrix::get<7 , 8> ( rhs ) ); geometrix::set<7 , 9> ( lhs , geometrix::get<7 , 9> ( rhs ) ); geometrix::set<8 , 0> ( lhs , geometrix::get<8 , 0> ( rhs ) ); geometrix::set<8 , 1> ( lhs , geometrix::get<8 , 1> ( rhs ) ); geometrix::set<8 , 2> ( lhs , geometrix::get<8 , 2> ( rhs ) ); geometrix::set<8 , 3> ( lhs , geometrix::get<8 , 3> ( rhs ) ); geometrix::set<8 , 4> ( lhs , geometrix::get<8 , 4> ( rhs ) ); geometrix::set<8 , 5> ( lhs , geometrix::get<8 , 5> ( rhs ) ); geometrix::set<8 , 6> ( lhs , geometrix::get<8 , 6> ( rhs ) ); geometrix::set<8 , 7> ( lhs , geometrix::get<8 , 7> ( rhs ) ); geometrix::set<8 , 8> ( lhs , geometrix::get<8 , 8> ( rhs ) ); geometrix::set<8 , 9> ( lhs , geometrix::get<8 , 9> ( rhs ) ); geometrix::set<9 , 0> ( lhs , geometrix::get<9 , 0> ( rhs ) ); geometrix::set<9 , 1> ( lhs , geometrix::get<9 , 1> ( rhs ) ); geometrix::set<9 , 2> ( lhs , geometrix::get<9 , 2> ( rhs ) ); geometrix::set<9 , 3> ( lhs , geometrix::get<9 , 3> ( rhs ) ); geometrix::set<9 , 4> ( lhs , geometrix::get<9 , 4> ( rhs ) ); geometrix::set<9 , 5> ( lhs , geometrix::get<9 , 5> ( rhs ) ); geometrix::set<9 , 6> ( lhs , geometrix::get<9 , 6> ( rhs ) ); geometrix::set<9 , 7> ( lhs , geometrix::get<9 , 7> ( rhs ) ); geometrix::set<9 , 8> ( lhs , geometrix::get<9 , 8> ( rhs ) ); geometrix::set<9 , 9> ( lhs , geometrix::get<9 , 9> ( rhs ) );;
            return lhs;
        }
    };
}
}
    
    
    
    
    namespace geometrix { namespace detail
    {
        typedef long double long_double;
    }}
    namespace geometrix { typedef matrix<double, 1, 1> matrix_double_1x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x1,0> matrix_double_1x1_row0; } template <> struct geometric_traits<detail::matrix_double_1x1_row0> { typedef detail::matrix_double_1x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x1,0> matrix_double_1x1_column0; }template <> struct geometric_traits<detail::matrix_double_1x1_column0> { typedef detail::matrix_double_1x1_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x1>::type > : index_operator_matrix_access_policy < matrix_double_1x1 > { typedef index_operator_matrix_access_policy < matrix_double_1x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x1 > { typedef dimension<1> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 2> matrix_double_1x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x2,0> matrix_double_1x2_row0; } template <> struct geometric_traits<detail::matrix_double_1x2_row0> { typedef detail::matrix_double_1x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x2,0> matrix_double_1x2_column0; }template <> struct geometric_traits<detail::matrix_double_1x2_column0> { typedef detail::matrix_double_1x2_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x2,1> matrix_double_1x2_column1; }template <> struct geometric_traits<detail::matrix_double_1x2_column1> { typedef detail::matrix_double_1x2_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x2>::type > : index_operator_matrix_access_policy < matrix_double_1x2 > { typedef index_operator_matrix_access_policy < matrix_double_1x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x2 > { typedef dimension<1> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 3> matrix_double_1x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x3,0> matrix_double_1x3_row0; } template <> struct geometric_traits<detail::matrix_double_1x3_row0> { typedef detail::matrix_double_1x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x3,0> matrix_double_1x3_column0; }template <> struct geometric_traits<detail::matrix_double_1x3_column0> { typedef detail::matrix_double_1x3_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x3,1> matrix_double_1x3_column1; }template <> struct geometric_traits<detail::matrix_double_1x3_column1> { typedef detail::matrix_double_1x3_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x3,2> matrix_double_1x3_column2; }template <> struct geometric_traits<detail::matrix_double_1x3_column2> { typedef detail::matrix_double_1x3_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x3>::type > : index_operator_matrix_access_policy < matrix_double_1x3 > { typedef index_operator_matrix_access_policy < matrix_double_1x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x3 > { typedef dimension<1> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 4> matrix_double_1x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x4,0> matrix_double_1x4_row0; } template <> struct geometric_traits<detail::matrix_double_1x4_row0> { typedef detail::matrix_double_1x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x4,0> matrix_double_1x4_column0; }template <> struct geometric_traits<detail::matrix_double_1x4_column0> { typedef detail::matrix_double_1x4_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x4,1> matrix_double_1x4_column1; }template <> struct geometric_traits<detail::matrix_double_1x4_column1> { typedef detail::matrix_double_1x4_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x4,2> matrix_double_1x4_column2; }template <> struct geometric_traits<detail::matrix_double_1x4_column2> { typedef detail::matrix_double_1x4_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x4,3> matrix_double_1x4_column3; }template <> struct geometric_traits<detail::matrix_double_1x4_column3> { typedef detail::matrix_double_1x4_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x4>::type > : index_operator_matrix_access_policy < matrix_double_1x4 > { typedef index_operator_matrix_access_policy < matrix_double_1x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x4 > { typedef dimension<1> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 5> matrix_double_1x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x5,0> matrix_double_1x5_row0; } template <> struct geometric_traits<detail::matrix_double_1x5_row0> { typedef detail::matrix_double_1x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x5,0> matrix_double_1x5_column0; }template <> struct geometric_traits<detail::matrix_double_1x5_column0> { typedef detail::matrix_double_1x5_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x5,1> matrix_double_1x5_column1; }template <> struct geometric_traits<detail::matrix_double_1x5_column1> { typedef detail::matrix_double_1x5_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x5,2> matrix_double_1x5_column2; }template <> struct geometric_traits<detail::matrix_double_1x5_column2> { typedef detail::matrix_double_1x5_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x5,3> matrix_double_1x5_column3; }template <> struct geometric_traits<detail::matrix_double_1x5_column3> { typedef detail::matrix_double_1x5_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x5,4> matrix_double_1x5_column4; }template <> struct geometric_traits<detail::matrix_double_1x5_column4> { typedef detail::matrix_double_1x5_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x5>::type > : index_operator_matrix_access_policy < matrix_double_1x5 > { typedef index_operator_matrix_access_policy < matrix_double_1x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x5 > { typedef dimension<1> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 6> matrix_double_1x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x6,0> matrix_double_1x6_row0; } template <> struct geometric_traits<detail::matrix_double_1x6_row0> { typedef detail::matrix_double_1x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,0> matrix_double_1x6_column0; }template <> struct geometric_traits<detail::matrix_double_1x6_column0> { typedef detail::matrix_double_1x6_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,1> matrix_double_1x6_column1; }template <> struct geometric_traits<detail::matrix_double_1x6_column1> { typedef detail::matrix_double_1x6_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,2> matrix_double_1x6_column2; }template <> struct geometric_traits<detail::matrix_double_1x6_column2> { typedef detail::matrix_double_1x6_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,3> matrix_double_1x6_column3; }template <> struct geometric_traits<detail::matrix_double_1x6_column3> { typedef detail::matrix_double_1x6_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,4> matrix_double_1x6_column4; }template <> struct geometric_traits<detail::matrix_double_1x6_column4> { typedef detail::matrix_double_1x6_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x6,5> matrix_double_1x6_column5; }template <> struct geometric_traits<detail::matrix_double_1x6_column5> { typedef detail::matrix_double_1x6_column5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x6>::type > : index_operator_matrix_access_policy < matrix_double_1x6 > { typedef index_operator_matrix_access_policy < matrix_double_1x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x6 > { typedef dimension<1> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 7> matrix_double_1x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x7,0> matrix_double_1x7_row0; } template <> struct geometric_traits<detail::matrix_double_1x7_row0> { typedef detail::matrix_double_1x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,0> matrix_double_1x7_column0; }template <> struct geometric_traits<detail::matrix_double_1x7_column0> { typedef detail::matrix_double_1x7_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,1> matrix_double_1x7_column1; }template <> struct geometric_traits<detail::matrix_double_1x7_column1> { typedef detail::matrix_double_1x7_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,2> matrix_double_1x7_column2; }template <> struct geometric_traits<detail::matrix_double_1x7_column2> { typedef detail::matrix_double_1x7_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,3> matrix_double_1x7_column3; }template <> struct geometric_traits<detail::matrix_double_1x7_column3> { typedef detail::matrix_double_1x7_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,4> matrix_double_1x7_column4; }template <> struct geometric_traits<detail::matrix_double_1x7_column4> { typedef detail::matrix_double_1x7_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,5> matrix_double_1x7_column5; }template <> struct geometric_traits<detail::matrix_double_1x7_column5> { typedef detail::matrix_double_1x7_column5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x7,6> matrix_double_1x7_column6; }template <> struct geometric_traits<detail::matrix_double_1x7_column6> { typedef detail::matrix_double_1x7_column6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x7>::type > : index_operator_matrix_access_policy < matrix_double_1x7 > { typedef index_operator_matrix_access_policy < matrix_double_1x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x7 > { typedef dimension<1> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 8> matrix_double_1x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x8,0> matrix_double_1x8_row0; } template <> struct geometric_traits<detail::matrix_double_1x8_row0> { typedef detail::matrix_double_1x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,0> matrix_double_1x8_column0; }template <> struct geometric_traits<detail::matrix_double_1x8_column0> { typedef detail::matrix_double_1x8_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,1> matrix_double_1x8_column1; }template <> struct geometric_traits<detail::matrix_double_1x8_column1> { typedef detail::matrix_double_1x8_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,2> matrix_double_1x8_column2; }template <> struct geometric_traits<detail::matrix_double_1x8_column2> { typedef detail::matrix_double_1x8_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,3> matrix_double_1x8_column3; }template <> struct geometric_traits<detail::matrix_double_1x8_column3> { typedef detail::matrix_double_1x8_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,4> matrix_double_1x8_column4; }template <> struct geometric_traits<detail::matrix_double_1x8_column4> { typedef detail::matrix_double_1x8_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,5> matrix_double_1x8_column5; }template <> struct geometric_traits<detail::matrix_double_1x8_column5> { typedef detail::matrix_double_1x8_column5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,6> matrix_double_1x8_column6; }template <> struct geometric_traits<detail::matrix_double_1x8_column6> { typedef detail::matrix_double_1x8_column6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x8,7> matrix_double_1x8_column7; }template <> struct geometric_traits<detail::matrix_double_1x8_column7> { typedef detail::matrix_double_1x8_column7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x8>::type > : index_operator_matrix_access_policy < matrix_double_1x8 > { typedef index_operator_matrix_access_policy < matrix_double_1x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x8 > { typedef dimension<1> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 9> matrix_double_1x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x9,0> matrix_double_1x9_row0; } template <> struct geometric_traits<detail::matrix_double_1x9_row0> { typedef detail::matrix_double_1x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,0> matrix_double_1x9_column0; }template <> struct geometric_traits<detail::matrix_double_1x9_column0> { typedef detail::matrix_double_1x9_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,1> matrix_double_1x9_column1; }template <> struct geometric_traits<detail::matrix_double_1x9_column1> { typedef detail::matrix_double_1x9_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,2> matrix_double_1x9_column2; }template <> struct geometric_traits<detail::matrix_double_1x9_column2> { typedef detail::matrix_double_1x9_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,3> matrix_double_1x9_column3; }template <> struct geometric_traits<detail::matrix_double_1x9_column3> { typedef detail::matrix_double_1x9_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,4> matrix_double_1x9_column4; }template <> struct geometric_traits<detail::matrix_double_1x9_column4> { typedef detail::matrix_double_1x9_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,5> matrix_double_1x9_column5; }template <> struct geometric_traits<detail::matrix_double_1x9_column5> { typedef detail::matrix_double_1x9_column5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,6> matrix_double_1x9_column6; }template <> struct geometric_traits<detail::matrix_double_1x9_column6> { typedef detail::matrix_double_1x9_column6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,7> matrix_double_1x9_column7; }template <> struct geometric_traits<detail::matrix_double_1x9_column7> { typedef detail::matrix_double_1x9_column7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x9,8> matrix_double_1x9_column8; }template <> struct geometric_traits<detail::matrix_double_1x9_column8> { typedef detail::matrix_double_1x9_column8 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x9>::type > : index_operator_matrix_access_policy < matrix_double_1x9 > { typedef index_operator_matrix_access_policy < matrix_double_1x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x9 > { typedef dimension<1> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 1, 10> matrix_double_1x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_1x10,0> matrix_double_1x10_row0; } template <> struct geometric_traits<detail::matrix_double_1x10_row0> { typedef detail::matrix_double_1x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,0> matrix_double_1x10_column0; }template <> struct geometric_traits<detail::matrix_double_1x10_column0> { typedef detail::matrix_double_1x10_column0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,1> matrix_double_1x10_column1; }template <> struct geometric_traits<detail::matrix_double_1x10_column1> { typedef detail::matrix_double_1x10_column1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,2> matrix_double_1x10_column2; }template <> struct geometric_traits<detail::matrix_double_1x10_column2> { typedef detail::matrix_double_1x10_column2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,3> matrix_double_1x10_column3; }template <> struct geometric_traits<detail::matrix_double_1x10_column3> { typedef detail::matrix_double_1x10_column3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,4> matrix_double_1x10_column4; }template <> struct geometric_traits<detail::matrix_double_1x10_column4> { typedef detail::matrix_double_1x10_column4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,5> matrix_double_1x10_column5; }template <> struct geometric_traits<detail::matrix_double_1x10_column5> { typedef detail::matrix_double_1x10_column5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,6> matrix_double_1x10_column6; }template <> struct geometric_traits<detail::matrix_double_1x10_column6> { typedef detail::matrix_double_1x10_column6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,7> matrix_double_1x10_column7; }template <> struct geometric_traits<detail::matrix_double_1x10_column7> { typedef detail::matrix_double_1x10_column7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,8> matrix_double_1x10_column8; }template <> struct geometric_traits<detail::matrix_double_1x10_column8> { typedef detail::matrix_double_1x10_column8 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_1x10,9> matrix_double_1x10_column9; }template <> struct geometric_traits<detail::matrix_double_1x10_column9> { typedef detail::matrix_double_1x10_column9 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_1x10>::type > : index_operator_matrix_access_policy < matrix_double_1x10 > { typedef index_operator_matrix_access_policy < matrix_double_1x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_1x10 > { typedef dimension<1> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 1> matrix_double_2x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x1,0> matrix_double_2x1_row0; } template <> struct geometric_traits<detail::matrix_double_2x1_row0> { typedef detail::matrix_double_2x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x1,1> matrix_double_2x1_row1; } template <> struct geometric_traits<detail::matrix_double_2x1_row1> { typedef detail::matrix_double_2x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x1,0> matrix_double_2x1_column0; }template <> struct geometric_traits<detail::matrix_double_2x1_column0> { typedef detail::matrix_double_2x1_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x1>::type > : index_operator_matrix_access_policy < matrix_double_2x1 > { typedef index_operator_matrix_access_policy < matrix_double_2x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x1 > { typedef dimension<2> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 2> matrix_double_2x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x2,0> matrix_double_2x2_row0; } template <> struct geometric_traits<detail::matrix_double_2x2_row0> { typedef detail::matrix_double_2x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x2,1> matrix_double_2x2_row1; } template <> struct geometric_traits<detail::matrix_double_2x2_row1> { typedef detail::matrix_double_2x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x2,0> matrix_double_2x2_column0; }template <> struct geometric_traits<detail::matrix_double_2x2_column0> { typedef detail::matrix_double_2x2_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x2,1> matrix_double_2x2_column1; }template <> struct geometric_traits<detail::matrix_double_2x2_column1> { typedef detail::matrix_double_2x2_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x2>::type > : index_operator_matrix_access_policy < matrix_double_2x2 > { typedef index_operator_matrix_access_policy < matrix_double_2x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x2 > { typedef dimension<2> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 3> matrix_double_2x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x3,0> matrix_double_2x3_row0; } template <> struct geometric_traits<detail::matrix_double_2x3_row0> { typedef detail::matrix_double_2x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x3,1> matrix_double_2x3_row1; } template <> struct geometric_traits<detail::matrix_double_2x3_row1> { typedef detail::matrix_double_2x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x3,0> matrix_double_2x3_column0; }template <> struct geometric_traits<detail::matrix_double_2x3_column0> { typedef detail::matrix_double_2x3_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x3,1> matrix_double_2x3_column1; }template <> struct geometric_traits<detail::matrix_double_2x3_column1> { typedef detail::matrix_double_2x3_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x3,2> matrix_double_2x3_column2; }template <> struct geometric_traits<detail::matrix_double_2x3_column2> { typedef detail::matrix_double_2x3_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x3>::type > : index_operator_matrix_access_policy < matrix_double_2x3 > { typedef index_operator_matrix_access_policy < matrix_double_2x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x3 > { typedef dimension<2> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 4> matrix_double_2x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x4,0> matrix_double_2x4_row0; } template <> struct geometric_traits<detail::matrix_double_2x4_row0> { typedef detail::matrix_double_2x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x4,1> matrix_double_2x4_row1; } template <> struct geometric_traits<detail::matrix_double_2x4_row1> { typedef detail::matrix_double_2x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x4,0> matrix_double_2x4_column0; }template <> struct geometric_traits<detail::matrix_double_2x4_column0> { typedef detail::matrix_double_2x4_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x4,1> matrix_double_2x4_column1; }template <> struct geometric_traits<detail::matrix_double_2x4_column1> { typedef detail::matrix_double_2x4_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x4,2> matrix_double_2x4_column2; }template <> struct geometric_traits<detail::matrix_double_2x4_column2> { typedef detail::matrix_double_2x4_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x4,3> matrix_double_2x4_column3; }template <> struct geometric_traits<detail::matrix_double_2x4_column3> { typedef detail::matrix_double_2x4_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x4>::type > : index_operator_matrix_access_policy < matrix_double_2x4 > { typedef index_operator_matrix_access_policy < matrix_double_2x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x4 > { typedef dimension<2> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 5> matrix_double_2x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x5,0> matrix_double_2x5_row0; } template <> struct geometric_traits<detail::matrix_double_2x5_row0> { typedef detail::matrix_double_2x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x5,1> matrix_double_2x5_row1; } template <> struct geometric_traits<detail::matrix_double_2x5_row1> { typedef detail::matrix_double_2x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x5,0> matrix_double_2x5_column0; }template <> struct geometric_traits<detail::matrix_double_2x5_column0> { typedef detail::matrix_double_2x5_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x5,1> matrix_double_2x5_column1; }template <> struct geometric_traits<detail::matrix_double_2x5_column1> { typedef detail::matrix_double_2x5_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x5,2> matrix_double_2x5_column2; }template <> struct geometric_traits<detail::matrix_double_2x5_column2> { typedef detail::matrix_double_2x5_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x5,3> matrix_double_2x5_column3; }template <> struct geometric_traits<detail::matrix_double_2x5_column3> { typedef detail::matrix_double_2x5_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x5,4> matrix_double_2x5_column4; }template <> struct geometric_traits<detail::matrix_double_2x5_column4> { typedef detail::matrix_double_2x5_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x5>::type > : index_operator_matrix_access_policy < matrix_double_2x5 > { typedef index_operator_matrix_access_policy < matrix_double_2x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x5 > { typedef dimension<2> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 6> matrix_double_2x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x6,0> matrix_double_2x6_row0; } template <> struct geometric_traits<detail::matrix_double_2x6_row0> { typedef detail::matrix_double_2x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x6,1> matrix_double_2x6_row1; } template <> struct geometric_traits<detail::matrix_double_2x6_row1> { typedef detail::matrix_double_2x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,0> matrix_double_2x6_column0; }template <> struct geometric_traits<detail::matrix_double_2x6_column0> { typedef detail::matrix_double_2x6_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,1> matrix_double_2x6_column1; }template <> struct geometric_traits<detail::matrix_double_2x6_column1> { typedef detail::matrix_double_2x6_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,2> matrix_double_2x6_column2; }template <> struct geometric_traits<detail::matrix_double_2x6_column2> { typedef detail::matrix_double_2x6_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,3> matrix_double_2x6_column3; }template <> struct geometric_traits<detail::matrix_double_2x6_column3> { typedef detail::matrix_double_2x6_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,4> matrix_double_2x6_column4; }template <> struct geometric_traits<detail::matrix_double_2x6_column4> { typedef detail::matrix_double_2x6_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x6,5> matrix_double_2x6_column5; }template <> struct geometric_traits<detail::matrix_double_2x6_column5> { typedef detail::matrix_double_2x6_column5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x6>::type > : index_operator_matrix_access_policy < matrix_double_2x6 > { typedef index_operator_matrix_access_policy < matrix_double_2x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x6 > { typedef dimension<2> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 7> matrix_double_2x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x7,0> matrix_double_2x7_row0; } template <> struct geometric_traits<detail::matrix_double_2x7_row0> { typedef detail::matrix_double_2x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x7,1> matrix_double_2x7_row1; } template <> struct geometric_traits<detail::matrix_double_2x7_row1> { typedef detail::matrix_double_2x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,0> matrix_double_2x7_column0; }template <> struct geometric_traits<detail::matrix_double_2x7_column0> { typedef detail::matrix_double_2x7_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,1> matrix_double_2x7_column1; }template <> struct geometric_traits<detail::matrix_double_2x7_column1> { typedef detail::matrix_double_2x7_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,2> matrix_double_2x7_column2; }template <> struct geometric_traits<detail::matrix_double_2x7_column2> { typedef detail::matrix_double_2x7_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,3> matrix_double_2x7_column3; }template <> struct geometric_traits<detail::matrix_double_2x7_column3> { typedef detail::matrix_double_2x7_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,4> matrix_double_2x7_column4; }template <> struct geometric_traits<detail::matrix_double_2x7_column4> { typedef detail::matrix_double_2x7_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,5> matrix_double_2x7_column5; }template <> struct geometric_traits<detail::matrix_double_2x7_column5> { typedef detail::matrix_double_2x7_column5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x7,6> matrix_double_2x7_column6; }template <> struct geometric_traits<detail::matrix_double_2x7_column6> { typedef detail::matrix_double_2x7_column6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x7>::type > : index_operator_matrix_access_policy < matrix_double_2x7 > { typedef index_operator_matrix_access_policy < matrix_double_2x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x7 > { typedef dimension<2> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 8> matrix_double_2x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x8,0> matrix_double_2x8_row0; } template <> struct geometric_traits<detail::matrix_double_2x8_row0> { typedef detail::matrix_double_2x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x8,1> matrix_double_2x8_row1; } template <> struct geometric_traits<detail::matrix_double_2x8_row1> { typedef detail::matrix_double_2x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,0> matrix_double_2x8_column0; }template <> struct geometric_traits<detail::matrix_double_2x8_column0> { typedef detail::matrix_double_2x8_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,1> matrix_double_2x8_column1; }template <> struct geometric_traits<detail::matrix_double_2x8_column1> { typedef detail::matrix_double_2x8_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,2> matrix_double_2x8_column2; }template <> struct geometric_traits<detail::matrix_double_2x8_column2> { typedef detail::matrix_double_2x8_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,3> matrix_double_2x8_column3; }template <> struct geometric_traits<detail::matrix_double_2x8_column3> { typedef detail::matrix_double_2x8_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,4> matrix_double_2x8_column4; }template <> struct geometric_traits<detail::matrix_double_2x8_column4> { typedef detail::matrix_double_2x8_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,5> matrix_double_2x8_column5; }template <> struct geometric_traits<detail::matrix_double_2x8_column5> { typedef detail::matrix_double_2x8_column5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,6> matrix_double_2x8_column6; }template <> struct geometric_traits<detail::matrix_double_2x8_column6> { typedef detail::matrix_double_2x8_column6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x8,7> matrix_double_2x8_column7; }template <> struct geometric_traits<detail::matrix_double_2x8_column7> { typedef detail::matrix_double_2x8_column7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x8>::type > : index_operator_matrix_access_policy < matrix_double_2x8 > { typedef index_operator_matrix_access_policy < matrix_double_2x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x8 > { typedef dimension<2> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 9> matrix_double_2x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x9,0> matrix_double_2x9_row0; } template <> struct geometric_traits<detail::matrix_double_2x9_row0> { typedef detail::matrix_double_2x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x9,1> matrix_double_2x9_row1; } template <> struct geometric_traits<detail::matrix_double_2x9_row1> { typedef detail::matrix_double_2x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,0> matrix_double_2x9_column0; }template <> struct geometric_traits<detail::matrix_double_2x9_column0> { typedef detail::matrix_double_2x9_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,1> matrix_double_2x9_column1; }template <> struct geometric_traits<detail::matrix_double_2x9_column1> { typedef detail::matrix_double_2x9_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,2> matrix_double_2x9_column2; }template <> struct geometric_traits<detail::matrix_double_2x9_column2> { typedef detail::matrix_double_2x9_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,3> matrix_double_2x9_column3; }template <> struct geometric_traits<detail::matrix_double_2x9_column3> { typedef detail::matrix_double_2x9_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,4> matrix_double_2x9_column4; }template <> struct geometric_traits<detail::matrix_double_2x9_column4> { typedef detail::matrix_double_2x9_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,5> matrix_double_2x9_column5; }template <> struct geometric_traits<detail::matrix_double_2x9_column5> { typedef detail::matrix_double_2x9_column5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,6> matrix_double_2x9_column6; }template <> struct geometric_traits<detail::matrix_double_2x9_column6> { typedef detail::matrix_double_2x9_column6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,7> matrix_double_2x9_column7; }template <> struct geometric_traits<detail::matrix_double_2x9_column7> { typedef detail::matrix_double_2x9_column7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x9,8> matrix_double_2x9_column8; }template <> struct geometric_traits<detail::matrix_double_2x9_column8> { typedef detail::matrix_double_2x9_column8 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x9>::type > : index_operator_matrix_access_policy < matrix_double_2x9 > { typedef index_operator_matrix_access_policy < matrix_double_2x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x9 > { typedef dimension<2> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 2, 10> matrix_double_2x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x10,0> matrix_double_2x10_row0; } template <> struct geometric_traits<detail::matrix_double_2x10_row0> { typedef detail::matrix_double_2x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_2x10,1> matrix_double_2x10_row1; } template <> struct geometric_traits<detail::matrix_double_2x10_row1> { typedef detail::matrix_double_2x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,0> matrix_double_2x10_column0; }template <> struct geometric_traits<detail::matrix_double_2x10_column0> { typedef detail::matrix_double_2x10_column0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,1> matrix_double_2x10_column1; }template <> struct geometric_traits<detail::matrix_double_2x10_column1> { typedef detail::matrix_double_2x10_column1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,2> matrix_double_2x10_column2; }template <> struct geometric_traits<detail::matrix_double_2x10_column2> { typedef detail::matrix_double_2x10_column2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,3> matrix_double_2x10_column3; }template <> struct geometric_traits<detail::matrix_double_2x10_column3> { typedef detail::matrix_double_2x10_column3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,4> matrix_double_2x10_column4; }template <> struct geometric_traits<detail::matrix_double_2x10_column4> { typedef detail::matrix_double_2x10_column4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,5> matrix_double_2x10_column5; }template <> struct geometric_traits<detail::matrix_double_2x10_column5> { typedef detail::matrix_double_2x10_column5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,6> matrix_double_2x10_column6; }template <> struct geometric_traits<detail::matrix_double_2x10_column6> { typedef detail::matrix_double_2x10_column6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,7> matrix_double_2x10_column7; }template <> struct geometric_traits<detail::matrix_double_2x10_column7> { typedef detail::matrix_double_2x10_column7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,8> matrix_double_2x10_column8; }template <> struct geometric_traits<detail::matrix_double_2x10_column8> { typedef detail::matrix_double_2x10_column8 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_2x10,9> matrix_double_2x10_column9; }template <> struct geometric_traits<detail::matrix_double_2x10_column9> { typedef detail::matrix_double_2x10_column9 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_2x10>::type > : index_operator_matrix_access_policy < matrix_double_2x10 > { typedef index_operator_matrix_access_policy < matrix_double_2x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_2x10 > { typedef dimension<2> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 1> matrix_double_3x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x1,0> matrix_double_3x1_row0; } template <> struct geometric_traits<detail::matrix_double_3x1_row0> { typedef detail::matrix_double_3x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x1,1> matrix_double_3x1_row1; } template <> struct geometric_traits<detail::matrix_double_3x1_row1> { typedef detail::matrix_double_3x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x1,2> matrix_double_3x1_row2; } template <> struct geometric_traits<detail::matrix_double_3x1_row2> { typedef detail::matrix_double_3x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x1,0> matrix_double_3x1_column0; }template <> struct geometric_traits<detail::matrix_double_3x1_column0> { typedef detail::matrix_double_3x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x1>::type > : index_operator_matrix_access_policy < matrix_double_3x1 > { typedef index_operator_matrix_access_policy < matrix_double_3x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x1 > { typedef dimension<3> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 2> matrix_double_3x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x2,0> matrix_double_3x2_row0; } template <> struct geometric_traits<detail::matrix_double_3x2_row0> { typedef detail::matrix_double_3x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x2,1> matrix_double_3x2_row1; } template <> struct geometric_traits<detail::matrix_double_3x2_row1> { typedef detail::matrix_double_3x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x2,2> matrix_double_3x2_row2; } template <> struct geometric_traits<detail::matrix_double_3x2_row2> { typedef detail::matrix_double_3x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x2,0> matrix_double_3x2_column0; }template <> struct geometric_traits<detail::matrix_double_3x2_column0> { typedef detail::matrix_double_3x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x2,1> matrix_double_3x2_column1; }template <> struct geometric_traits<detail::matrix_double_3x2_column1> { typedef detail::matrix_double_3x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x2>::type > : index_operator_matrix_access_policy < matrix_double_3x2 > { typedef index_operator_matrix_access_policy < matrix_double_3x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x2 > { typedef dimension<3> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 3> matrix_double_3x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x3,0> matrix_double_3x3_row0; } template <> struct geometric_traits<detail::matrix_double_3x3_row0> { typedef detail::matrix_double_3x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x3,1> matrix_double_3x3_row1; } template <> struct geometric_traits<detail::matrix_double_3x3_row1> { typedef detail::matrix_double_3x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x3,2> matrix_double_3x3_row2; } template <> struct geometric_traits<detail::matrix_double_3x3_row2> { typedef detail::matrix_double_3x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x3,0> matrix_double_3x3_column0; }template <> struct geometric_traits<detail::matrix_double_3x3_column0> { typedef detail::matrix_double_3x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x3,1> matrix_double_3x3_column1; }template <> struct geometric_traits<detail::matrix_double_3x3_column1> { typedef detail::matrix_double_3x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x3,2> matrix_double_3x3_column2; }template <> struct geometric_traits<detail::matrix_double_3x3_column2> { typedef detail::matrix_double_3x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x3>::type > : index_operator_matrix_access_policy < matrix_double_3x3 > { typedef index_operator_matrix_access_policy < matrix_double_3x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x3 > { typedef dimension<3> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 4> matrix_double_3x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x4,0> matrix_double_3x4_row0; } template <> struct geometric_traits<detail::matrix_double_3x4_row0> { typedef detail::matrix_double_3x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x4,1> matrix_double_3x4_row1; } template <> struct geometric_traits<detail::matrix_double_3x4_row1> { typedef detail::matrix_double_3x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x4,2> matrix_double_3x4_row2; } template <> struct geometric_traits<detail::matrix_double_3x4_row2> { typedef detail::matrix_double_3x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x4,0> matrix_double_3x4_column0; }template <> struct geometric_traits<detail::matrix_double_3x4_column0> { typedef detail::matrix_double_3x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x4,1> matrix_double_3x4_column1; }template <> struct geometric_traits<detail::matrix_double_3x4_column1> { typedef detail::matrix_double_3x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x4,2> matrix_double_3x4_column2; }template <> struct geometric_traits<detail::matrix_double_3x4_column2> { typedef detail::matrix_double_3x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x4,3> matrix_double_3x4_column3; }template <> struct geometric_traits<detail::matrix_double_3x4_column3> { typedef detail::matrix_double_3x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x4>::type > : index_operator_matrix_access_policy < matrix_double_3x4 > { typedef index_operator_matrix_access_policy < matrix_double_3x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x4 > { typedef dimension<3> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 5> matrix_double_3x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x5,0> matrix_double_3x5_row0; } template <> struct geometric_traits<detail::matrix_double_3x5_row0> { typedef detail::matrix_double_3x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x5,1> matrix_double_3x5_row1; } template <> struct geometric_traits<detail::matrix_double_3x5_row1> { typedef detail::matrix_double_3x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x5,2> matrix_double_3x5_row2; } template <> struct geometric_traits<detail::matrix_double_3x5_row2> { typedef detail::matrix_double_3x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x5,0> matrix_double_3x5_column0; }template <> struct geometric_traits<detail::matrix_double_3x5_column0> { typedef detail::matrix_double_3x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x5,1> matrix_double_3x5_column1; }template <> struct geometric_traits<detail::matrix_double_3x5_column1> { typedef detail::matrix_double_3x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x5,2> matrix_double_3x5_column2; }template <> struct geometric_traits<detail::matrix_double_3x5_column2> { typedef detail::matrix_double_3x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x5,3> matrix_double_3x5_column3; }template <> struct geometric_traits<detail::matrix_double_3x5_column3> { typedef detail::matrix_double_3x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x5,4> matrix_double_3x5_column4; }template <> struct geometric_traits<detail::matrix_double_3x5_column4> { typedef detail::matrix_double_3x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x5>::type > : index_operator_matrix_access_policy < matrix_double_3x5 > { typedef index_operator_matrix_access_policy < matrix_double_3x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x5 > { typedef dimension<3> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 6> matrix_double_3x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x6,0> matrix_double_3x6_row0; } template <> struct geometric_traits<detail::matrix_double_3x6_row0> { typedef detail::matrix_double_3x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x6,1> matrix_double_3x6_row1; } template <> struct geometric_traits<detail::matrix_double_3x6_row1> { typedef detail::matrix_double_3x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x6,2> matrix_double_3x6_row2; } template <> struct geometric_traits<detail::matrix_double_3x6_row2> { typedef detail::matrix_double_3x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,0> matrix_double_3x6_column0; }template <> struct geometric_traits<detail::matrix_double_3x6_column0> { typedef detail::matrix_double_3x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,1> matrix_double_3x6_column1; }template <> struct geometric_traits<detail::matrix_double_3x6_column1> { typedef detail::matrix_double_3x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,2> matrix_double_3x6_column2; }template <> struct geometric_traits<detail::matrix_double_3x6_column2> { typedef detail::matrix_double_3x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,3> matrix_double_3x6_column3; }template <> struct geometric_traits<detail::matrix_double_3x6_column3> { typedef detail::matrix_double_3x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,4> matrix_double_3x6_column4; }template <> struct geometric_traits<detail::matrix_double_3x6_column4> { typedef detail::matrix_double_3x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x6,5> matrix_double_3x6_column5; }template <> struct geometric_traits<detail::matrix_double_3x6_column5> { typedef detail::matrix_double_3x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x6>::type > : index_operator_matrix_access_policy < matrix_double_3x6 > { typedef index_operator_matrix_access_policy < matrix_double_3x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x6 > { typedef dimension<3> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 7> matrix_double_3x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x7,0> matrix_double_3x7_row0; } template <> struct geometric_traits<detail::matrix_double_3x7_row0> { typedef detail::matrix_double_3x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x7,1> matrix_double_3x7_row1; } template <> struct geometric_traits<detail::matrix_double_3x7_row1> { typedef detail::matrix_double_3x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x7,2> matrix_double_3x7_row2; } template <> struct geometric_traits<detail::matrix_double_3x7_row2> { typedef detail::matrix_double_3x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,0> matrix_double_3x7_column0; }template <> struct geometric_traits<detail::matrix_double_3x7_column0> { typedef detail::matrix_double_3x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,1> matrix_double_3x7_column1; }template <> struct geometric_traits<detail::matrix_double_3x7_column1> { typedef detail::matrix_double_3x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,2> matrix_double_3x7_column2; }template <> struct geometric_traits<detail::matrix_double_3x7_column2> { typedef detail::matrix_double_3x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,3> matrix_double_3x7_column3; }template <> struct geometric_traits<detail::matrix_double_3x7_column3> { typedef detail::matrix_double_3x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,4> matrix_double_3x7_column4; }template <> struct geometric_traits<detail::matrix_double_3x7_column4> { typedef detail::matrix_double_3x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,5> matrix_double_3x7_column5; }template <> struct geometric_traits<detail::matrix_double_3x7_column5> { typedef detail::matrix_double_3x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x7,6> matrix_double_3x7_column6; }template <> struct geometric_traits<detail::matrix_double_3x7_column6> { typedef detail::matrix_double_3x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x7>::type > : index_operator_matrix_access_policy < matrix_double_3x7 > { typedef index_operator_matrix_access_policy < matrix_double_3x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x7 > { typedef dimension<3> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 8> matrix_double_3x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x8,0> matrix_double_3x8_row0; } template <> struct geometric_traits<detail::matrix_double_3x8_row0> { typedef detail::matrix_double_3x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x8,1> matrix_double_3x8_row1; } template <> struct geometric_traits<detail::matrix_double_3x8_row1> { typedef detail::matrix_double_3x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x8,2> matrix_double_3x8_row2; } template <> struct geometric_traits<detail::matrix_double_3x8_row2> { typedef detail::matrix_double_3x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,0> matrix_double_3x8_column0; }template <> struct geometric_traits<detail::matrix_double_3x8_column0> { typedef detail::matrix_double_3x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,1> matrix_double_3x8_column1; }template <> struct geometric_traits<detail::matrix_double_3x8_column1> { typedef detail::matrix_double_3x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,2> matrix_double_3x8_column2; }template <> struct geometric_traits<detail::matrix_double_3x8_column2> { typedef detail::matrix_double_3x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,3> matrix_double_3x8_column3; }template <> struct geometric_traits<detail::matrix_double_3x8_column3> { typedef detail::matrix_double_3x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,4> matrix_double_3x8_column4; }template <> struct geometric_traits<detail::matrix_double_3x8_column4> { typedef detail::matrix_double_3x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,5> matrix_double_3x8_column5; }template <> struct geometric_traits<detail::matrix_double_3x8_column5> { typedef detail::matrix_double_3x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,6> matrix_double_3x8_column6; }template <> struct geometric_traits<detail::matrix_double_3x8_column6> { typedef detail::matrix_double_3x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x8,7> matrix_double_3x8_column7; }template <> struct geometric_traits<detail::matrix_double_3x8_column7> { typedef detail::matrix_double_3x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x8>::type > : index_operator_matrix_access_policy < matrix_double_3x8 > { typedef index_operator_matrix_access_policy < matrix_double_3x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x8 > { typedef dimension<3> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 9> matrix_double_3x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x9,0> matrix_double_3x9_row0; } template <> struct geometric_traits<detail::matrix_double_3x9_row0> { typedef detail::matrix_double_3x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x9,1> matrix_double_3x9_row1; } template <> struct geometric_traits<detail::matrix_double_3x9_row1> { typedef detail::matrix_double_3x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x9,2> matrix_double_3x9_row2; } template <> struct geometric_traits<detail::matrix_double_3x9_row2> { typedef detail::matrix_double_3x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,0> matrix_double_3x9_column0; }template <> struct geometric_traits<detail::matrix_double_3x9_column0> { typedef detail::matrix_double_3x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,1> matrix_double_3x9_column1; }template <> struct geometric_traits<detail::matrix_double_3x9_column1> { typedef detail::matrix_double_3x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,2> matrix_double_3x9_column2; }template <> struct geometric_traits<detail::matrix_double_3x9_column2> { typedef detail::matrix_double_3x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,3> matrix_double_3x9_column3; }template <> struct geometric_traits<detail::matrix_double_3x9_column3> { typedef detail::matrix_double_3x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,4> matrix_double_3x9_column4; }template <> struct geometric_traits<detail::matrix_double_3x9_column4> { typedef detail::matrix_double_3x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,5> matrix_double_3x9_column5; }template <> struct geometric_traits<detail::matrix_double_3x9_column5> { typedef detail::matrix_double_3x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,6> matrix_double_3x9_column6; }template <> struct geometric_traits<detail::matrix_double_3x9_column6> { typedef detail::matrix_double_3x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,7> matrix_double_3x9_column7; }template <> struct geometric_traits<detail::matrix_double_3x9_column7> { typedef detail::matrix_double_3x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x9,8> matrix_double_3x9_column8; }template <> struct geometric_traits<detail::matrix_double_3x9_column8> { typedef detail::matrix_double_3x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x9>::type > : index_operator_matrix_access_policy < matrix_double_3x9 > { typedef index_operator_matrix_access_policy < matrix_double_3x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x9 > { typedef dimension<3> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 3, 10> matrix_double_3x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x10,0> matrix_double_3x10_row0; } template <> struct geometric_traits<detail::matrix_double_3x10_row0> { typedef detail::matrix_double_3x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x10,1> matrix_double_3x10_row1; } template <> struct geometric_traits<detail::matrix_double_3x10_row1> { typedef detail::matrix_double_3x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_3x10,2> matrix_double_3x10_row2; } template <> struct geometric_traits<detail::matrix_double_3x10_row2> { typedef detail::matrix_double_3x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,0> matrix_double_3x10_column0; }template <> struct geometric_traits<detail::matrix_double_3x10_column0> { typedef detail::matrix_double_3x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,1> matrix_double_3x10_column1; }template <> struct geometric_traits<detail::matrix_double_3x10_column1> { typedef detail::matrix_double_3x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,2> matrix_double_3x10_column2; }template <> struct geometric_traits<detail::matrix_double_3x10_column2> { typedef detail::matrix_double_3x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,3> matrix_double_3x10_column3; }template <> struct geometric_traits<detail::matrix_double_3x10_column3> { typedef detail::matrix_double_3x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,4> matrix_double_3x10_column4; }template <> struct geometric_traits<detail::matrix_double_3x10_column4> { typedef detail::matrix_double_3x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,5> matrix_double_3x10_column5; }template <> struct geometric_traits<detail::matrix_double_3x10_column5> { typedef detail::matrix_double_3x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,6> matrix_double_3x10_column6; }template <> struct geometric_traits<detail::matrix_double_3x10_column6> { typedef detail::matrix_double_3x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,7> matrix_double_3x10_column7; }template <> struct geometric_traits<detail::matrix_double_3x10_column7> { typedef detail::matrix_double_3x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,8> matrix_double_3x10_column8; }template <> struct geometric_traits<detail::matrix_double_3x10_column8> { typedef detail::matrix_double_3x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_3x10,9> matrix_double_3x10_column9; }template <> struct geometric_traits<detail::matrix_double_3x10_column9> { typedef detail::matrix_double_3x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_3x10>::type > : index_operator_matrix_access_policy < matrix_double_3x10 > { typedef index_operator_matrix_access_policy < matrix_double_3x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_3x10 > { typedef dimension<3> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 1> matrix_double_4x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x1,0> matrix_double_4x1_row0; } template <> struct geometric_traits<detail::matrix_double_4x1_row0> { typedef detail::matrix_double_4x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x1,1> matrix_double_4x1_row1; } template <> struct geometric_traits<detail::matrix_double_4x1_row1> { typedef detail::matrix_double_4x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x1,2> matrix_double_4x1_row2; } template <> struct geometric_traits<detail::matrix_double_4x1_row2> { typedef detail::matrix_double_4x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x1,3> matrix_double_4x1_row3; } template <> struct geometric_traits<detail::matrix_double_4x1_row3> { typedef detail::matrix_double_4x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x1,0> matrix_double_4x1_column0; }template <> struct geometric_traits<detail::matrix_double_4x1_column0> { typedef detail::matrix_double_4x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x1>::type > : index_operator_matrix_access_policy < matrix_double_4x1 > { typedef index_operator_matrix_access_policy < matrix_double_4x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x1 > { typedef dimension<4> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 2> matrix_double_4x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x2,0> matrix_double_4x2_row0; } template <> struct geometric_traits<detail::matrix_double_4x2_row0> { typedef detail::matrix_double_4x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x2,1> matrix_double_4x2_row1; } template <> struct geometric_traits<detail::matrix_double_4x2_row1> { typedef detail::matrix_double_4x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x2,2> matrix_double_4x2_row2; } template <> struct geometric_traits<detail::matrix_double_4x2_row2> { typedef detail::matrix_double_4x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x2,3> matrix_double_4x2_row3; } template <> struct geometric_traits<detail::matrix_double_4x2_row3> { typedef detail::matrix_double_4x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x2,0> matrix_double_4x2_column0; }template <> struct geometric_traits<detail::matrix_double_4x2_column0> { typedef detail::matrix_double_4x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x2,1> matrix_double_4x2_column1; }template <> struct geometric_traits<detail::matrix_double_4x2_column1> { typedef detail::matrix_double_4x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x2>::type > : index_operator_matrix_access_policy < matrix_double_4x2 > { typedef index_operator_matrix_access_policy < matrix_double_4x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x2 > { typedef dimension<4> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 3> matrix_double_4x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x3,0> matrix_double_4x3_row0; } template <> struct geometric_traits<detail::matrix_double_4x3_row0> { typedef detail::matrix_double_4x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x3,1> matrix_double_4x3_row1; } template <> struct geometric_traits<detail::matrix_double_4x3_row1> { typedef detail::matrix_double_4x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x3,2> matrix_double_4x3_row2; } template <> struct geometric_traits<detail::matrix_double_4x3_row2> { typedef detail::matrix_double_4x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x3,3> matrix_double_4x3_row3; } template <> struct geometric_traits<detail::matrix_double_4x3_row3> { typedef detail::matrix_double_4x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x3,0> matrix_double_4x3_column0; }template <> struct geometric_traits<detail::matrix_double_4x3_column0> { typedef detail::matrix_double_4x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x3,1> matrix_double_4x3_column1; }template <> struct geometric_traits<detail::matrix_double_4x3_column1> { typedef detail::matrix_double_4x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x3,2> matrix_double_4x3_column2; }template <> struct geometric_traits<detail::matrix_double_4x3_column2> { typedef detail::matrix_double_4x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x3>::type > : index_operator_matrix_access_policy < matrix_double_4x3 > { typedef index_operator_matrix_access_policy < matrix_double_4x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x3 > { typedef dimension<4> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 4> matrix_double_4x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x4,0> matrix_double_4x4_row0; } template <> struct geometric_traits<detail::matrix_double_4x4_row0> { typedef detail::matrix_double_4x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x4,1> matrix_double_4x4_row1; } template <> struct geometric_traits<detail::matrix_double_4x4_row1> { typedef detail::matrix_double_4x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x4,2> matrix_double_4x4_row2; } template <> struct geometric_traits<detail::matrix_double_4x4_row2> { typedef detail::matrix_double_4x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x4,3> matrix_double_4x4_row3; } template <> struct geometric_traits<detail::matrix_double_4x4_row3> { typedef detail::matrix_double_4x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x4,0> matrix_double_4x4_column0; }template <> struct geometric_traits<detail::matrix_double_4x4_column0> { typedef detail::matrix_double_4x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x4,1> matrix_double_4x4_column1; }template <> struct geometric_traits<detail::matrix_double_4x4_column1> { typedef detail::matrix_double_4x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x4,2> matrix_double_4x4_column2; }template <> struct geometric_traits<detail::matrix_double_4x4_column2> { typedef detail::matrix_double_4x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x4,3> matrix_double_4x4_column3; }template <> struct geometric_traits<detail::matrix_double_4x4_column3> { typedef detail::matrix_double_4x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x4>::type > : index_operator_matrix_access_policy < matrix_double_4x4 > { typedef index_operator_matrix_access_policy < matrix_double_4x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x4 > { typedef dimension<4> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 5> matrix_double_4x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x5,0> matrix_double_4x5_row0; } template <> struct geometric_traits<detail::matrix_double_4x5_row0> { typedef detail::matrix_double_4x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x5,1> matrix_double_4x5_row1; } template <> struct geometric_traits<detail::matrix_double_4x5_row1> { typedef detail::matrix_double_4x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x5,2> matrix_double_4x5_row2; } template <> struct geometric_traits<detail::matrix_double_4x5_row2> { typedef detail::matrix_double_4x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x5,3> matrix_double_4x5_row3; } template <> struct geometric_traits<detail::matrix_double_4x5_row3> { typedef detail::matrix_double_4x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x5,0> matrix_double_4x5_column0; }template <> struct geometric_traits<detail::matrix_double_4x5_column0> { typedef detail::matrix_double_4x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x5,1> matrix_double_4x5_column1; }template <> struct geometric_traits<detail::matrix_double_4x5_column1> { typedef detail::matrix_double_4x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x5,2> matrix_double_4x5_column2; }template <> struct geometric_traits<detail::matrix_double_4x5_column2> { typedef detail::matrix_double_4x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x5,3> matrix_double_4x5_column3; }template <> struct geometric_traits<detail::matrix_double_4x5_column3> { typedef detail::matrix_double_4x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x5,4> matrix_double_4x5_column4; }template <> struct geometric_traits<detail::matrix_double_4x5_column4> { typedef detail::matrix_double_4x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x5>::type > : index_operator_matrix_access_policy < matrix_double_4x5 > { typedef index_operator_matrix_access_policy < matrix_double_4x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x5 > { typedef dimension<4> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 6> matrix_double_4x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x6,0> matrix_double_4x6_row0; } template <> struct geometric_traits<detail::matrix_double_4x6_row0> { typedef detail::matrix_double_4x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x6,1> matrix_double_4x6_row1; } template <> struct geometric_traits<detail::matrix_double_4x6_row1> { typedef detail::matrix_double_4x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x6,2> matrix_double_4x6_row2; } template <> struct geometric_traits<detail::matrix_double_4x6_row2> { typedef detail::matrix_double_4x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x6,3> matrix_double_4x6_row3; } template <> struct geometric_traits<detail::matrix_double_4x6_row3> { typedef detail::matrix_double_4x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,0> matrix_double_4x6_column0; }template <> struct geometric_traits<detail::matrix_double_4x6_column0> { typedef detail::matrix_double_4x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,1> matrix_double_4x6_column1; }template <> struct geometric_traits<detail::matrix_double_4x6_column1> { typedef detail::matrix_double_4x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,2> matrix_double_4x6_column2; }template <> struct geometric_traits<detail::matrix_double_4x6_column2> { typedef detail::matrix_double_4x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,3> matrix_double_4x6_column3; }template <> struct geometric_traits<detail::matrix_double_4x6_column3> { typedef detail::matrix_double_4x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,4> matrix_double_4x6_column4; }template <> struct geometric_traits<detail::matrix_double_4x6_column4> { typedef detail::matrix_double_4x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x6,5> matrix_double_4x6_column5; }template <> struct geometric_traits<detail::matrix_double_4x6_column5> { typedef detail::matrix_double_4x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x6>::type > : index_operator_matrix_access_policy < matrix_double_4x6 > { typedef index_operator_matrix_access_policy < matrix_double_4x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x6 > { typedef dimension<4> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 7> matrix_double_4x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x7,0> matrix_double_4x7_row0; } template <> struct geometric_traits<detail::matrix_double_4x7_row0> { typedef detail::matrix_double_4x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x7,1> matrix_double_4x7_row1; } template <> struct geometric_traits<detail::matrix_double_4x7_row1> { typedef detail::matrix_double_4x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x7,2> matrix_double_4x7_row2; } template <> struct geometric_traits<detail::matrix_double_4x7_row2> { typedef detail::matrix_double_4x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x7,3> matrix_double_4x7_row3; } template <> struct geometric_traits<detail::matrix_double_4x7_row3> { typedef detail::matrix_double_4x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,0> matrix_double_4x7_column0; }template <> struct geometric_traits<detail::matrix_double_4x7_column0> { typedef detail::matrix_double_4x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,1> matrix_double_4x7_column1; }template <> struct geometric_traits<detail::matrix_double_4x7_column1> { typedef detail::matrix_double_4x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,2> matrix_double_4x7_column2; }template <> struct geometric_traits<detail::matrix_double_4x7_column2> { typedef detail::matrix_double_4x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,3> matrix_double_4x7_column3; }template <> struct geometric_traits<detail::matrix_double_4x7_column3> { typedef detail::matrix_double_4x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,4> matrix_double_4x7_column4; }template <> struct geometric_traits<detail::matrix_double_4x7_column4> { typedef detail::matrix_double_4x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,5> matrix_double_4x7_column5; }template <> struct geometric_traits<detail::matrix_double_4x7_column5> { typedef detail::matrix_double_4x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x7,6> matrix_double_4x7_column6; }template <> struct geometric_traits<detail::matrix_double_4x7_column6> { typedef detail::matrix_double_4x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x7>::type > : index_operator_matrix_access_policy < matrix_double_4x7 > { typedef index_operator_matrix_access_policy < matrix_double_4x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x7 > { typedef dimension<4> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 8> matrix_double_4x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x8,0> matrix_double_4x8_row0; } template <> struct geometric_traits<detail::matrix_double_4x8_row0> { typedef detail::matrix_double_4x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x8,1> matrix_double_4x8_row1; } template <> struct geometric_traits<detail::matrix_double_4x8_row1> { typedef detail::matrix_double_4x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x8,2> matrix_double_4x8_row2; } template <> struct geometric_traits<detail::matrix_double_4x8_row2> { typedef detail::matrix_double_4x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x8,3> matrix_double_4x8_row3; } template <> struct geometric_traits<detail::matrix_double_4x8_row3> { typedef detail::matrix_double_4x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,0> matrix_double_4x8_column0; }template <> struct geometric_traits<detail::matrix_double_4x8_column0> { typedef detail::matrix_double_4x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,1> matrix_double_4x8_column1; }template <> struct geometric_traits<detail::matrix_double_4x8_column1> { typedef detail::matrix_double_4x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,2> matrix_double_4x8_column2; }template <> struct geometric_traits<detail::matrix_double_4x8_column2> { typedef detail::matrix_double_4x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,3> matrix_double_4x8_column3; }template <> struct geometric_traits<detail::matrix_double_4x8_column3> { typedef detail::matrix_double_4x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,4> matrix_double_4x8_column4; }template <> struct geometric_traits<detail::matrix_double_4x8_column4> { typedef detail::matrix_double_4x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,5> matrix_double_4x8_column5; }template <> struct geometric_traits<detail::matrix_double_4x8_column5> { typedef detail::matrix_double_4x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,6> matrix_double_4x8_column6; }template <> struct geometric_traits<detail::matrix_double_4x8_column6> { typedef detail::matrix_double_4x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x8,7> matrix_double_4x8_column7; }template <> struct geometric_traits<detail::matrix_double_4x8_column7> { typedef detail::matrix_double_4x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x8>::type > : index_operator_matrix_access_policy < matrix_double_4x8 > { typedef index_operator_matrix_access_policy < matrix_double_4x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x8 > { typedef dimension<4> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 9> matrix_double_4x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x9,0> matrix_double_4x9_row0; } template <> struct geometric_traits<detail::matrix_double_4x9_row0> { typedef detail::matrix_double_4x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x9,1> matrix_double_4x9_row1; } template <> struct geometric_traits<detail::matrix_double_4x9_row1> { typedef detail::matrix_double_4x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x9,2> matrix_double_4x9_row2; } template <> struct geometric_traits<detail::matrix_double_4x9_row2> { typedef detail::matrix_double_4x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x9,3> matrix_double_4x9_row3; } template <> struct geometric_traits<detail::matrix_double_4x9_row3> { typedef detail::matrix_double_4x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,0> matrix_double_4x9_column0; }template <> struct geometric_traits<detail::matrix_double_4x9_column0> { typedef detail::matrix_double_4x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,1> matrix_double_4x9_column1; }template <> struct geometric_traits<detail::matrix_double_4x9_column1> { typedef detail::matrix_double_4x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,2> matrix_double_4x9_column2; }template <> struct geometric_traits<detail::matrix_double_4x9_column2> { typedef detail::matrix_double_4x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,3> matrix_double_4x9_column3; }template <> struct geometric_traits<detail::matrix_double_4x9_column3> { typedef detail::matrix_double_4x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,4> matrix_double_4x9_column4; }template <> struct geometric_traits<detail::matrix_double_4x9_column4> { typedef detail::matrix_double_4x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,5> matrix_double_4x9_column5; }template <> struct geometric_traits<detail::matrix_double_4x9_column5> { typedef detail::matrix_double_4x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,6> matrix_double_4x9_column6; }template <> struct geometric_traits<detail::matrix_double_4x9_column6> { typedef detail::matrix_double_4x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,7> matrix_double_4x9_column7; }template <> struct geometric_traits<detail::matrix_double_4x9_column7> { typedef detail::matrix_double_4x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x9,8> matrix_double_4x9_column8; }template <> struct geometric_traits<detail::matrix_double_4x9_column8> { typedef detail::matrix_double_4x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x9>::type > : index_operator_matrix_access_policy < matrix_double_4x9 > { typedef index_operator_matrix_access_policy < matrix_double_4x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x9 > { typedef dimension<4> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 4, 10> matrix_double_4x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x10,0> matrix_double_4x10_row0; } template <> struct geometric_traits<detail::matrix_double_4x10_row0> { typedef detail::matrix_double_4x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x10,1> matrix_double_4x10_row1; } template <> struct geometric_traits<detail::matrix_double_4x10_row1> { typedef detail::matrix_double_4x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x10,2> matrix_double_4x10_row2; } template <> struct geometric_traits<detail::matrix_double_4x10_row2> { typedef detail::matrix_double_4x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_4x10,3> matrix_double_4x10_row3; } template <> struct geometric_traits<detail::matrix_double_4x10_row3> { typedef detail::matrix_double_4x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,0> matrix_double_4x10_column0; }template <> struct geometric_traits<detail::matrix_double_4x10_column0> { typedef detail::matrix_double_4x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,1> matrix_double_4x10_column1; }template <> struct geometric_traits<detail::matrix_double_4x10_column1> { typedef detail::matrix_double_4x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,2> matrix_double_4x10_column2; }template <> struct geometric_traits<detail::matrix_double_4x10_column2> { typedef detail::matrix_double_4x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,3> matrix_double_4x10_column3; }template <> struct geometric_traits<detail::matrix_double_4x10_column3> { typedef detail::matrix_double_4x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,4> matrix_double_4x10_column4; }template <> struct geometric_traits<detail::matrix_double_4x10_column4> { typedef detail::matrix_double_4x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,5> matrix_double_4x10_column5; }template <> struct geometric_traits<detail::matrix_double_4x10_column5> { typedef detail::matrix_double_4x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,6> matrix_double_4x10_column6; }template <> struct geometric_traits<detail::matrix_double_4x10_column6> { typedef detail::matrix_double_4x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,7> matrix_double_4x10_column7; }template <> struct geometric_traits<detail::matrix_double_4x10_column7> { typedef detail::matrix_double_4x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,8> matrix_double_4x10_column8; }template <> struct geometric_traits<detail::matrix_double_4x10_column8> { typedef detail::matrix_double_4x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_4x10,9> matrix_double_4x10_column9; }template <> struct geometric_traits<detail::matrix_double_4x10_column9> { typedef detail::matrix_double_4x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_4x10>::type > : index_operator_matrix_access_policy < matrix_double_4x10 > { typedef index_operator_matrix_access_policy < matrix_double_4x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_4x10 > { typedef dimension<4> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 1> matrix_double_5x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x1,0> matrix_double_5x1_row0; } template <> struct geometric_traits<detail::matrix_double_5x1_row0> { typedef detail::matrix_double_5x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x1,1> matrix_double_5x1_row1; } template <> struct geometric_traits<detail::matrix_double_5x1_row1> { typedef detail::matrix_double_5x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x1,2> matrix_double_5x1_row2; } template <> struct geometric_traits<detail::matrix_double_5x1_row2> { typedef detail::matrix_double_5x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x1,3> matrix_double_5x1_row3; } template <> struct geometric_traits<detail::matrix_double_5x1_row3> { typedef detail::matrix_double_5x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x1,4> matrix_double_5x1_row4; } template <> struct geometric_traits<detail::matrix_double_5x1_row4> { typedef detail::matrix_double_5x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x1,0> matrix_double_5x1_column0; }template <> struct geometric_traits<detail::matrix_double_5x1_column0> { typedef detail::matrix_double_5x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x1>::type > : index_operator_matrix_access_policy < matrix_double_5x1 > { typedef index_operator_matrix_access_policy < matrix_double_5x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x1 > { typedef dimension<5> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 2> matrix_double_5x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x2,0> matrix_double_5x2_row0; } template <> struct geometric_traits<detail::matrix_double_5x2_row0> { typedef detail::matrix_double_5x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x2,1> matrix_double_5x2_row1; } template <> struct geometric_traits<detail::matrix_double_5x2_row1> { typedef detail::matrix_double_5x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x2,2> matrix_double_5x2_row2; } template <> struct geometric_traits<detail::matrix_double_5x2_row2> { typedef detail::matrix_double_5x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x2,3> matrix_double_5x2_row3; } template <> struct geometric_traits<detail::matrix_double_5x2_row3> { typedef detail::matrix_double_5x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x2,4> matrix_double_5x2_row4; } template <> struct geometric_traits<detail::matrix_double_5x2_row4> { typedef detail::matrix_double_5x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x2,0> matrix_double_5x2_column0; }template <> struct geometric_traits<detail::matrix_double_5x2_column0> { typedef detail::matrix_double_5x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x2,1> matrix_double_5x2_column1; }template <> struct geometric_traits<detail::matrix_double_5x2_column1> { typedef detail::matrix_double_5x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x2>::type > : index_operator_matrix_access_policy < matrix_double_5x2 > { typedef index_operator_matrix_access_policy < matrix_double_5x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x2 > { typedef dimension<5> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 3> matrix_double_5x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x3,0> matrix_double_5x3_row0; } template <> struct geometric_traits<detail::matrix_double_5x3_row0> { typedef detail::matrix_double_5x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x3,1> matrix_double_5x3_row1; } template <> struct geometric_traits<detail::matrix_double_5x3_row1> { typedef detail::matrix_double_5x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x3,2> matrix_double_5x3_row2; } template <> struct geometric_traits<detail::matrix_double_5x3_row2> { typedef detail::matrix_double_5x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x3,3> matrix_double_5x3_row3; } template <> struct geometric_traits<detail::matrix_double_5x3_row3> { typedef detail::matrix_double_5x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x3,4> matrix_double_5x3_row4; } template <> struct geometric_traits<detail::matrix_double_5x3_row4> { typedef detail::matrix_double_5x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x3,0> matrix_double_5x3_column0; }template <> struct geometric_traits<detail::matrix_double_5x3_column0> { typedef detail::matrix_double_5x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x3,1> matrix_double_5x3_column1; }template <> struct geometric_traits<detail::matrix_double_5x3_column1> { typedef detail::matrix_double_5x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x3,2> matrix_double_5x3_column2; }template <> struct geometric_traits<detail::matrix_double_5x3_column2> { typedef detail::matrix_double_5x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x3>::type > : index_operator_matrix_access_policy < matrix_double_5x3 > { typedef index_operator_matrix_access_policy < matrix_double_5x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x3 > { typedef dimension<5> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 4> matrix_double_5x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x4,0> matrix_double_5x4_row0; } template <> struct geometric_traits<detail::matrix_double_5x4_row0> { typedef detail::matrix_double_5x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x4,1> matrix_double_5x4_row1; } template <> struct geometric_traits<detail::matrix_double_5x4_row1> { typedef detail::matrix_double_5x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x4,2> matrix_double_5x4_row2; } template <> struct geometric_traits<detail::matrix_double_5x4_row2> { typedef detail::matrix_double_5x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x4,3> matrix_double_5x4_row3; } template <> struct geometric_traits<detail::matrix_double_5x4_row3> { typedef detail::matrix_double_5x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x4,4> matrix_double_5x4_row4; } template <> struct geometric_traits<detail::matrix_double_5x4_row4> { typedef detail::matrix_double_5x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x4,0> matrix_double_5x4_column0; }template <> struct geometric_traits<detail::matrix_double_5x4_column0> { typedef detail::matrix_double_5x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x4,1> matrix_double_5x4_column1; }template <> struct geometric_traits<detail::matrix_double_5x4_column1> { typedef detail::matrix_double_5x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x4,2> matrix_double_5x4_column2; }template <> struct geometric_traits<detail::matrix_double_5x4_column2> { typedef detail::matrix_double_5x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x4,3> matrix_double_5x4_column3; }template <> struct geometric_traits<detail::matrix_double_5x4_column3> { typedef detail::matrix_double_5x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x4>::type > : index_operator_matrix_access_policy < matrix_double_5x4 > { typedef index_operator_matrix_access_policy < matrix_double_5x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x4 > { typedef dimension<5> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 5> matrix_double_5x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x5,0> matrix_double_5x5_row0; } template <> struct geometric_traits<detail::matrix_double_5x5_row0> { typedef detail::matrix_double_5x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x5,1> matrix_double_5x5_row1; } template <> struct geometric_traits<detail::matrix_double_5x5_row1> { typedef detail::matrix_double_5x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x5,2> matrix_double_5x5_row2; } template <> struct geometric_traits<detail::matrix_double_5x5_row2> { typedef detail::matrix_double_5x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x5,3> matrix_double_5x5_row3; } template <> struct geometric_traits<detail::matrix_double_5x5_row3> { typedef detail::matrix_double_5x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x5,4> matrix_double_5x5_row4; } template <> struct geometric_traits<detail::matrix_double_5x5_row4> { typedef detail::matrix_double_5x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x5,0> matrix_double_5x5_column0; }template <> struct geometric_traits<detail::matrix_double_5x5_column0> { typedef detail::matrix_double_5x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x5,1> matrix_double_5x5_column1; }template <> struct geometric_traits<detail::matrix_double_5x5_column1> { typedef detail::matrix_double_5x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x5,2> matrix_double_5x5_column2; }template <> struct geometric_traits<detail::matrix_double_5x5_column2> { typedef detail::matrix_double_5x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x5,3> matrix_double_5x5_column3; }template <> struct geometric_traits<detail::matrix_double_5x5_column3> { typedef detail::matrix_double_5x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x5,4> matrix_double_5x5_column4; }template <> struct geometric_traits<detail::matrix_double_5x5_column4> { typedef detail::matrix_double_5x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x5>::type > : index_operator_matrix_access_policy < matrix_double_5x5 > { typedef index_operator_matrix_access_policy < matrix_double_5x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x5 > { typedef dimension<5> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 6> matrix_double_5x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x6,0> matrix_double_5x6_row0; } template <> struct geometric_traits<detail::matrix_double_5x6_row0> { typedef detail::matrix_double_5x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x6,1> matrix_double_5x6_row1; } template <> struct geometric_traits<detail::matrix_double_5x6_row1> { typedef detail::matrix_double_5x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x6,2> matrix_double_5x6_row2; } template <> struct geometric_traits<detail::matrix_double_5x6_row2> { typedef detail::matrix_double_5x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x6,3> matrix_double_5x6_row3; } template <> struct geometric_traits<detail::matrix_double_5x6_row3> { typedef detail::matrix_double_5x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x6,4> matrix_double_5x6_row4; } template <> struct geometric_traits<detail::matrix_double_5x6_row4> { typedef detail::matrix_double_5x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,0> matrix_double_5x6_column0; }template <> struct geometric_traits<detail::matrix_double_5x6_column0> { typedef detail::matrix_double_5x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,1> matrix_double_5x6_column1; }template <> struct geometric_traits<detail::matrix_double_5x6_column1> { typedef detail::matrix_double_5x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,2> matrix_double_5x6_column2; }template <> struct geometric_traits<detail::matrix_double_5x6_column2> { typedef detail::matrix_double_5x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,3> matrix_double_5x6_column3; }template <> struct geometric_traits<detail::matrix_double_5x6_column3> { typedef detail::matrix_double_5x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,4> matrix_double_5x6_column4; }template <> struct geometric_traits<detail::matrix_double_5x6_column4> { typedef detail::matrix_double_5x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x6,5> matrix_double_5x6_column5; }template <> struct geometric_traits<detail::matrix_double_5x6_column5> { typedef detail::matrix_double_5x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x6>::type > : index_operator_matrix_access_policy < matrix_double_5x6 > { typedef index_operator_matrix_access_policy < matrix_double_5x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x6 > { typedef dimension<5> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 7> matrix_double_5x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x7,0> matrix_double_5x7_row0; } template <> struct geometric_traits<detail::matrix_double_5x7_row0> { typedef detail::matrix_double_5x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x7,1> matrix_double_5x7_row1; } template <> struct geometric_traits<detail::matrix_double_5x7_row1> { typedef detail::matrix_double_5x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x7,2> matrix_double_5x7_row2; } template <> struct geometric_traits<detail::matrix_double_5x7_row2> { typedef detail::matrix_double_5x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x7,3> matrix_double_5x7_row3; } template <> struct geometric_traits<detail::matrix_double_5x7_row3> { typedef detail::matrix_double_5x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x7,4> matrix_double_5x7_row4; } template <> struct geometric_traits<detail::matrix_double_5x7_row4> { typedef detail::matrix_double_5x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,0> matrix_double_5x7_column0; }template <> struct geometric_traits<detail::matrix_double_5x7_column0> { typedef detail::matrix_double_5x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,1> matrix_double_5x7_column1; }template <> struct geometric_traits<detail::matrix_double_5x7_column1> { typedef detail::matrix_double_5x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,2> matrix_double_5x7_column2; }template <> struct geometric_traits<detail::matrix_double_5x7_column2> { typedef detail::matrix_double_5x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,3> matrix_double_5x7_column3; }template <> struct geometric_traits<detail::matrix_double_5x7_column3> { typedef detail::matrix_double_5x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,4> matrix_double_5x7_column4; }template <> struct geometric_traits<detail::matrix_double_5x7_column4> { typedef detail::matrix_double_5x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,5> matrix_double_5x7_column5; }template <> struct geometric_traits<detail::matrix_double_5x7_column5> { typedef detail::matrix_double_5x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x7,6> matrix_double_5x7_column6; }template <> struct geometric_traits<detail::matrix_double_5x7_column6> { typedef detail::matrix_double_5x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x7>::type > : index_operator_matrix_access_policy < matrix_double_5x7 > { typedef index_operator_matrix_access_policy < matrix_double_5x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x7 > { typedef dimension<5> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 8> matrix_double_5x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x8,0> matrix_double_5x8_row0; } template <> struct geometric_traits<detail::matrix_double_5x8_row0> { typedef detail::matrix_double_5x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x8,1> matrix_double_5x8_row1; } template <> struct geometric_traits<detail::matrix_double_5x8_row1> { typedef detail::matrix_double_5x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x8,2> matrix_double_5x8_row2; } template <> struct geometric_traits<detail::matrix_double_5x8_row2> { typedef detail::matrix_double_5x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x8,3> matrix_double_5x8_row3; } template <> struct geometric_traits<detail::matrix_double_5x8_row3> { typedef detail::matrix_double_5x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x8,4> matrix_double_5x8_row4; } template <> struct geometric_traits<detail::matrix_double_5x8_row4> { typedef detail::matrix_double_5x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,0> matrix_double_5x8_column0; }template <> struct geometric_traits<detail::matrix_double_5x8_column0> { typedef detail::matrix_double_5x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,1> matrix_double_5x8_column1; }template <> struct geometric_traits<detail::matrix_double_5x8_column1> { typedef detail::matrix_double_5x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,2> matrix_double_5x8_column2; }template <> struct geometric_traits<detail::matrix_double_5x8_column2> { typedef detail::matrix_double_5x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,3> matrix_double_5x8_column3; }template <> struct geometric_traits<detail::matrix_double_5x8_column3> { typedef detail::matrix_double_5x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,4> matrix_double_5x8_column4; }template <> struct geometric_traits<detail::matrix_double_5x8_column4> { typedef detail::matrix_double_5x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,5> matrix_double_5x8_column5; }template <> struct geometric_traits<detail::matrix_double_5x8_column5> { typedef detail::matrix_double_5x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,6> matrix_double_5x8_column6; }template <> struct geometric_traits<detail::matrix_double_5x8_column6> { typedef detail::matrix_double_5x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x8,7> matrix_double_5x8_column7; }template <> struct geometric_traits<detail::matrix_double_5x8_column7> { typedef detail::matrix_double_5x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x8>::type > : index_operator_matrix_access_policy < matrix_double_5x8 > { typedef index_operator_matrix_access_policy < matrix_double_5x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x8 > { typedef dimension<5> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 9> matrix_double_5x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x9,0> matrix_double_5x9_row0; } template <> struct geometric_traits<detail::matrix_double_5x9_row0> { typedef detail::matrix_double_5x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x9,1> matrix_double_5x9_row1; } template <> struct geometric_traits<detail::matrix_double_5x9_row1> { typedef detail::matrix_double_5x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x9,2> matrix_double_5x9_row2; } template <> struct geometric_traits<detail::matrix_double_5x9_row2> { typedef detail::matrix_double_5x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x9,3> matrix_double_5x9_row3; } template <> struct geometric_traits<detail::matrix_double_5x9_row3> { typedef detail::matrix_double_5x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x9,4> matrix_double_5x9_row4; } template <> struct geometric_traits<detail::matrix_double_5x9_row4> { typedef detail::matrix_double_5x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,0> matrix_double_5x9_column0; }template <> struct geometric_traits<detail::matrix_double_5x9_column0> { typedef detail::matrix_double_5x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,1> matrix_double_5x9_column1; }template <> struct geometric_traits<detail::matrix_double_5x9_column1> { typedef detail::matrix_double_5x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,2> matrix_double_5x9_column2; }template <> struct geometric_traits<detail::matrix_double_5x9_column2> { typedef detail::matrix_double_5x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,3> matrix_double_5x9_column3; }template <> struct geometric_traits<detail::matrix_double_5x9_column3> { typedef detail::matrix_double_5x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,4> matrix_double_5x9_column4; }template <> struct geometric_traits<detail::matrix_double_5x9_column4> { typedef detail::matrix_double_5x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,5> matrix_double_5x9_column5; }template <> struct geometric_traits<detail::matrix_double_5x9_column5> { typedef detail::matrix_double_5x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,6> matrix_double_5x9_column6; }template <> struct geometric_traits<detail::matrix_double_5x9_column6> { typedef detail::matrix_double_5x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,7> matrix_double_5x9_column7; }template <> struct geometric_traits<detail::matrix_double_5x9_column7> { typedef detail::matrix_double_5x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x9,8> matrix_double_5x9_column8; }template <> struct geometric_traits<detail::matrix_double_5x9_column8> { typedef detail::matrix_double_5x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x9>::type > : index_operator_matrix_access_policy < matrix_double_5x9 > { typedef index_operator_matrix_access_policy < matrix_double_5x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x9 > { typedef dimension<5> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 5, 10> matrix_double_5x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x10,0> matrix_double_5x10_row0; } template <> struct geometric_traits<detail::matrix_double_5x10_row0> { typedef detail::matrix_double_5x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x10,1> matrix_double_5x10_row1; } template <> struct geometric_traits<detail::matrix_double_5x10_row1> { typedef detail::matrix_double_5x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x10,2> matrix_double_5x10_row2; } template <> struct geometric_traits<detail::matrix_double_5x10_row2> { typedef detail::matrix_double_5x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x10,3> matrix_double_5x10_row3; } template <> struct geometric_traits<detail::matrix_double_5x10_row3> { typedef detail::matrix_double_5x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_5x10,4> matrix_double_5x10_row4; } template <> struct geometric_traits<detail::matrix_double_5x10_row4> { typedef detail::matrix_double_5x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,0> matrix_double_5x10_column0; }template <> struct geometric_traits<detail::matrix_double_5x10_column0> { typedef detail::matrix_double_5x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,1> matrix_double_5x10_column1; }template <> struct geometric_traits<detail::matrix_double_5x10_column1> { typedef detail::matrix_double_5x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,2> matrix_double_5x10_column2; }template <> struct geometric_traits<detail::matrix_double_5x10_column2> { typedef detail::matrix_double_5x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,3> matrix_double_5x10_column3; }template <> struct geometric_traits<detail::matrix_double_5x10_column3> { typedef detail::matrix_double_5x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,4> matrix_double_5x10_column4; }template <> struct geometric_traits<detail::matrix_double_5x10_column4> { typedef detail::matrix_double_5x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,5> matrix_double_5x10_column5; }template <> struct geometric_traits<detail::matrix_double_5x10_column5> { typedef detail::matrix_double_5x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,6> matrix_double_5x10_column6; }template <> struct geometric_traits<detail::matrix_double_5x10_column6> { typedef detail::matrix_double_5x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,7> matrix_double_5x10_column7; }template <> struct geometric_traits<detail::matrix_double_5x10_column7> { typedef detail::matrix_double_5x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,8> matrix_double_5x10_column8; }template <> struct geometric_traits<detail::matrix_double_5x10_column8> { typedef detail::matrix_double_5x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_5x10,9> matrix_double_5x10_column9; }template <> struct geometric_traits<detail::matrix_double_5x10_column9> { typedef detail::matrix_double_5x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_5x10>::type > : index_operator_matrix_access_policy < matrix_double_5x10 > { typedef index_operator_matrix_access_policy < matrix_double_5x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_5x10 > { typedef dimension<5> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 1> matrix_double_6x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,0> matrix_double_6x1_row0; } template <> struct geometric_traits<detail::matrix_double_6x1_row0> { typedef detail::matrix_double_6x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,1> matrix_double_6x1_row1; } template <> struct geometric_traits<detail::matrix_double_6x1_row1> { typedef detail::matrix_double_6x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,2> matrix_double_6x1_row2; } template <> struct geometric_traits<detail::matrix_double_6x1_row2> { typedef detail::matrix_double_6x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,3> matrix_double_6x1_row3; } template <> struct geometric_traits<detail::matrix_double_6x1_row3> { typedef detail::matrix_double_6x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,4> matrix_double_6x1_row4; } template <> struct geometric_traits<detail::matrix_double_6x1_row4> { typedef detail::matrix_double_6x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x1,5> matrix_double_6x1_row5; } template <> struct geometric_traits<detail::matrix_double_6x1_row5> { typedef detail::matrix_double_6x1_row5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x1,0> matrix_double_6x1_column0; }template <> struct geometric_traits<detail::matrix_double_6x1_column0> { typedef detail::matrix_double_6x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x1>::type > : index_operator_matrix_access_policy < matrix_double_6x1 > { typedef index_operator_matrix_access_policy < matrix_double_6x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x1 > { typedef dimension<6> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 2> matrix_double_6x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,0> matrix_double_6x2_row0; } template <> struct geometric_traits<detail::matrix_double_6x2_row0> { typedef detail::matrix_double_6x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,1> matrix_double_6x2_row1; } template <> struct geometric_traits<detail::matrix_double_6x2_row1> { typedef detail::matrix_double_6x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,2> matrix_double_6x2_row2; } template <> struct geometric_traits<detail::matrix_double_6x2_row2> { typedef detail::matrix_double_6x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,3> matrix_double_6x2_row3; } template <> struct geometric_traits<detail::matrix_double_6x2_row3> { typedef detail::matrix_double_6x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,4> matrix_double_6x2_row4; } template <> struct geometric_traits<detail::matrix_double_6x2_row4> { typedef detail::matrix_double_6x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x2,5> matrix_double_6x2_row5; } template <> struct geometric_traits<detail::matrix_double_6x2_row5> { typedef detail::matrix_double_6x2_row5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x2,0> matrix_double_6x2_column0; }template <> struct geometric_traits<detail::matrix_double_6x2_column0> { typedef detail::matrix_double_6x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x2,1> matrix_double_6x2_column1; }template <> struct geometric_traits<detail::matrix_double_6x2_column1> { typedef detail::matrix_double_6x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x2>::type > : index_operator_matrix_access_policy < matrix_double_6x2 > { typedef index_operator_matrix_access_policy < matrix_double_6x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x2 > { typedef dimension<6> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 3> matrix_double_6x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,0> matrix_double_6x3_row0; } template <> struct geometric_traits<detail::matrix_double_6x3_row0> { typedef detail::matrix_double_6x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,1> matrix_double_6x3_row1; } template <> struct geometric_traits<detail::matrix_double_6x3_row1> { typedef detail::matrix_double_6x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,2> matrix_double_6x3_row2; } template <> struct geometric_traits<detail::matrix_double_6x3_row2> { typedef detail::matrix_double_6x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,3> matrix_double_6x3_row3; } template <> struct geometric_traits<detail::matrix_double_6x3_row3> { typedef detail::matrix_double_6x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,4> matrix_double_6x3_row4; } template <> struct geometric_traits<detail::matrix_double_6x3_row4> { typedef detail::matrix_double_6x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x3,5> matrix_double_6x3_row5; } template <> struct geometric_traits<detail::matrix_double_6x3_row5> { typedef detail::matrix_double_6x3_row5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x3,0> matrix_double_6x3_column0; }template <> struct geometric_traits<detail::matrix_double_6x3_column0> { typedef detail::matrix_double_6x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x3,1> matrix_double_6x3_column1; }template <> struct geometric_traits<detail::matrix_double_6x3_column1> { typedef detail::matrix_double_6x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x3,2> matrix_double_6x3_column2; }template <> struct geometric_traits<detail::matrix_double_6x3_column2> { typedef detail::matrix_double_6x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x3>::type > : index_operator_matrix_access_policy < matrix_double_6x3 > { typedef index_operator_matrix_access_policy < matrix_double_6x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x3 > { typedef dimension<6> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 4> matrix_double_6x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,0> matrix_double_6x4_row0; } template <> struct geometric_traits<detail::matrix_double_6x4_row0> { typedef detail::matrix_double_6x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,1> matrix_double_6x4_row1; } template <> struct geometric_traits<detail::matrix_double_6x4_row1> { typedef detail::matrix_double_6x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,2> matrix_double_6x4_row2; } template <> struct geometric_traits<detail::matrix_double_6x4_row2> { typedef detail::matrix_double_6x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,3> matrix_double_6x4_row3; } template <> struct geometric_traits<detail::matrix_double_6x4_row3> { typedef detail::matrix_double_6x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,4> matrix_double_6x4_row4; } template <> struct geometric_traits<detail::matrix_double_6x4_row4> { typedef detail::matrix_double_6x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x4,5> matrix_double_6x4_row5; } template <> struct geometric_traits<detail::matrix_double_6x4_row5> { typedef detail::matrix_double_6x4_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x4,0> matrix_double_6x4_column0; }template <> struct geometric_traits<detail::matrix_double_6x4_column0> { typedef detail::matrix_double_6x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x4,1> matrix_double_6x4_column1; }template <> struct geometric_traits<detail::matrix_double_6x4_column1> { typedef detail::matrix_double_6x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x4,2> matrix_double_6x4_column2; }template <> struct geometric_traits<detail::matrix_double_6x4_column2> { typedef detail::matrix_double_6x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x4,3> matrix_double_6x4_column3; }template <> struct geometric_traits<detail::matrix_double_6x4_column3> { typedef detail::matrix_double_6x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x4>::type > : index_operator_matrix_access_policy < matrix_double_6x4 > { typedef index_operator_matrix_access_policy < matrix_double_6x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x4 > { typedef dimension<6> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 5> matrix_double_6x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,0> matrix_double_6x5_row0; } template <> struct geometric_traits<detail::matrix_double_6x5_row0> { typedef detail::matrix_double_6x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,1> matrix_double_6x5_row1; } template <> struct geometric_traits<detail::matrix_double_6x5_row1> { typedef detail::matrix_double_6x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,2> matrix_double_6x5_row2; } template <> struct geometric_traits<detail::matrix_double_6x5_row2> { typedef detail::matrix_double_6x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,3> matrix_double_6x5_row3; } template <> struct geometric_traits<detail::matrix_double_6x5_row3> { typedef detail::matrix_double_6x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,4> matrix_double_6x5_row4; } template <> struct geometric_traits<detail::matrix_double_6x5_row4> { typedef detail::matrix_double_6x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x5,5> matrix_double_6x5_row5; } template <> struct geometric_traits<detail::matrix_double_6x5_row5> { typedef detail::matrix_double_6x5_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x5,0> matrix_double_6x5_column0; }template <> struct geometric_traits<detail::matrix_double_6x5_column0> { typedef detail::matrix_double_6x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x5,1> matrix_double_6x5_column1; }template <> struct geometric_traits<detail::matrix_double_6x5_column1> { typedef detail::matrix_double_6x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x5,2> matrix_double_6x5_column2; }template <> struct geometric_traits<detail::matrix_double_6x5_column2> { typedef detail::matrix_double_6x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x5,3> matrix_double_6x5_column3; }template <> struct geometric_traits<detail::matrix_double_6x5_column3> { typedef detail::matrix_double_6x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x5,4> matrix_double_6x5_column4; }template <> struct geometric_traits<detail::matrix_double_6x5_column4> { typedef detail::matrix_double_6x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x5>::type > : index_operator_matrix_access_policy < matrix_double_6x5 > { typedef index_operator_matrix_access_policy < matrix_double_6x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x5 > { typedef dimension<6> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 6> matrix_double_6x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,0> matrix_double_6x6_row0; } template <> struct geometric_traits<detail::matrix_double_6x6_row0> { typedef detail::matrix_double_6x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,1> matrix_double_6x6_row1; } template <> struct geometric_traits<detail::matrix_double_6x6_row1> { typedef detail::matrix_double_6x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,2> matrix_double_6x6_row2; } template <> struct geometric_traits<detail::matrix_double_6x6_row2> { typedef detail::matrix_double_6x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,3> matrix_double_6x6_row3; } template <> struct geometric_traits<detail::matrix_double_6x6_row3> { typedef detail::matrix_double_6x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,4> matrix_double_6x6_row4; } template <> struct geometric_traits<detail::matrix_double_6x6_row4> { typedef detail::matrix_double_6x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x6,5> matrix_double_6x6_row5; } template <> struct geometric_traits<detail::matrix_double_6x6_row5> { typedef detail::matrix_double_6x6_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,0> matrix_double_6x6_column0; }template <> struct geometric_traits<detail::matrix_double_6x6_column0> { typedef detail::matrix_double_6x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,1> matrix_double_6x6_column1; }template <> struct geometric_traits<detail::matrix_double_6x6_column1> { typedef detail::matrix_double_6x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,2> matrix_double_6x6_column2; }template <> struct geometric_traits<detail::matrix_double_6x6_column2> { typedef detail::matrix_double_6x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,3> matrix_double_6x6_column3; }template <> struct geometric_traits<detail::matrix_double_6x6_column3> { typedef detail::matrix_double_6x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,4> matrix_double_6x6_column4; }template <> struct geometric_traits<detail::matrix_double_6x6_column4> { typedef detail::matrix_double_6x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x6,5> matrix_double_6x6_column5; }template <> struct geometric_traits<detail::matrix_double_6x6_column5> { typedef detail::matrix_double_6x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x6>::type > : index_operator_matrix_access_policy < matrix_double_6x6 > { typedef index_operator_matrix_access_policy < matrix_double_6x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x6 > { typedef dimension<6> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 7> matrix_double_6x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,0> matrix_double_6x7_row0; } template <> struct geometric_traits<detail::matrix_double_6x7_row0> { typedef detail::matrix_double_6x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,1> matrix_double_6x7_row1; } template <> struct geometric_traits<detail::matrix_double_6x7_row1> { typedef detail::matrix_double_6x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,2> matrix_double_6x7_row2; } template <> struct geometric_traits<detail::matrix_double_6x7_row2> { typedef detail::matrix_double_6x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,3> matrix_double_6x7_row3; } template <> struct geometric_traits<detail::matrix_double_6x7_row3> { typedef detail::matrix_double_6x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,4> matrix_double_6x7_row4; } template <> struct geometric_traits<detail::matrix_double_6x7_row4> { typedef detail::matrix_double_6x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x7,5> matrix_double_6x7_row5; } template <> struct geometric_traits<detail::matrix_double_6x7_row5> { typedef detail::matrix_double_6x7_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,0> matrix_double_6x7_column0; }template <> struct geometric_traits<detail::matrix_double_6x7_column0> { typedef detail::matrix_double_6x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,1> matrix_double_6x7_column1; }template <> struct geometric_traits<detail::matrix_double_6x7_column1> { typedef detail::matrix_double_6x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,2> matrix_double_6x7_column2; }template <> struct geometric_traits<detail::matrix_double_6x7_column2> { typedef detail::matrix_double_6x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,3> matrix_double_6x7_column3; }template <> struct geometric_traits<detail::matrix_double_6x7_column3> { typedef detail::matrix_double_6x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,4> matrix_double_6x7_column4; }template <> struct geometric_traits<detail::matrix_double_6x7_column4> { typedef detail::matrix_double_6x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,5> matrix_double_6x7_column5; }template <> struct geometric_traits<detail::matrix_double_6x7_column5> { typedef detail::matrix_double_6x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x7,6> matrix_double_6x7_column6; }template <> struct geometric_traits<detail::matrix_double_6x7_column6> { typedef detail::matrix_double_6x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x7>::type > : index_operator_matrix_access_policy < matrix_double_6x7 > { typedef index_operator_matrix_access_policy < matrix_double_6x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x7 > { typedef dimension<6> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 8> matrix_double_6x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,0> matrix_double_6x8_row0; } template <> struct geometric_traits<detail::matrix_double_6x8_row0> { typedef detail::matrix_double_6x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,1> matrix_double_6x8_row1; } template <> struct geometric_traits<detail::matrix_double_6x8_row1> { typedef detail::matrix_double_6x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,2> matrix_double_6x8_row2; } template <> struct geometric_traits<detail::matrix_double_6x8_row2> { typedef detail::matrix_double_6x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,3> matrix_double_6x8_row3; } template <> struct geometric_traits<detail::matrix_double_6x8_row3> { typedef detail::matrix_double_6x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,4> matrix_double_6x8_row4; } template <> struct geometric_traits<detail::matrix_double_6x8_row4> { typedef detail::matrix_double_6x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x8,5> matrix_double_6x8_row5; } template <> struct geometric_traits<detail::matrix_double_6x8_row5> { typedef detail::matrix_double_6x8_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,0> matrix_double_6x8_column0; }template <> struct geometric_traits<detail::matrix_double_6x8_column0> { typedef detail::matrix_double_6x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,1> matrix_double_6x8_column1; }template <> struct geometric_traits<detail::matrix_double_6x8_column1> { typedef detail::matrix_double_6x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,2> matrix_double_6x8_column2; }template <> struct geometric_traits<detail::matrix_double_6x8_column2> { typedef detail::matrix_double_6x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,3> matrix_double_6x8_column3; }template <> struct geometric_traits<detail::matrix_double_6x8_column3> { typedef detail::matrix_double_6x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,4> matrix_double_6x8_column4; }template <> struct geometric_traits<detail::matrix_double_6x8_column4> { typedef detail::matrix_double_6x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,5> matrix_double_6x8_column5; }template <> struct geometric_traits<detail::matrix_double_6x8_column5> { typedef detail::matrix_double_6x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,6> matrix_double_6x8_column6; }template <> struct geometric_traits<detail::matrix_double_6x8_column6> { typedef detail::matrix_double_6x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x8,7> matrix_double_6x8_column7; }template <> struct geometric_traits<detail::matrix_double_6x8_column7> { typedef detail::matrix_double_6x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x8>::type > : index_operator_matrix_access_policy < matrix_double_6x8 > { typedef index_operator_matrix_access_policy < matrix_double_6x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x8 > { typedef dimension<6> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 9> matrix_double_6x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,0> matrix_double_6x9_row0; } template <> struct geometric_traits<detail::matrix_double_6x9_row0> { typedef detail::matrix_double_6x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,1> matrix_double_6x9_row1; } template <> struct geometric_traits<detail::matrix_double_6x9_row1> { typedef detail::matrix_double_6x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,2> matrix_double_6x9_row2; } template <> struct geometric_traits<detail::matrix_double_6x9_row2> { typedef detail::matrix_double_6x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,3> matrix_double_6x9_row3; } template <> struct geometric_traits<detail::matrix_double_6x9_row3> { typedef detail::matrix_double_6x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,4> matrix_double_6x9_row4; } template <> struct geometric_traits<detail::matrix_double_6x9_row4> { typedef detail::matrix_double_6x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x9,5> matrix_double_6x9_row5; } template <> struct geometric_traits<detail::matrix_double_6x9_row5> { typedef detail::matrix_double_6x9_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,0> matrix_double_6x9_column0; }template <> struct geometric_traits<detail::matrix_double_6x9_column0> { typedef detail::matrix_double_6x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,1> matrix_double_6x9_column1; }template <> struct geometric_traits<detail::matrix_double_6x9_column1> { typedef detail::matrix_double_6x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,2> matrix_double_6x9_column2; }template <> struct geometric_traits<detail::matrix_double_6x9_column2> { typedef detail::matrix_double_6x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,3> matrix_double_6x9_column3; }template <> struct geometric_traits<detail::matrix_double_6x9_column3> { typedef detail::matrix_double_6x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,4> matrix_double_6x9_column4; }template <> struct geometric_traits<detail::matrix_double_6x9_column4> { typedef detail::matrix_double_6x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,5> matrix_double_6x9_column5; }template <> struct geometric_traits<detail::matrix_double_6x9_column5> { typedef detail::matrix_double_6x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,6> matrix_double_6x9_column6; }template <> struct geometric_traits<detail::matrix_double_6x9_column6> { typedef detail::matrix_double_6x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,7> matrix_double_6x9_column7; }template <> struct geometric_traits<detail::matrix_double_6x9_column7> { typedef detail::matrix_double_6x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x9,8> matrix_double_6x9_column8; }template <> struct geometric_traits<detail::matrix_double_6x9_column8> { typedef detail::matrix_double_6x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x9>::type > : index_operator_matrix_access_policy < matrix_double_6x9 > { typedef index_operator_matrix_access_policy < matrix_double_6x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x9 > { typedef dimension<6> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 6, 10> matrix_double_6x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,0> matrix_double_6x10_row0; } template <> struct geometric_traits<detail::matrix_double_6x10_row0> { typedef detail::matrix_double_6x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,1> matrix_double_6x10_row1; } template <> struct geometric_traits<detail::matrix_double_6x10_row1> { typedef detail::matrix_double_6x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,2> matrix_double_6x10_row2; } template <> struct geometric_traits<detail::matrix_double_6x10_row2> { typedef detail::matrix_double_6x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,3> matrix_double_6x10_row3; } template <> struct geometric_traits<detail::matrix_double_6x10_row3> { typedef detail::matrix_double_6x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,4> matrix_double_6x10_row4; } template <> struct geometric_traits<detail::matrix_double_6x10_row4> { typedef detail::matrix_double_6x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_6x10,5> matrix_double_6x10_row5; } template <> struct geometric_traits<detail::matrix_double_6x10_row5> { typedef detail::matrix_double_6x10_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,0> matrix_double_6x10_column0; }template <> struct geometric_traits<detail::matrix_double_6x10_column0> { typedef detail::matrix_double_6x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,1> matrix_double_6x10_column1; }template <> struct geometric_traits<detail::matrix_double_6x10_column1> { typedef detail::matrix_double_6x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,2> matrix_double_6x10_column2; }template <> struct geometric_traits<detail::matrix_double_6x10_column2> { typedef detail::matrix_double_6x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,3> matrix_double_6x10_column3; }template <> struct geometric_traits<detail::matrix_double_6x10_column3> { typedef detail::matrix_double_6x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,4> matrix_double_6x10_column4; }template <> struct geometric_traits<detail::matrix_double_6x10_column4> { typedef detail::matrix_double_6x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,5> matrix_double_6x10_column5; }template <> struct geometric_traits<detail::matrix_double_6x10_column5> { typedef detail::matrix_double_6x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,6> matrix_double_6x10_column6; }template <> struct geometric_traits<detail::matrix_double_6x10_column6> { typedef detail::matrix_double_6x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,7> matrix_double_6x10_column7; }template <> struct geometric_traits<detail::matrix_double_6x10_column7> { typedef detail::matrix_double_6x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,8> matrix_double_6x10_column8; }template <> struct geometric_traits<detail::matrix_double_6x10_column8> { typedef detail::matrix_double_6x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_6x10,9> matrix_double_6x10_column9; }template <> struct geometric_traits<detail::matrix_double_6x10_column9> { typedef detail::matrix_double_6x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_6x10>::type > : index_operator_matrix_access_policy < matrix_double_6x10 > { typedef index_operator_matrix_access_policy < matrix_double_6x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_6x10 > { typedef dimension<6> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 1> matrix_double_7x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,0> matrix_double_7x1_row0; } template <> struct geometric_traits<detail::matrix_double_7x1_row0> { typedef detail::matrix_double_7x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,1> matrix_double_7x1_row1; } template <> struct geometric_traits<detail::matrix_double_7x1_row1> { typedef detail::matrix_double_7x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,2> matrix_double_7x1_row2; } template <> struct geometric_traits<detail::matrix_double_7x1_row2> { typedef detail::matrix_double_7x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,3> matrix_double_7x1_row3; } template <> struct geometric_traits<detail::matrix_double_7x1_row3> { typedef detail::matrix_double_7x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,4> matrix_double_7x1_row4; } template <> struct geometric_traits<detail::matrix_double_7x1_row4> { typedef detail::matrix_double_7x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,5> matrix_double_7x1_row5; } template <> struct geometric_traits<detail::matrix_double_7x1_row5> { typedef detail::matrix_double_7x1_row5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x1,6> matrix_double_7x1_row6; } template <> struct geometric_traits<detail::matrix_double_7x1_row6> { typedef detail::matrix_double_7x1_row6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x1,0> matrix_double_7x1_column0; }template <> struct geometric_traits<detail::matrix_double_7x1_column0> { typedef detail::matrix_double_7x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x1>::type > : index_operator_matrix_access_policy < matrix_double_7x1 > { typedef index_operator_matrix_access_policy < matrix_double_7x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x1 > { typedef dimension<7> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 2> matrix_double_7x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,0> matrix_double_7x2_row0; } template <> struct geometric_traits<detail::matrix_double_7x2_row0> { typedef detail::matrix_double_7x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,1> matrix_double_7x2_row1; } template <> struct geometric_traits<detail::matrix_double_7x2_row1> { typedef detail::matrix_double_7x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,2> matrix_double_7x2_row2; } template <> struct geometric_traits<detail::matrix_double_7x2_row2> { typedef detail::matrix_double_7x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,3> matrix_double_7x2_row3; } template <> struct geometric_traits<detail::matrix_double_7x2_row3> { typedef detail::matrix_double_7x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,4> matrix_double_7x2_row4; } template <> struct geometric_traits<detail::matrix_double_7x2_row4> { typedef detail::matrix_double_7x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,5> matrix_double_7x2_row5; } template <> struct geometric_traits<detail::matrix_double_7x2_row5> { typedef detail::matrix_double_7x2_row5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x2,6> matrix_double_7x2_row6; } template <> struct geometric_traits<detail::matrix_double_7x2_row6> { typedef detail::matrix_double_7x2_row6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x2,0> matrix_double_7x2_column0; }template <> struct geometric_traits<detail::matrix_double_7x2_column0> { typedef detail::matrix_double_7x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x2,1> matrix_double_7x2_column1; }template <> struct geometric_traits<detail::matrix_double_7x2_column1> { typedef detail::matrix_double_7x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x2>::type > : index_operator_matrix_access_policy < matrix_double_7x2 > { typedef index_operator_matrix_access_policy < matrix_double_7x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x2 > { typedef dimension<7> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 3> matrix_double_7x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,0> matrix_double_7x3_row0; } template <> struct geometric_traits<detail::matrix_double_7x3_row0> { typedef detail::matrix_double_7x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,1> matrix_double_7x3_row1; } template <> struct geometric_traits<detail::matrix_double_7x3_row1> { typedef detail::matrix_double_7x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,2> matrix_double_7x3_row2; } template <> struct geometric_traits<detail::matrix_double_7x3_row2> { typedef detail::matrix_double_7x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,3> matrix_double_7x3_row3; } template <> struct geometric_traits<detail::matrix_double_7x3_row3> { typedef detail::matrix_double_7x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,4> matrix_double_7x3_row4; } template <> struct geometric_traits<detail::matrix_double_7x3_row4> { typedef detail::matrix_double_7x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,5> matrix_double_7x3_row5; } template <> struct geometric_traits<detail::matrix_double_7x3_row5> { typedef detail::matrix_double_7x3_row5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x3,6> matrix_double_7x3_row6; } template <> struct geometric_traits<detail::matrix_double_7x3_row6> { typedef detail::matrix_double_7x3_row6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x3,0> matrix_double_7x3_column0; }template <> struct geometric_traits<detail::matrix_double_7x3_column0> { typedef detail::matrix_double_7x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x3,1> matrix_double_7x3_column1; }template <> struct geometric_traits<detail::matrix_double_7x3_column1> { typedef detail::matrix_double_7x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x3,2> matrix_double_7x3_column2; }template <> struct geometric_traits<detail::matrix_double_7x3_column2> { typedef detail::matrix_double_7x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x3>::type > : index_operator_matrix_access_policy < matrix_double_7x3 > { typedef index_operator_matrix_access_policy < matrix_double_7x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x3 > { typedef dimension<7> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 4> matrix_double_7x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,0> matrix_double_7x4_row0; } template <> struct geometric_traits<detail::matrix_double_7x4_row0> { typedef detail::matrix_double_7x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,1> matrix_double_7x4_row1; } template <> struct geometric_traits<detail::matrix_double_7x4_row1> { typedef detail::matrix_double_7x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,2> matrix_double_7x4_row2; } template <> struct geometric_traits<detail::matrix_double_7x4_row2> { typedef detail::matrix_double_7x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,3> matrix_double_7x4_row3; } template <> struct geometric_traits<detail::matrix_double_7x4_row3> { typedef detail::matrix_double_7x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,4> matrix_double_7x4_row4; } template <> struct geometric_traits<detail::matrix_double_7x4_row4> { typedef detail::matrix_double_7x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,5> matrix_double_7x4_row5; } template <> struct geometric_traits<detail::matrix_double_7x4_row5> { typedef detail::matrix_double_7x4_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x4,6> matrix_double_7x4_row6; } template <> struct geometric_traits<detail::matrix_double_7x4_row6> { typedef detail::matrix_double_7x4_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x4,0> matrix_double_7x4_column0; }template <> struct geometric_traits<detail::matrix_double_7x4_column0> { typedef detail::matrix_double_7x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x4,1> matrix_double_7x4_column1; }template <> struct geometric_traits<detail::matrix_double_7x4_column1> { typedef detail::matrix_double_7x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x4,2> matrix_double_7x4_column2; }template <> struct geometric_traits<detail::matrix_double_7x4_column2> { typedef detail::matrix_double_7x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x4,3> matrix_double_7x4_column3; }template <> struct geometric_traits<detail::matrix_double_7x4_column3> { typedef detail::matrix_double_7x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x4>::type > : index_operator_matrix_access_policy < matrix_double_7x4 > { typedef index_operator_matrix_access_policy < matrix_double_7x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x4 > { typedef dimension<7> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 5> matrix_double_7x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,0> matrix_double_7x5_row0; } template <> struct geometric_traits<detail::matrix_double_7x5_row0> { typedef detail::matrix_double_7x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,1> matrix_double_7x5_row1; } template <> struct geometric_traits<detail::matrix_double_7x5_row1> { typedef detail::matrix_double_7x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,2> matrix_double_7x5_row2; } template <> struct geometric_traits<detail::matrix_double_7x5_row2> { typedef detail::matrix_double_7x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,3> matrix_double_7x5_row3; } template <> struct geometric_traits<detail::matrix_double_7x5_row3> { typedef detail::matrix_double_7x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,4> matrix_double_7x5_row4; } template <> struct geometric_traits<detail::matrix_double_7x5_row4> { typedef detail::matrix_double_7x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,5> matrix_double_7x5_row5; } template <> struct geometric_traits<detail::matrix_double_7x5_row5> { typedef detail::matrix_double_7x5_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x5,6> matrix_double_7x5_row6; } template <> struct geometric_traits<detail::matrix_double_7x5_row6> { typedef detail::matrix_double_7x5_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x5,0> matrix_double_7x5_column0; }template <> struct geometric_traits<detail::matrix_double_7x5_column0> { typedef detail::matrix_double_7x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x5,1> matrix_double_7x5_column1; }template <> struct geometric_traits<detail::matrix_double_7x5_column1> { typedef detail::matrix_double_7x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x5,2> matrix_double_7x5_column2; }template <> struct geometric_traits<detail::matrix_double_7x5_column2> { typedef detail::matrix_double_7x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x5,3> matrix_double_7x5_column3; }template <> struct geometric_traits<detail::matrix_double_7x5_column3> { typedef detail::matrix_double_7x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x5,4> matrix_double_7x5_column4; }template <> struct geometric_traits<detail::matrix_double_7x5_column4> { typedef detail::matrix_double_7x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x5>::type > : index_operator_matrix_access_policy < matrix_double_7x5 > { typedef index_operator_matrix_access_policy < matrix_double_7x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x5 > { typedef dimension<7> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 6> matrix_double_7x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,0> matrix_double_7x6_row0; } template <> struct geometric_traits<detail::matrix_double_7x6_row0> { typedef detail::matrix_double_7x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,1> matrix_double_7x6_row1; } template <> struct geometric_traits<detail::matrix_double_7x6_row1> { typedef detail::matrix_double_7x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,2> matrix_double_7x6_row2; } template <> struct geometric_traits<detail::matrix_double_7x6_row2> { typedef detail::matrix_double_7x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,3> matrix_double_7x6_row3; } template <> struct geometric_traits<detail::matrix_double_7x6_row3> { typedef detail::matrix_double_7x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,4> matrix_double_7x6_row4; } template <> struct geometric_traits<detail::matrix_double_7x6_row4> { typedef detail::matrix_double_7x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,5> matrix_double_7x6_row5; } template <> struct geometric_traits<detail::matrix_double_7x6_row5> { typedef detail::matrix_double_7x6_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x6,6> matrix_double_7x6_row6; } template <> struct geometric_traits<detail::matrix_double_7x6_row6> { typedef detail::matrix_double_7x6_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,0> matrix_double_7x6_column0; }template <> struct geometric_traits<detail::matrix_double_7x6_column0> { typedef detail::matrix_double_7x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,1> matrix_double_7x6_column1; }template <> struct geometric_traits<detail::matrix_double_7x6_column1> { typedef detail::matrix_double_7x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,2> matrix_double_7x6_column2; }template <> struct geometric_traits<detail::matrix_double_7x6_column2> { typedef detail::matrix_double_7x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,3> matrix_double_7x6_column3; }template <> struct geometric_traits<detail::matrix_double_7x6_column3> { typedef detail::matrix_double_7x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,4> matrix_double_7x6_column4; }template <> struct geometric_traits<detail::matrix_double_7x6_column4> { typedef detail::matrix_double_7x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x6,5> matrix_double_7x6_column5; }template <> struct geometric_traits<detail::matrix_double_7x6_column5> { typedef detail::matrix_double_7x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x6>::type > : index_operator_matrix_access_policy < matrix_double_7x6 > { typedef index_operator_matrix_access_policy < matrix_double_7x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x6 > { typedef dimension<7> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 7> matrix_double_7x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,0> matrix_double_7x7_row0; } template <> struct geometric_traits<detail::matrix_double_7x7_row0> { typedef detail::matrix_double_7x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,1> matrix_double_7x7_row1; } template <> struct geometric_traits<detail::matrix_double_7x7_row1> { typedef detail::matrix_double_7x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,2> matrix_double_7x7_row2; } template <> struct geometric_traits<detail::matrix_double_7x7_row2> { typedef detail::matrix_double_7x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,3> matrix_double_7x7_row3; } template <> struct geometric_traits<detail::matrix_double_7x7_row3> { typedef detail::matrix_double_7x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,4> matrix_double_7x7_row4; } template <> struct geometric_traits<detail::matrix_double_7x7_row4> { typedef detail::matrix_double_7x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,5> matrix_double_7x7_row5; } template <> struct geometric_traits<detail::matrix_double_7x7_row5> { typedef detail::matrix_double_7x7_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x7,6> matrix_double_7x7_row6; } template <> struct geometric_traits<detail::matrix_double_7x7_row6> { typedef detail::matrix_double_7x7_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,0> matrix_double_7x7_column0; }template <> struct geometric_traits<detail::matrix_double_7x7_column0> { typedef detail::matrix_double_7x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,1> matrix_double_7x7_column1; }template <> struct geometric_traits<detail::matrix_double_7x7_column1> { typedef detail::matrix_double_7x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,2> matrix_double_7x7_column2; }template <> struct geometric_traits<detail::matrix_double_7x7_column2> { typedef detail::matrix_double_7x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,3> matrix_double_7x7_column3; }template <> struct geometric_traits<detail::matrix_double_7x7_column3> { typedef detail::matrix_double_7x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,4> matrix_double_7x7_column4; }template <> struct geometric_traits<detail::matrix_double_7x7_column4> { typedef detail::matrix_double_7x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,5> matrix_double_7x7_column5; }template <> struct geometric_traits<detail::matrix_double_7x7_column5> { typedef detail::matrix_double_7x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x7,6> matrix_double_7x7_column6; }template <> struct geometric_traits<detail::matrix_double_7x7_column6> { typedef detail::matrix_double_7x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x7>::type > : index_operator_matrix_access_policy < matrix_double_7x7 > { typedef index_operator_matrix_access_policy < matrix_double_7x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x7 > { typedef dimension<7> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 8> matrix_double_7x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,0> matrix_double_7x8_row0; } template <> struct geometric_traits<detail::matrix_double_7x8_row0> { typedef detail::matrix_double_7x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,1> matrix_double_7x8_row1; } template <> struct geometric_traits<detail::matrix_double_7x8_row1> { typedef detail::matrix_double_7x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,2> matrix_double_7x8_row2; } template <> struct geometric_traits<detail::matrix_double_7x8_row2> { typedef detail::matrix_double_7x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,3> matrix_double_7x8_row3; } template <> struct geometric_traits<detail::matrix_double_7x8_row3> { typedef detail::matrix_double_7x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,4> matrix_double_7x8_row4; } template <> struct geometric_traits<detail::matrix_double_7x8_row4> { typedef detail::matrix_double_7x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,5> matrix_double_7x8_row5; } template <> struct geometric_traits<detail::matrix_double_7x8_row5> { typedef detail::matrix_double_7x8_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x8,6> matrix_double_7x8_row6; } template <> struct geometric_traits<detail::matrix_double_7x8_row6> { typedef detail::matrix_double_7x8_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,0> matrix_double_7x8_column0; }template <> struct geometric_traits<detail::matrix_double_7x8_column0> { typedef detail::matrix_double_7x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,1> matrix_double_7x8_column1; }template <> struct geometric_traits<detail::matrix_double_7x8_column1> { typedef detail::matrix_double_7x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,2> matrix_double_7x8_column2; }template <> struct geometric_traits<detail::matrix_double_7x8_column2> { typedef detail::matrix_double_7x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,3> matrix_double_7x8_column3; }template <> struct geometric_traits<detail::matrix_double_7x8_column3> { typedef detail::matrix_double_7x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,4> matrix_double_7x8_column4; }template <> struct geometric_traits<detail::matrix_double_7x8_column4> { typedef detail::matrix_double_7x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,5> matrix_double_7x8_column5; }template <> struct geometric_traits<detail::matrix_double_7x8_column5> { typedef detail::matrix_double_7x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,6> matrix_double_7x8_column6; }template <> struct geometric_traits<detail::matrix_double_7x8_column6> { typedef detail::matrix_double_7x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x8,7> matrix_double_7x8_column7; }template <> struct geometric_traits<detail::matrix_double_7x8_column7> { typedef detail::matrix_double_7x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x8>::type > : index_operator_matrix_access_policy < matrix_double_7x8 > { typedef index_operator_matrix_access_policy < matrix_double_7x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x8 > { typedef dimension<7> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 9> matrix_double_7x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,0> matrix_double_7x9_row0; } template <> struct geometric_traits<detail::matrix_double_7x9_row0> { typedef detail::matrix_double_7x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,1> matrix_double_7x9_row1; } template <> struct geometric_traits<detail::matrix_double_7x9_row1> { typedef detail::matrix_double_7x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,2> matrix_double_7x9_row2; } template <> struct geometric_traits<detail::matrix_double_7x9_row2> { typedef detail::matrix_double_7x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,3> matrix_double_7x9_row3; } template <> struct geometric_traits<detail::matrix_double_7x9_row3> { typedef detail::matrix_double_7x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,4> matrix_double_7x9_row4; } template <> struct geometric_traits<detail::matrix_double_7x9_row4> { typedef detail::matrix_double_7x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,5> matrix_double_7x9_row5; } template <> struct geometric_traits<detail::matrix_double_7x9_row5> { typedef detail::matrix_double_7x9_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x9,6> matrix_double_7x9_row6; } template <> struct geometric_traits<detail::matrix_double_7x9_row6> { typedef detail::matrix_double_7x9_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,0> matrix_double_7x9_column0; }template <> struct geometric_traits<detail::matrix_double_7x9_column0> { typedef detail::matrix_double_7x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,1> matrix_double_7x9_column1; }template <> struct geometric_traits<detail::matrix_double_7x9_column1> { typedef detail::matrix_double_7x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,2> matrix_double_7x9_column2; }template <> struct geometric_traits<detail::matrix_double_7x9_column2> { typedef detail::matrix_double_7x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,3> matrix_double_7x9_column3; }template <> struct geometric_traits<detail::matrix_double_7x9_column3> { typedef detail::matrix_double_7x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,4> matrix_double_7x9_column4; }template <> struct geometric_traits<detail::matrix_double_7x9_column4> { typedef detail::matrix_double_7x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,5> matrix_double_7x9_column5; }template <> struct geometric_traits<detail::matrix_double_7x9_column5> { typedef detail::matrix_double_7x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,6> matrix_double_7x9_column6; }template <> struct geometric_traits<detail::matrix_double_7x9_column6> { typedef detail::matrix_double_7x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,7> matrix_double_7x9_column7; }template <> struct geometric_traits<detail::matrix_double_7x9_column7> { typedef detail::matrix_double_7x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x9,8> matrix_double_7x9_column8; }template <> struct geometric_traits<detail::matrix_double_7x9_column8> { typedef detail::matrix_double_7x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x9>::type > : index_operator_matrix_access_policy < matrix_double_7x9 > { typedef index_operator_matrix_access_policy < matrix_double_7x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x9 > { typedef dimension<7> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 7, 10> matrix_double_7x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,0> matrix_double_7x10_row0; } template <> struct geometric_traits<detail::matrix_double_7x10_row0> { typedef detail::matrix_double_7x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,1> matrix_double_7x10_row1; } template <> struct geometric_traits<detail::matrix_double_7x10_row1> { typedef detail::matrix_double_7x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,2> matrix_double_7x10_row2; } template <> struct geometric_traits<detail::matrix_double_7x10_row2> { typedef detail::matrix_double_7x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,3> matrix_double_7x10_row3; } template <> struct geometric_traits<detail::matrix_double_7x10_row3> { typedef detail::matrix_double_7x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,4> matrix_double_7x10_row4; } template <> struct geometric_traits<detail::matrix_double_7x10_row4> { typedef detail::matrix_double_7x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,5> matrix_double_7x10_row5; } template <> struct geometric_traits<detail::matrix_double_7x10_row5> { typedef detail::matrix_double_7x10_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_7x10,6> matrix_double_7x10_row6; } template <> struct geometric_traits<detail::matrix_double_7x10_row6> { typedef detail::matrix_double_7x10_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,0> matrix_double_7x10_column0; }template <> struct geometric_traits<detail::matrix_double_7x10_column0> { typedef detail::matrix_double_7x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,1> matrix_double_7x10_column1; }template <> struct geometric_traits<detail::matrix_double_7x10_column1> { typedef detail::matrix_double_7x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,2> matrix_double_7x10_column2; }template <> struct geometric_traits<detail::matrix_double_7x10_column2> { typedef detail::matrix_double_7x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,3> matrix_double_7x10_column3; }template <> struct geometric_traits<detail::matrix_double_7x10_column3> { typedef detail::matrix_double_7x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,4> matrix_double_7x10_column4; }template <> struct geometric_traits<detail::matrix_double_7x10_column4> { typedef detail::matrix_double_7x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,5> matrix_double_7x10_column5; }template <> struct geometric_traits<detail::matrix_double_7x10_column5> { typedef detail::matrix_double_7x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,6> matrix_double_7x10_column6; }template <> struct geometric_traits<detail::matrix_double_7x10_column6> { typedef detail::matrix_double_7x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,7> matrix_double_7x10_column7; }template <> struct geometric_traits<detail::matrix_double_7x10_column7> { typedef detail::matrix_double_7x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,8> matrix_double_7x10_column8; }template <> struct geometric_traits<detail::matrix_double_7x10_column8> { typedef detail::matrix_double_7x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_7x10,9> matrix_double_7x10_column9; }template <> struct geometric_traits<detail::matrix_double_7x10_column9> { typedef detail::matrix_double_7x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_7x10>::type > : index_operator_matrix_access_policy < matrix_double_7x10 > { typedef index_operator_matrix_access_policy < matrix_double_7x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_7x10 > { typedef dimension<7> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 1> matrix_double_8x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,0> matrix_double_8x1_row0; } template <> struct geometric_traits<detail::matrix_double_8x1_row0> { typedef detail::matrix_double_8x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,1> matrix_double_8x1_row1; } template <> struct geometric_traits<detail::matrix_double_8x1_row1> { typedef detail::matrix_double_8x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,2> matrix_double_8x1_row2; } template <> struct geometric_traits<detail::matrix_double_8x1_row2> { typedef detail::matrix_double_8x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,3> matrix_double_8x1_row3; } template <> struct geometric_traits<detail::matrix_double_8x1_row3> { typedef detail::matrix_double_8x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,4> matrix_double_8x1_row4; } template <> struct geometric_traits<detail::matrix_double_8x1_row4> { typedef detail::matrix_double_8x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,5> matrix_double_8x1_row5; } template <> struct geometric_traits<detail::matrix_double_8x1_row5> { typedef detail::matrix_double_8x1_row5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,6> matrix_double_8x1_row6; } template <> struct geometric_traits<detail::matrix_double_8x1_row6> { typedef detail::matrix_double_8x1_row6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x1,7> matrix_double_8x1_row7; } template <> struct geometric_traits<detail::matrix_double_8x1_row7> { typedef detail::matrix_double_8x1_row7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x1,0> matrix_double_8x1_column0; }template <> struct geometric_traits<detail::matrix_double_8x1_column0> { typedef detail::matrix_double_8x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x1>::type > : index_operator_matrix_access_policy < matrix_double_8x1 > { typedef index_operator_matrix_access_policy < matrix_double_8x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x1 > { typedef dimension<8> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 2> matrix_double_8x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,0> matrix_double_8x2_row0; } template <> struct geometric_traits<detail::matrix_double_8x2_row0> { typedef detail::matrix_double_8x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,1> matrix_double_8x2_row1; } template <> struct geometric_traits<detail::matrix_double_8x2_row1> { typedef detail::matrix_double_8x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,2> matrix_double_8x2_row2; } template <> struct geometric_traits<detail::matrix_double_8x2_row2> { typedef detail::matrix_double_8x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,3> matrix_double_8x2_row3; } template <> struct geometric_traits<detail::matrix_double_8x2_row3> { typedef detail::matrix_double_8x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,4> matrix_double_8x2_row4; } template <> struct geometric_traits<detail::matrix_double_8x2_row4> { typedef detail::matrix_double_8x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,5> matrix_double_8x2_row5; } template <> struct geometric_traits<detail::matrix_double_8x2_row5> { typedef detail::matrix_double_8x2_row5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,6> matrix_double_8x2_row6; } template <> struct geometric_traits<detail::matrix_double_8x2_row6> { typedef detail::matrix_double_8x2_row6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x2,7> matrix_double_8x2_row7; } template <> struct geometric_traits<detail::matrix_double_8x2_row7> { typedef detail::matrix_double_8x2_row7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x2,0> matrix_double_8x2_column0; }template <> struct geometric_traits<detail::matrix_double_8x2_column0> { typedef detail::matrix_double_8x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x2,1> matrix_double_8x2_column1; }template <> struct geometric_traits<detail::matrix_double_8x2_column1> { typedef detail::matrix_double_8x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x2>::type > : index_operator_matrix_access_policy < matrix_double_8x2 > { typedef index_operator_matrix_access_policy < matrix_double_8x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x2 > { typedef dimension<8> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 3> matrix_double_8x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,0> matrix_double_8x3_row0; } template <> struct geometric_traits<detail::matrix_double_8x3_row0> { typedef detail::matrix_double_8x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,1> matrix_double_8x3_row1; } template <> struct geometric_traits<detail::matrix_double_8x3_row1> { typedef detail::matrix_double_8x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,2> matrix_double_8x3_row2; } template <> struct geometric_traits<detail::matrix_double_8x3_row2> { typedef detail::matrix_double_8x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,3> matrix_double_8x3_row3; } template <> struct geometric_traits<detail::matrix_double_8x3_row3> { typedef detail::matrix_double_8x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,4> matrix_double_8x3_row4; } template <> struct geometric_traits<detail::matrix_double_8x3_row4> { typedef detail::matrix_double_8x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,5> matrix_double_8x3_row5; } template <> struct geometric_traits<detail::matrix_double_8x3_row5> { typedef detail::matrix_double_8x3_row5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,6> matrix_double_8x3_row6; } template <> struct geometric_traits<detail::matrix_double_8x3_row6> { typedef detail::matrix_double_8x3_row6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x3,7> matrix_double_8x3_row7; } template <> struct geometric_traits<detail::matrix_double_8x3_row7> { typedef detail::matrix_double_8x3_row7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x3,0> matrix_double_8x3_column0; }template <> struct geometric_traits<detail::matrix_double_8x3_column0> { typedef detail::matrix_double_8x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x3,1> matrix_double_8x3_column1; }template <> struct geometric_traits<detail::matrix_double_8x3_column1> { typedef detail::matrix_double_8x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x3,2> matrix_double_8x3_column2; }template <> struct geometric_traits<detail::matrix_double_8x3_column2> { typedef detail::matrix_double_8x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x3>::type > : index_operator_matrix_access_policy < matrix_double_8x3 > { typedef index_operator_matrix_access_policy < matrix_double_8x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x3 > { typedef dimension<8> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 4> matrix_double_8x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,0> matrix_double_8x4_row0; } template <> struct geometric_traits<detail::matrix_double_8x4_row0> { typedef detail::matrix_double_8x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,1> matrix_double_8x4_row1; } template <> struct geometric_traits<detail::matrix_double_8x4_row1> { typedef detail::matrix_double_8x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,2> matrix_double_8x4_row2; } template <> struct geometric_traits<detail::matrix_double_8x4_row2> { typedef detail::matrix_double_8x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,3> matrix_double_8x4_row3; } template <> struct geometric_traits<detail::matrix_double_8x4_row3> { typedef detail::matrix_double_8x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,4> matrix_double_8x4_row4; } template <> struct geometric_traits<detail::matrix_double_8x4_row4> { typedef detail::matrix_double_8x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,5> matrix_double_8x4_row5; } template <> struct geometric_traits<detail::matrix_double_8x4_row5> { typedef detail::matrix_double_8x4_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,6> matrix_double_8x4_row6; } template <> struct geometric_traits<detail::matrix_double_8x4_row6> { typedef detail::matrix_double_8x4_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x4,7> matrix_double_8x4_row7; } template <> struct geometric_traits<detail::matrix_double_8x4_row7> { typedef detail::matrix_double_8x4_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x4,0> matrix_double_8x4_column0; }template <> struct geometric_traits<detail::matrix_double_8x4_column0> { typedef detail::matrix_double_8x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x4,1> matrix_double_8x4_column1; }template <> struct geometric_traits<detail::matrix_double_8x4_column1> { typedef detail::matrix_double_8x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x4,2> matrix_double_8x4_column2; }template <> struct geometric_traits<detail::matrix_double_8x4_column2> { typedef detail::matrix_double_8x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x4,3> matrix_double_8x4_column3; }template <> struct geometric_traits<detail::matrix_double_8x4_column3> { typedef detail::matrix_double_8x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x4>::type > : index_operator_matrix_access_policy < matrix_double_8x4 > { typedef index_operator_matrix_access_policy < matrix_double_8x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x4 > { typedef dimension<8> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 5> matrix_double_8x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,0> matrix_double_8x5_row0; } template <> struct geometric_traits<detail::matrix_double_8x5_row0> { typedef detail::matrix_double_8x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,1> matrix_double_8x5_row1; } template <> struct geometric_traits<detail::matrix_double_8x5_row1> { typedef detail::matrix_double_8x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,2> matrix_double_8x5_row2; } template <> struct geometric_traits<detail::matrix_double_8x5_row2> { typedef detail::matrix_double_8x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,3> matrix_double_8x5_row3; } template <> struct geometric_traits<detail::matrix_double_8x5_row3> { typedef detail::matrix_double_8x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,4> matrix_double_8x5_row4; } template <> struct geometric_traits<detail::matrix_double_8x5_row4> { typedef detail::matrix_double_8x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,5> matrix_double_8x5_row5; } template <> struct geometric_traits<detail::matrix_double_8x5_row5> { typedef detail::matrix_double_8x5_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,6> matrix_double_8x5_row6; } template <> struct geometric_traits<detail::matrix_double_8x5_row6> { typedef detail::matrix_double_8x5_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x5,7> matrix_double_8x5_row7; } template <> struct geometric_traits<detail::matrix_double_8x5_row7> { typedef detail::matrix_double_8x5_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x5,0> matrix_double_8x5_column0; }template <> struct geometric_traits<detail::matrix_double_8x5_column0> { typedef detail::matrix_double_8x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x5,1> matrix_double_8x5_column1; }template <> struct geometric_traits<detail::matrix_double_8x5_column1> { typedef detail::matrix_double_8x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x5,2> matrix_double_8x5_column2; }template <> struct geometric_traits<detail::matrix_double_8x5_column2> { typedef detail::matrix_double_8x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x5,3> matrix_double_8x5_column3; }template <> struct geometric_traits<detail::matrix_double_8x5_column3> { typedef detail::matrix_double_8x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x5,4> matrix_double_8x5_column4; }template <> struct geometric_traits<detail::matrix_double_8x5_column4> { typedef detail::matrix_double_8x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x5>::type > : index_operator_matrix_access_policy < matrix_double_8x5 > { typedef index_operator_matrix_access_policy < matrix_double_8x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x5 > { typedef dimension<8> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 6> matrix_double_8x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,0> matrix_double_8x6_row0; } template <> struct geometric_traits<detail::matrix_double_8x6_row0> { typedef detail::matrix_double_8x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,1> matrix_double_8x6_row1; } template <> struct geometric_traits<detail::matrix_double_8x6_row1> { typedef detail::matrix_double_8x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,2> matrix_double_8x6_row2; } template <> struct geometric_traits<detail::matrix_double_8x6_row2> { typedef detail::matrix_double_8x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,3> matrix_double_8x6_row3; } template <> struct geometric_traits<detail::matrix_double_8x6_row3> { typedef detail::matrix_double_8x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,4> matrix_double_8x6_row4; } template <> struct geometric_traits<detail::matrix_double_8x6_row4> { typedef detail::matrix_double_8x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,5> matrix_double_8x6_row5; } template <> struct geometric_traits<detail::matrix_double_8x6_row5> { typedef detail::matrix_double_8x6_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,6> matrix_double_8x6_row6; } template <> struct geometric_traits<detail::matrix_double_8x6_row6> { typedef detail::matrix_double_8x6_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x6,7> matrix_double_8x6_row7; } template <> struct geometric_traits<detail::matrix_double_8x6_row7> { typedef detail::matrix_double_8x6_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,0> matrix_double_8x6_column0; }template <> struct geometric_traits<detail::matrix_double_8x6_column0> { typedef detail::matrix_double_8x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,1> matrix_double_8x6_column1; }template <> struct geometric_traits<detail::matrix_double_8x6_column1> { typedef detail::matrix_double_8x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,2> matrix_double_8x6_column2; }template <> struct geometric_traits<detail::matrix_double_8x6_column2> { typedef detail::matrix_double_8x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,3> matrix_double_8x6_column3; }template <> struct geometric_traits<detail::matrix_double_8x6_column3> { typedef detail::matrix_double_8x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,4> matrix_double_8x6_column4; }template <> struct geometric_traits<detail::matrix_double_8x6_column4> { typedef detail::matrix_double_8x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x6,5> matrix_double_8x6_column5; }template <> struct geometric_traits<detail::matrix_double_8x6_column5> { typedef detail::matrix_double_8x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x6>::type > : index_operator_matrix_access_policy < matrix_double_8x6 > { typedef index_operator_matrix_access_policy < matrix_double_8x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x6 > { typedef dimension<8> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 7> matrix_double_8x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,0> matrix_double_8x7_row0; } template <> struct geometric_traits<detail::matrix_double_8x7_row0> { typedef detail::matrix_double_8x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,1> matrix_double_8x7_row1; } template <> struct geometric_traits<detail::matrix_double_8x7_row1> { typedef detail::matrix_double_8x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,2> matrix_double_8x7_row2; } template <> struct geometric_traits<detail::matrix_double_8x7_row2> { typedef detail::matrix_double_8x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,3> matrix_double_8x7_row3; } template <> struct geometric_traits<detail::matrix_double_8x7_row3> { typedef detail::matrix_double_8x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,4> matrix_double_8x7_row4; } template <> struct geometric_traits<detail::matrix_double_8x7_row4> { typedef detail::matrix_double_8x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,5> matrix_double_8x7_row5; } template <> struct geometric_traits<detail::matrix_double_8x7_row5> { typedef detail::matrix_double_8x7_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,6> matrix_double_8x7_row6; } template <> struct geometric_traits<detail::matrix_double_8x7_row6> { typedef detail::matrix_double_8x7_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x7,7> matrix_double_8x7_row7; } template <> struct geometric_traits<detail::matrix_double_8x7_row7> { typedef detail::matrix_double_8x7_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,0> matrix_double_8x7_column0; }template <> struct geometric_traits<detail::matrix_double_8x7_column0> { typedef detail::matrix_double_8x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,1> matrix_double_8x7_column1; }template <> struct geometric_traits<detail::matrix_double_8x7_column1> { typedef detail::matrix_double_8x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,2> matrix_double_8x7_column2; }template <> struct geometric_traits<detail::matrix_double_8x7_column2> { typedef detail::matrix_double_8x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,3> matrix_double_8x7_column3; }template <> struct geometric_traits<detail::matrix_double_8x7_column3> { typedef detail::matrix_double_8x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,4> matrix_double_8x7_column4; }template <> struct geometric_traits<detail::matrix_double_8x7_column4> { typedef detail::matrix_double_8x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,5> matrix_double_8x7_column5; }template <> struct geometric_traits<detail::matrix_double_8x7_column5> { typedef detail::matrix_double_8x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x7,6> matrix_double_8x7_column6; }template <> struct geometric_traits<detail::matrix_double_8x7_column6> { typedef detail::matrix_double_8x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x7>::type > : index_operator_matrix_access_policy < matrix_double_8x7 > { typedef index_operator_matrix_access_policy < matrix_double_8x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x7 > { typedef dimension<8> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 8> matrix_double_8x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,0> matrix_double_8x8_row0; } template <> struct geometric_traits<detail::matrix_double_8x8_row0> { typedef detail::matrix_double_8x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,1> matrix_double_8x8_row1; } template <> struct geometric_traits<detail::matrix_double_8x8_row1> { typedef detail::matrix_double_8x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,2> matrix_double_8x8_row2; } template <> struct geometric_traits<detail::matrix_double_8x8_row2> { typedef detail::matrix_double_8x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,3> matrix_double_8x8_row3; } template <> struct geometric_traits<detail::matrix_double_8x8_row3> { typedef detail::matrix_double_8x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,4> matrix_double_8x8_row4; } template <> struct geometric_traits<detail::matrix_double_8x8_row4> { typedef detail::matrix_double_8x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,5> matrix_double_8x8_row5; } template <> struct geometric_traits<detail::matrix_double_8x8_row5> { typedef detail::matrix_double_8x8_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,6> matrix_double_8x8_row6; } template <> struct geometric_traits<detail::matrix_double_8x8_row6> { typedef detail::matrix_double_8x8_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x8,7> matrix_double_8x8_row7; } template <> struct geometric_traits<detail::matrix_double_8x8_row7> { typedef detail::matrix_double_8x8_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,0> matrix_double_8x8_column0; }template <> struct geometric_traits<detail::matrix_double_8x8_column0> { typedef detail::matrix_double_8x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,1> matrix_double_8x8_column1; }template <> struct geometric_traits<detail::matrix_double_8x8_column1> { typedef detail::matrix_double_8x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,2> matrix_double_8x8_column2; }template <> struct geometric_traits<detail::matrix_double_8x8_column2> { typedef detail::matrix_double_8x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,3> matrix_double_8x8_column3; }template <> struct geometric_traits<detail::matrix_double_8x8_column3> { typedef detail::matrix_double_8x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,4> matrix_double_8x8_column4; }template <> struct geometric_traits<detail::matrix_double_8x8_column4> { typedef detail::matrix_double_8x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,5> matrix_double_8x8_column5; }template <> struct geometric_traits<detail::matrix_double_8x8_column5> { typedef detail::matrix_double_8x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,6> matrix_double_8x8_column6; }template <> struct geometric_traits<detail::matrix_double_8x8_column6> { typedef detail::matrix_double_8x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x8,7> matrix_double_8x8_column7; }template <> struct geometric_traits<detail::matrix_double_8x8_column7> { typedef detail::matrix_double_8x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x8>::type > : index_operator_matrix_access_policy < matrix_double_8x8 > { typedef index_operator_matrix_access_policy < matrix_double_8x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x8 > { typedef dimension<8> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 9> matrix_double_8x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,0> matrix_double_8x9_row0; } template <> struct geometric_traits<detail::matrix_double_8x9_row0> { typedef detail::matrix_double_8x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,1> matrix_double_8x9_row1; } template <> struct geometric_traits<detail::matrix_double_8x9_row1> { typedef detail::matrix_double_8x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,2> matrix_double_8x9_row2; } template <> struct geometric_traits<detail::matrix_double_8x9_row2> { typedef detail::matrix_double_8x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,3> matrix_double_8x9_row3; } template <> struct geometric_traits<detail::matrix_double_8x9_row3> { typedef detail::matrix_double_8x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,4> matrix_double_8x9_row4; } template <> struct geometric_traits<detail::matrix_double_8x9_row4> { typedef detail::matrix_double_8x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,5> matrix_double_8x9_row5; } template <> struct geometric_traits<detail::matrix_double_8x9_row5> { typedef detail::matrix_double_8x9_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,6> matrix_double_8x9_row6; } template <> struct geometric_traits<detail::matrix_double_8x9_row6> { typedef detail::matrix_double_8x9_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x9,7> matrix_double_8x9_row7; } template <> struct geometric_traits<detail::matrix_double_8x9_row7> { typedef detail::matrix_double_8x9_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,0> matrix_double_8x9_column0; }template <> struct geometric_traits<detail::matrix_double_8x9_column0> { typedef detail::matrix_double_8x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,1> matrix_double_8x9_column1; }template <> struct geometric_traits<detail::matrix_double_8x9_column1> { typedef detail::matrix_double_8x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,2> matrix_double_8x9_column2; }template <> struct geometric_traits<detail::matrix_double_8x9_column2> { typedef detail::matrix_double_8x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,3> matrix_double_8x9_column3; }template <> struct geometric_traits<detail::matrix_double_8x9_column3> { typedef detail::matrix_double_8x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,4> matrix_double_8x9_column4; }template <> struct geometric_traits<detail::matrix_double_8x9_column4> { typedef detail::matrix_double_8x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,5> matrix_double_8x9_column5; }template <> struct geometric_traits<detail::matrix_double_8x9_column5> { typedef detail::matrix_double_8x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,6> matrix_double_8x9_column6; }template <> struct geometric_traits<detail::matrix_double_8x9_column6> { typedef detail::matrix_double_8x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,7> matrix_double_8x9_column7; }template <> struct geometric_traits<detail::matrix_double_8x9_column7> { typedef detail::matrix_double_8x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x9,8> matrix_double_8x9_column8; }template <> struct geometric_traits<detail::matrix_double_8x9_column8> { typedef detail::matrix_double_8x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x9>::type > : index_operator_matrix_access_policy < matrix_double_8x9 > { typedef index_operator_matrix_access_policy < matrix_double_8x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x9 > { typedef dimension<8> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 8, 10> matrix_double_8x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,0> matrix_double_8x10_row0; } template <> struct geometric_traits<detail::matrix_double_8x10_row0> { typedef detail::matrix_double_8x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,1> matrix_double_8x10_row1; } template <> struct geometric_traits<detail::matrix_double_8x10_row1> { typedef detail::matrix_double_8x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,2> matrix_double_8x10_row2; } template <> struct geometric_traits<detail::matrix_double_8x10_row2> { typedef detail::matrix_double_8x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,3> matrix_double_8x10_row3; } template <> struct geometric_traits<detail::matrix_double_8x10_row3> { typedef detail::matrix_double_8x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,4> matrix_double_8x10_row4; } template <> struct geometric_traits<detail::matrix_double_8x10_row4> { typedef detail::matrix_double_8x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,5> matrix_double_8x10_row5; } template <> struct geometric_traits<detail::matrix_double_8x10_row5> { typedef detail::matrix_double_8x10_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,6> matrix_double_8x10_row6; } template <> struct geometric_traits<detail::matrix_double_8x10_row6> { typedef detail::matrix_double_8x10_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_8x10,7> matrix_double_8x10_row7; } template <> struct geometric_traits<detail::matrix_double_8x10_row7> { typedef detail::matrix_double_8x10_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,0> matrix_double_8x10_column0; }template <> struct geometric_traits<detail::matrix_double_8x10_column0> { typedef detail::matrix_double_8x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,1> matrix_double_8x10_column1; }template <> struct geometric_traits<detail::matrix_double_8x10_column1> { typedef detail::matrix_double_8x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,2> matrix_double_8x10_column2; }template <> struct geometric_traits<detail::matrix_double_8x10_column2> { typedef detail::matrix_double_8x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,3> matrix_double_8x10_column3; }template <> struct geometric_traits<detail::matrix_double_8x10_column3> { typedef detail::matrix_double_8x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,4> matrix_double_8x10_column4; }template <> struct geometric_traits<detail::matrix_double_8x10_column4> { typedef detail::matrix_double_8x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,5> matrix_double_8x10_column5; }template <> struct geometric_traits<detail::matrix_double_8x10_column5> { typedef detail::matrix_double_8x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,6> matrix_double_8x10_column6; }template <> struct geometric_traits<detail::matrix_double_8x10_column6> { typedef detail::matrix_double_8x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,7> matrix_double_8x10_column7; }template <> struct geometric_traits<detail::matrix_double_8x10_column7> { typedef detail::matrix_double_8x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,8> matrix_double_8x10_column8; }template <> struct geometric_traits<detail::matrix_double_8x10_column8> { typedef detail::matrix_double_8x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_8x10,9> matrix_double_8x10_column9; }template <> struct geometric_traits<detail::matrix_double_8x10_column9> { typedef detail::matrix_double_8x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_8x10>::type > : index_operator_matrix_access_policy < matrix_double_8x10 > { typedef index_operator_matrix_access_policy < matrix_double_8x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_8x10 > { typedef dimension<8> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 1> matrix_double_9x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,0> matrix_double_9x1_row0; } template <> struct geometric_traits<detail::matrix_double_9x1_row0> { typedef detail::matrix_double_9x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,1> matrix_double_9x1_row1; } template <> struct geometric_traits<detail::matrix_double_9x1_row1> { typedef detail::matrix_double_9x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,2> matrix_double_9x1_row2; } template <> struct geometric_traits<detail::matrix_double_9x1_row2> { typedef detail::matrix_double_9x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,3> matrix_double_9x1_row3; } template <> struct geometric_traits<detail::matrix_double_9x1_row3> { typedef detail::matrix_double_9x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,4> matrix_double_9x1_row4; } template <> struct geometric_traits<detail::matrix_double_9x1_row4> { typedef detail::matrix_double_9x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,5> matrix_double_9x1_row5; } template <> struct geometric_traits<detail::matrix_double_9x1_row5> { typedef detail::matrix_double_9x1_row5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,6> matrix_double_9x1_row6; } template <> struct geometric_traits<detail::matrix_double_9x1_row6> { typedef detail::matrix_double_9x1_row6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,7> matrix_double_9x1_row7; } template <> struct geometric_traits<detail::matrix_double_9x1_row7> { typedef detail::matrix_double_9x1_row7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x1,8> matrix_double_9x1_row8; } template <> struct geometric_traits<detail::matrix_double_9x1_row8> { typedef detail::matrix_double_9x1_row8 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x1,0> matrix_double_9x1_column0; }template <> struct geometric_traits<detail::matrix_double_9x1_column0> { typedef detail::matrix_double_9x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x1>::type > : index_operator_matrix_access_policy < matrix_double_9x1 > { typedef index_operator_matrix_access_policy < matrix_double_9x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x1 > { typedef dimension<9> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 2> matrix_double_9x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,0> matrix_double_9x2_row0; } template <> struct geometric_traits<detail::matrix_double_9x2_row0> { typedef detail::matrix_double_9x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,1> matrix_double_9x2_row1; } template <> struct geometric_traits<detail::matrix_double_9x2_row1> { typedef detail::matrix_double_9x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,2> matrix_double_9x2_row2; } template <> struct geometric_traits<detail::matrix_double_9x2_row2> { typedef detail::matrix_double_9x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,3> matrix_double_9x2_row3; } template <> struct geometric_traits<detail::matrix_double_9x2_row3> { typedef detail::matrix_double_9x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,4> matrix_double_9x2_row4; } template <> struct geometric_traits<detail::matrix_double_9x2_row4> { typedef detail::matrix_double_9x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,5> matrix_double_9x2_row5; } template <> struct geometric_traits<detail::matrix_double_9x2_row5> { typedef detail::matrix_double_9x2_row5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,6> matrix_double_9x2_row6; } template <> struct geometric_traits<detail::matrix_double_9x2_row6> { typedef detail::matrix_double_9x2_row6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,7> matrix_double_9x2_row7; } template <> struct geometric_traits<detail::matrix_double_9x2_row7> { typedef detail::matrix_double_9x2_row7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x2,8> matrix_double_9x2_row8; } template <> struct geometric_traits<detail::matrix_double_9x2_row8> { typedef detail::matrix_double_9x2_row8 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x2,0> matrix_double_9x2_column0; }template <> struct geometric_traits<detail::matrix_double_9x2_column0> { typedef detail::matrix_double_9x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x2,1> matrix_double_9x2_column1; }template <> struct geometric_traits<detail::matrix_double_9x2_column1> { typedef detail::matrix_double_9x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x2>::type > : index_operator_matrix_access_policy < matrix_double_9x2 > { typedef index_operator_matrix_access_policy < matrix_double_9x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x2 > { typedef dimension<9> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 3> matrix_double_9x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,0> matrix_double_9x3_row0; } template <> struct geometric_traits<detail::matrix_double_9x3_row0> { typedef detail::matrix_double_9x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,1> matrix_double_9x3_row1; } template <> struct geometric_traits<detail::matrix_double_9x3_row1> { typedef detail::matrix_double_9x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,2> matrix_double_9x3_row2; } template <> struct geometric_traits<detail::matrix_double_9x3_row2> { typedef detail::matrix_double_9x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,3> matrix_double_9x3_row3; } template <> struct geometric_traits<detail::matrix_double_9x3_row3> { typedef detail::matrix_double_9x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,4> matrix_double_9x3_row4; } template <> struct geometric_traits<detail::matrix_double_9x3_row4> { typedef detail::matrix_double_9x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,5> matrix_double_9x3_row5; } template <> struct geometric_traits<detail::matrix_double_9x3_row5> { typedef detail::matrix_double_9x3_row5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,6> matrix_double_9x3_row6; } template <> struct geometric_traits<detail::matrix_double_9x3_row6> { typedef detail::matrix_double_9x3_row6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,7> matrix_double_9x3_row7; } template <> struct geometric_traits<detail::matrix_double_9x3_row7> { typedef detail::matrix_double_9x3_row7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x3,8> matrix_double_9x3_row8; } template <> struct geometric_traits<detail::matrix_double_9x3_row8> { typedef detail::matrix_double_9x3_row8 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x3,0> matrix_double_9x3_column0; }template <> struct geometric_traits<detail::matrix_double_9x3_column0> { typedef detail::matrix_double_9x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x3,1> matrix_double_9x3_column1; }template <> struct geometric_traits<detail::matrix_double_9x3_column1> { typedef detail::matrix_double_9x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x3,2> matrix_double_9x3_column2; }template <> struct geometric_traits<detail::matrix_double_9x3_column2> { typedef detail::matrix_double_9x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x3>::type > : index_operator_matrix_access_policy < matrix_double_9x3 > { typedef index_operator_matrix_access_policy < matrix_double_9x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x3 > { typedef dimension<9> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 4> matrix_double_9x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,0> matrix_double_9x4_row0; } template <> struct geometric_traits<detail::matrix_double_9x4_row0> { typedef detail::matrix_double_9x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,1> matrix_double_9x4_row1; } template <> struct geometric_traits<detail::matrix_double_9x4_row1> { typedef detail::matrix_double_9x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,2> matrix_double_9x4_row2; } template <> struct geometric_traits<detail::matrix_double_9x4_row2> { typedef detail::matrix_double_9x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,3> matrix_double_9x4_row3; } template <> struct geometric_traits<detail::matrix_double_9x4_row3> { typedef detail::matrix_double_9x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,4> matrix_double_9x4_row4; } template <> struct geometric_traits<detail::matrix_double_9x4_row4> { typedef detail::matrix_double_9x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,5> matrix_double_9x4_row5; } template <> struct geometric_traits<detail::matrix_double_9x4_row5> { typedef detail::matrix_double_9x4_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,6> matrix_double_9x4_row6; } template <> struct geometric_traits<detail::matrix_double_9x4_row6> { typedef detail::matrix_double_9x4_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,7> matrix_double_9x4_row7; } template <> struct geometric_traits<detail::matrix_double_9x4_row7> { typedef detail::matrix_double_9x4_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x4,8> matrix_double_9x4_row8; } template <> struct geometric_traits<detail::matrix_double_9x4_row8> { typedef detail::matrix_double_9x4_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x4,0> matrix_double_9x4_column0; }template <> struct geometric_traits<detail::matrix_double_9x4_column0> { typedef detail::matrix_double_9x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x4,1> matrix_double_9x4_column1; }template <> struct geometric_traits<detail::matrix_double_9x4_column1> { typedef detail::matrix_double_9x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x4,2> matrix_double_9x4_column2; }template <> struct geometric_traits<detail::matrix_double_9x4_column2> { typedef detail::matrix_double_9x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x4,3> matrix_double_9x4_column3; }template <> struct geometric_traits<detail::matrix_double_9x4_column3> { typedef detail::matrix_double_9x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x4>::type > : index_operator_matrix_access_policy < matrix_double_9x4 > { typedef index_operator_matrix_access_policy < matrix_double_9x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x4 > { typedef dimension<9> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 5> matrix_double_9x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,0> matrix_double_9x5_row0; } template <> struct geometric_traits<detail::matrix_double_9x5_row0> { typedef detail::matrix_double_9x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,1> matrix_double_9x5_row1; } template <> struct geometric_traits<detail::matrix_double_9x5_row1> { typedef detail::matrix_double_9x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,2> matrix_double_9x5_row2; } template <> struct geometric_traits<detail::matrix_double_9x5_row2> { typedef detail::matrix_double_9x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,3> matrix_double_9x5_row3; } template <> struct geometric_traits<detail::matrix_double_9x5_row3> { typedef detail::matrix_double_9x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,4> matrix_double_9x5_row4; } template <> struct geometric_traits<detail::matrix_double_9x5_row4> { typedef detail::matrix_double_9x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,5> matrix_double_9x5_row5; } template <> struct geometric_traits<detail::matrix_double_9x5_row5> { typedef detail::matrix_double_9x5_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,6> matrix_double_9x5_row6; } template <> struct geometric_traits<detail::matrix_double_9x5_row6> { typedef detail::matrix_double_9x5_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,7> matrix_double_9x5_row7; } template <> struct geometric_traits<detail::matrix_double_9x5_row7> { typedef detail::matrix_double_9x5_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x5,8> matrix_double_9x5_row8; } template <> struct geometric_traits<detail::matrix_double_9x5_row8> { typedef detail::matrix_double_9x5_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x5,0> matrix_double_9x5_column0; }template <> struct geometric_traits<detail::matrix_double_9x5_column0> { typedef detail::matrix_double_9x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x5,1> matrix_double_9x5_column1; }template <> struct geometric_traits<detail::matrix_double_9x5_column1> { typedef detail::matrix_double_9x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x5,2> matrix_double_9x5_column2; }template <> struct geometric_traits<detail::matrix_double_9x5_column2> { typedef detail::matrix_double_9x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x5,3> matrix_double_9x5_column3; }template <> struct geometric_traits<detail::matrix_double_9x5_column3> { typedef detail::matrix_double_9x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x5,4> matrix_double_9x5_column4; }template <> struct geometric_traits<detail::matrix_double_9x5_column4> { typedef detail::matrix_double_9x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x5>::type > : index_operator_matrix_access_policy < matrix_double_9x5 > { typedef index_operator_matrix_access_policy < matrix_double_9x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x5 > { typedef dimension<9> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 6> matrix_double_9x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,0> matrix_double_9x6_row0; } template <> struct geometric_traits<detail::matrix_double_9x6_row0> { typedef detail::matrix_double_9x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,1> matrix_double_9x6_row1; } template <> struct geometric_traits<detail::matrix_double_9x6_row1> { typedef detail::matrix_double_9x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,2> matrix_double_9x6_row2; } template <> struct geometric_traits<detail::matrix_double_9x6_row2> { typedef detail::matrix_double_9x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,3> matrix_double_9x6_row3; } template <> struct geometric_traits<detail::matrix_double_9x6_row3> { typedef detail::matrix_double_9x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,4> matrix_double_9x6_row4; } template <> struct geometric_traits<detail::matrix_double_9x6_row4> { typedef detail::matrix_double_9x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,5> matrix_double_9x6_row5; } template <> struct geometric_traits<detail::matrix_double_9x6_row5> { typedef detail::matrix_double_9x6_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,6> matrix_double_9x6_row6; } template <> struct geometric_traits<detail::matrix_double_9x6_row6> { typedef detail::matrix_double_9x6_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,7> matrix_double_9x6_row7; } template <> struct geometric_traits<detail::matrix_double_9x6_row7> { typedef detail::matrix_double_9x6_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x6,8> matrix_double_9x6_row8; } template <> struct geometric_traits<detail::matrix_double_9x6_row8> { typedef detail::matrix_double_9x6_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,0> matrix_double_9x6_column0; }template <> struct geometric_traits<detail::matrix_double_9x6_column0> { typedef detail::matrix_double_9x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,1> matrix_double_9x6_column1; }template <> struct geometric_traits<detail::matrix_double_9x6_column1> { typedef detail::matrix_double_9x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,2> matrix_double_9x6_column2; }template <> struct geometric_traits<detail::matrix_double_9x6_column2> { typedef detail::matrix_double_9x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,3> matrix_double_9x6_column3; }template <> struct geometric_traits<detail::matrix_double_9x6_column3> { typedef detail::matrix_double_9x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,4> matrix_double_9x6_column4; }template <> struct geometric_traits<detail::matrix_double_9x6_column4> { typedef detail::matrix_double_9x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x6,5> matrix_double_9x6_column5; }template <> struct geometric_traits<detail::matrix_double_9x6_column5> { typedef detail::matrix_double_9x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x6>::type > : index_operator_matrix_access_policy < matrix_double_9x6 > { typedef index_operator_matrix_access_policy < matrix_double_9x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x6 > { typedef dimension<9> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 7> matrix_double_9x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,0> matrix_double_9x7_row0; } template <> struct geometric_traits<detail::matrix_double_9x7_row0> { typedef detail::matrix_double_9x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,1> matrix_double_9x7_row1; } template <> struct geometric_traits<detail::matrix_double_9x7_row1> { typedef detail::matrix_double_9x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,2> matrix_double_9x7_row2; } template <> struct geometric_traits<detail::matrix_double_9x7_row2> { typedef detail::matrix_double_9x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,3> matrix_double_9x7_row3; } template <> struct geometric_traits<detail::matrix_double_9x7_row3> { typedef detail::matrix_double_9x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,4> matrix_double_9x7_row4; } template <> struct geometric_traits<detail::matrix_double_9x7_row4> { typedef detail::matrix_double_9x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,5> matrix_double_9x7_row5; } template <> struct geometric_traits<detail::matrix_double_9x7_row5> { typedef detail::matrix_double_9x7_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,6> matrix_double_9x7_row6; } template <> struct geometric_traits<detail::matrix_double_9x7_row6> { typedef detail::matrix_double_9x7_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,7> matrix_double_9x7_row7; } template <> struct geometric_traits<detail::matrix_double_9x7_row7> { typedef detail::matrix_double_9x7_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x7,8> matrix_double_9x7_row8; } template <> struct geometric_traits<detail::matrix_double_9x7_row8> { typedef detail::matrix_double_9x7_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,0> matrix_double_9x7_column0; }template <> struct geometric_traits<detail::matrix_double_9x7_column0> { typedef detail::matrix_double_9x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,1> matrix_double_9x7_column1; }template <> struct geometric_traits<detail::matrix_double_9x7_column1> { typedef detail::matrix_double_9x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,2> matrix_double_9x7_column2; }template <> struct geometric_traits<detail::matrix_double_9x7_column2> { typedef detail::matrix_double_9x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,3> matrix_double_9x7_column3; }template <> struct geometric_traits<detail::matrix_double_9x7_column3> { typedef detail::matrix_double_9x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,4> matrix_double_9x7_column4; }template <> struct geometric_traits<detail::matrix_double_9x7_column4> { typedef detail::matrix_double_9x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,5> matrix_double_9x7_column5; }template <> struct geometric_traits<detail::matrix_double_9x7_column5> { typedef detail::matrix_double_9x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x7,6> matrix_double_9x7_column6; }template <> struct geometric_traits<detail::matrix_double_9x7_column6> { typedef detail::matrix_double_9x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x7>::type > : index_operator_matrix_access_policy < matrix_double_9x7 > { typedef index_operator_matrix_access_policy < matrix_double_9x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x7 > { typedef dimension<9> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 8> matrix_double_9x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,0> matrix_double_9x8_row0; } template <> struct geometric_traits<detail::matrix_double_9x8_row0> { typedef detail::matrix_double_9x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,1> matrix_double_9x8_row1; } template <> struct geometric_traits<detail::matrix_double_9x8_row1> { typedef detail::matrix_double_9x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,2> matrix_double_9x8_row2; } template <> struct geometric_traits<detail::matrix_double_9x8_row2> { typedef detail::matrix_double_9x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,3> matrix_double_9x8_row3; } template <> struct geometric_traits<detail::matrix_double_9x8_row3> { typedef detail::matrix_double_9x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,4> matrix_double_9x8_row4; } template <> struct geometric_traits<detail::matrix_double_9x8_row4> { typedef detail::matrix_double_9x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,5> matrix_double_9x8_row5; } template <> struct geometric_traits<detail::matrix_double_9x8_row5> { typedef detail::matrix_double_9x8_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,6> matrix_double_9x8_row6; } template <> struct geometric_traits<detail::matrix_double_9x8_row6> { typedef detail::matrix_double_9x8_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,7> matrix_double_9x8_row7; } template <> struct geometric_traits<detail::matrix_double_9x8_row7> { typedef detail::matrix_double_9x8_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x8,8> matrix_double_9x8_row8; } template <> struct geometric_traits<detail::matrix_double_9x8_row8> { typedef detail::matrix_double_9x8_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,0> matrix_double_9x8_column0; }template <> struct geometric_traits<detail::matrix_double_9x8_column0> { typedef detail::matrix_double_9x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,1> matrix_double_9x8_column1; }template <> struct geometric_traits<detail::matrix_double_9x8_column1> { typedef detail::matrix_double_9x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,2> matrix_double_9x8_column2; }template <> struct geometric_traits<detail::matrix_double_9x8_column2> { typedef detail::matrix_double_9x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,3> matrix_double_9x8_column3; }template <> struct geometric_traits<detail::matrix_double_9x8_column3> { typedef detail::matrix_double_9x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,4> matrix_double_9x8_column4; }template <> struct geometric_traits<detail::matrix_double_9x8_column4> { typedef detail::matrix_double_9x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,5> matrix_double_9x8_column5; }template <> struct geometric_traits<detail::matrix_double_9x8_column5> { typedef detail::matrix_double_9x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,6> matrix_double_9x8_column6; }template <> struct geometric_traits<detail::matrix_double_9x8_column6> { typedef detail::matrix_double_9x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x8,7> matrix_double_9x8_column7; }template <> struct geometric_traits<detail::matrix_double_9x8_column7> { typedef detail::matrix_double_9x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x8>::type > : index_operator_matrix_access_policy < matrix_double_9x8 > { typedef index_operator_matrix_access_policy < matrix_double_9x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x8 > { typedef dimension<9> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 9> matrix_double_9x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,0> matrix_double_9x9_row0; } template <> struct geometric_traits<detail::matrix_double_9x9_row0> { typedef detail::matrix_double_9x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,1> matrix_double_9x9_row1; } template <> struct geometric_traits<detail::matrix_double_9x9_row1> { typedef detail::matrix_double_9x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,2> matrix_double_9x9_row2; } template <> struct geometric_traits<detail::matrix_double_9x9_row2> { typedef detail::matrix_double_9x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,3> matrix_double_9x9_row3; } template <> struct geometric_traits<detail::matrix_double_9x9_row3> { typedef detail::matrix_double_9x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,4> matrix_double_9x9_row4; } template <> struct geometric_traits<detail::matrix_double_9x9_row4> { typedef detail::matrix_double_9x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,5> matrix_double_9x9_row5; } template <> struct geometric_traits<detail::matrix_double_9x9_row5> { typedef detail::matrix_double_9x9_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,6> matrix_double_9x9_row6; } template <> struct geometric_traits<detail::matrix_double_9x9_row6> { typedef detail::matrix_double_9x9_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,7> matrix_double_9x9_row7; } template <> struct geometric_traits<detail::matrix_double_9x9_row7> { typedef detail::matrix_double_9x9_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x9,8> matrix_double_9x9_row8; } template <> struct geometric_traits<detail::matrix_double_9x9_row8> { typedef detail::matrix_double_9x9_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,0> matrix_double_9x9_column0; }template <> struct geometric_traits<detail::matrix_double_9x9_column0> { typedef detail::matrix_double_9x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,1> matrix_double_9x9_column1; }template <> struct geometric_traits<detail::matrix_double_9x9_column1> { typedef detail::matrix_double_9x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,2> matrix_double_9x9_column2; }template <> struct geometric_traits<detail::matrix_double_9x9_column2> { typedef detail::matrix_double_9x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,3> matrix_double_9x9_column3; }template <> struct geometric_traits<detail::matrix_double_9x9_column3> { typedef detail::matrix_double_9x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,4> matrix_double_9x9_column4; }template <> struct geometric_traits<detail::matrix_double_9x9_column4> { typedef detail::matrix_double_9x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,5> matrix_double_9x9_column5; }template <> struct geometric_traits<detail::matrix_double_9x9_column5> { typedef detail::matrix_double_9x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,6> matrix_double_9x9_column6; }template <> struct geometric_traits<detail::matrix_double_9x9_column6> { typedef detail::matrix_double_9x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,7> matrix_double_9x9_column7; }template <> struct geometric_traits<detail::matrix_double_9x9_column7> { typedef detail::matrix_double_9x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x9,8> matrix_double_9x9_column8; }template <> struct geometric_traits<detail::matrix_double_9x9_column8> { typedef detail::matrix_double_9x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x9>::type > : index_operator_matrix_access_policy < matrix_double_9x9 > { typedef index_operator_matrix_access_policy < matrix_double_9x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x9 > { typedef dimension<9> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 9, 10> matrix_double_9x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,0> matrix_double_9x10_row0; } template <> struct geometric_traits<detail::matrix_double_9x10_row0> { typedef detail::matrix_double_9x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,1> matrix_double_9x10_row1; } template <> struct geometric_traits<detail::matrix_double_9x10_row1> { typedef detail::matrix_double_9x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,2> matrix_double_9x10_row2; } template <> struct geometric_traits<detail::matrix_double_9x10_row2> { typedef detail::matrix_double_9x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,3> matrix_double_9x10_row3; } template <> struct geometric_traits<detail::matrix_double_9x10_row3> { typedef detail::matrix_double_9x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,4> matrix_double_9x10_row4; } template <> struct geometric_traits<detail::matrix_double_9x10_row4> { typedef detail::matrix_double_9x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,5> matrix_double_9x10_row5; } template <> struct geometric_traits<detail::matrix_double_9x10_row5> { typedef detail::matrix_double_9x10_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,6> matrix_double_9x10_row6; } template <> struct geometric_traits<detail::matrix_double_9x10_row6> { typedef detail::matrix_double_9x10_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,7> matrix_double_9x10_row7; } template <> struct geometric_traits<detail::matrix_double_9x10_row7> { typedef detail::matrix_double_9x10_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_9x10,8> matrix_double_9x10_row8; } template <> struct geometric_traits<detail::matrix_double_9x10_row8> { typedef detail::matrix_double_9x10_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,0> matrix_double_9x10_column0; }template <> struct geometric_traits<detail::matrix_double_9x10_column0> { typedef detail::matrix_double_9x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,1> matrix_double_9x10_column1; }template <> struct geometric_traits<detail::matrix_double_9x10_column1> { typedef detail::matrix_double_9x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,2> matrix_double_9x10_column2; }template <> struct geometric_traits<detail::matrix_double_9x10_column2> { typedef detail::matrix_double_9x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,3> matrix_double_9x10_column3; }template <> struct geometric_traits<detail::matrix_double_9x10_column3> { typedef detail::matrix_double_9x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,4> matrix_double_9x10_column4; }template <> struct geometric_traits<detail::matrix_double_9x10_column4> { typedef detail::matrix_double_9x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,5> matrix_double_9x10_column5; }template <> struct geometric_traits<detail::matrix_double_9x10_column5> { typedef detail::matrix_double_9x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,6> matrix_double_9x10_column6; }template <> struct geometric_traits<detail::matrix_double_9x10_column6> { typedef detail::matrix_double_9x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,7> matrix_double_9x10_column7; }template <> struct geometric_traits<detail::matrix_double_9x10_column7> { typedef detail::matrix_double_9x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,8> matrix_double_9x10_column8; }template <> struct geometric_traits<detail::matrix_double_9x10_column8> { typedef detail::matrix_double_9x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_9x10,9> matrix_double_9x10_column9; }template <> struct geometric_traits<detail::matrix_double_9x10_column9> { typedef detail::matrix_double_9x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_9x10>::type > : index_operator_matrix_access_policy < matrix_double_9x10 > { typedef index_operator_matrix_access_policy < matrix_double_9x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_9x10 > { typedef dimension<9> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 1> matrix_double_10x1; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,0> matrix_double_10x1_row0; } template <> struct geometric_traits<detail::matrix_double_10x1_row0> { typedef detail::matrix_double_10x1_row0 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,1> matrix_double_10x1_row1; } template <> struct geometric_traits<detail::matrix_double_10x1_row1> { typedef detail::matrix_double_10x1_row1 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,2> matrix_double_10x1_row2; } template <> struct geometric_traits<detail::matrix_double_10x1_row2> { typedef detail::matrix_double_10x1_row2 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,3> matrix_double_10x1_row3; } template <> struct geometric_traits<detail::matrix_double_10x1_row3> { typedef detail::matrix_double_10x1_row3 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,4> matrix_double_10x1_row4; } template <> struct geometric_traits<detail::matrix_double_10x1_row4> { typedef detail::matrix_double_10x1_row4 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,5> matrix_double_10x1_row5; } template <> struct geometric_traits<detail::matrix_double_10x1_row5> { typedef detail::matrix_double_10x1_row5 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,6> matrix_double_10x1_row6; } template <> struct geometric_traits<detail::matrix_double_10x1_row6> { typedef detail::matrix_double_10x1_row6 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,7> matrix_double_10x1_row7; } template <> struct geometric_traits<detail::matrix_double_10x1_row7> { typedef detail::matrix_double_10x1_row7 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,8> matrix_double_10x1_row8; } template <> struct geometric_traits<detail::matrix_double_10x1_row8> { typedef detail::matrix_double_10x1_row8 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x1,9> matrix_double_10x1_row9; } template <> struct geometric_traits<detail::matrix_double_10x1_row9> { typedef detail::matrix_double_10x1_row9 sequence_type; typedef boost::mpl::vector<double> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x1,0> matrix_double_10x1_column0; }template <> struct geometric_traits<detail::matrix_double_10x1_column0> { typedef detail::matrix_double_10x1_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x1>::type > : index_operator_matrix_access_policy < matrix_double_10x1 > { typedef index_operator_matrix_access_policy < matrix_double_10x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x1 > { typedef dimension<10> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 2> matrix_double_10x2; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,0> matrix_double_10x2_row0; } template <> struct geometric_traits<detail::matrix_double_10x2_row0> { typedef detail::matrix_double_10x2_row0 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,1> matrix_double_10x2_row1; } template <> struct geometric_traits<detail::matrix_double_10x2_row1> { typedef detail::matrix_double_10x2_row1 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,2> matrix_double_10x2_row2; } template <> struct geometric_traits<detail::matrix_double_10x2_row2> { typedef detail::matrix_double_10x2_row2 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,3> matrix_double_10x2_row3; } template <> struct geometric_traits<detail::matrix_double_10x2_row3> { typedef detail::matrix_double_10x2_row3 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,4> matrix_double_10x2_row4; } template <> struct geometric_traits<detail::matrix_double_10x2_row4> { typedef detail::matrix_double_10x2_row4 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,5> matrix_double_10x2_row5; } template <> struct geometric_traits<detail::matrix_double_10x2_row5> { typedef detail::matrix_double_10x2_row5 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,6> matrix_double_10x2_row6; } template <> struct geometric_traits<detail::matrix_double_10x2_row6> { typedef detail::matrix_double_10x2_row6 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,7> matrix_double_10x2_row7; } template <> struct geometric_traits<detail::matrix_double_10x2_row7> { typedef detail::matrix_double_10x2_row7 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,8> matrix_double_10x2_row8; } template <> struct geometric_traits<detail::matrix_double_10x2_row8> { typedef detail::matrix_double_10x2_row8 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x2,9> matrix_double_10x2_row9; } template <> struct geometric_traits<detail::matrix_double_10x2_row9> { typedef detail::matrix_double_10x2_row9 sequence_type; typedef boost::mpl::vector<double, double> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x2,0> matrix_double_10x2_column0; }template <> struct geometric_traits<detail::matrix_double_10x2_column0> { typedef detail::matrix_double_10x2_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x2,1> matrix_double_10x2_column1; }template <> struct geometric_traits<detail::matrix_double_10x2_column1> { typedef detail::matrix_double_10x2_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x2>::type > : index_operator_matrix_access_policy < matrix_double_10x2 > { typedef index_operator_matrix_access_policy < matrix_double_10x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x2 > { typedef dimension<10> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 3> matrix_double_10x3; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,0> matrix_double_10x3_row0; } template <> struct geometric_traits<detail::matrix_double_10x3_row0> { typedef detail::matrix_double_10x3_row0 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,1> matrix_double_10x3_row1; } template <> struct geometric_traits<detail::matrix_double_10x3_row1> { typedef detail::matrix_double_10x3_row1 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,2> matrix_double_10x3_row2; } template <> struct geometric_traits<detail::matrix_double_10x3_row2> { typedef detail::matrix_double_10x3_row2 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,3> matrix_double_10x3_row3; } template <> struct geometric_traits<detail::matrix_double_10x3_row3> { typedef detail::matrix_double_10x3_row3 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,4> matrix_double_10x3_row4; } template <> struct geometric_traits<detail::matrix_double_10x3_row4> { typedef detail::matrix_double_10x3_row4 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,5> matrix_double_10x3_row5; } template <> struct geometric_traits<detail::matrix_double_10x3_row5> { typedef detail::matrix_double_10x3_row5 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,6> matrix_double_10x3_row6; } template <> struct geometric_traits<detail::matrix_double_10x3_row6> { typedef detail::matrix_double_10x3_row6 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,7> matrix_double_10x3_row7; } template <> struct geometric_traits<detail::matrix_double_10x3_row7> { typedef detail::matrix_double_10x3_row7 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,8> matrix_double_10x3_row8; } template <> struct geometric_traits<detail::matrix_double_10x3_row8> { typedef detail::matrix_double_10x3_row8 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x3,9> matrix_double_10x3_row9; } template <> struct geometric_traits<detail::matrix_double_10x3_row9> { typedef detail::matrix_double_10x3_row9 sequence_type; typedef boost::mpl::vector<double, double, double> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x3,0> matrix_double_10x3_column0; }template <> struct geometric_traits<detail::matrix_double_10x3_column0> { typedef detail::matrix_double_10x3_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x3,1> matrix_double_10x3_column1; }template <> struct geometric_traits<detail::matrix_double_10x3_column1> { typedef detail::matrix_double_10x3_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x3,2> matrix_double_10x3_column2; }template <> struct geometric_traits<detail::matrix_double_10x3_column2> { typedef detail::matrix_double_10x3_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x3>::type > : index_operator_matrix_access_policy < matrix_double_10x3 > { typedef index_operator_matrix_access_policy < matrix_double_10x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x3 > { typedef dimension<10> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 4> matrix_double_10x4; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,0> matrix_double_10x4_row0; } template <> struct geometric_traits<detail::matrix_double_10x4_row0> { typedef detail::matrix_double_10x4_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,1> matrix_double_10x4_row1; } template <> struct geometric_traits<detail::matrix_double_10x4_row1> { typedef detail::matrix_double_10x4_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,2> matrix_double_10x4_row2; } template <> struct geometric_traits<detail::matrix_double_10x4_row2> { typedef detail::matrix_double_10x4_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,3> matrix_double_10x4_row3; } template <> struct geometric_traits<detail::matrix_double_10x4_row3> { typedef detail::matrix_double_10x4_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,4> matrix_double_10x4_row4; } template <> struct geometric_traits<detail::matrix_double_10x4_row4> { typedef detail::matrix_double_10x4_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,5> matrix_double_10x4_row5; } template <> struct geometric_traits<detail::matrix_double_10x4_row5> { typedef detail::matrix_double_10x4_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,6> matrix_double_10x4_row6; } template <> struct geometric_traits<detail::matrix_double_10x4_row6> { typedef detail::matrix_double_10x4_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,7> matrix_double_10x4_row7; } template <> struct geometric_traits<detail::matrix_double_10x4_row7> { typedef detail::matrix_double_10x4_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,8> matrix_double_10x4_row8; } template <> struct geometric_traits<detail::matrix_double_10x4_row8> { typedef detail::matrix_double_10x4_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x4,9> matrix_double_10x4_row9; } template <> struct geometric_traits<detail::matrix_double_10x4_row9> { typedef detail::matrix_double_10x4_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x4,0> matrix_double_10x4_column0; }template <> struct geometric_traits<detail::matrix_double_10x4_column0> { typedef detail::matrix_double_10x4_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x4,1> matrix_double_10x4_column1; }template <> struct geometric_traits<detail::matrix_double_10x4_column1> { typedef detail::matrix_double_10x4_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x4,2> matrix_double_10x4_column2; }template <> struct geometric_traits<detail::matrix_double_10x4_column2> { typedef detail::matrix_double_10x4_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x4,3> matrix_double_10x4_column3; }template <> struct geometric_traits<detail::matrix_double_10x4_column3> { typedef detail::matrix_double_10x4_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x4>::type > : index_operator_matrix_access_policy < matrix_double_10x4 > { typedef index_operator_matrix_access_policy < matrix_double_10x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x4 > { typedef dimension<10> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 5> matrix_double_10x5; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,0> matrix_double_10x5_row0; } template <> struct geometric_traits<detail::matrix_double_10x5_row0> { typedef detail::matrix_double_10x5_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,1> matrix_double_10x5_row1; } template <> struct geometric_traits<detail::matrix_double_10x5_row1> { typedef detail::matrix_double_10x5_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,2> matrix_double_10x5_row2; } template <> struct geometric_traits<detail::matrix_double_10x5_row2> { typedef detail::matrix_double_10x5_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,3> matrix_double_10x5_row3; } template <> struct geometric_traits<detail::matrix_double_10x5_row3> { typedef detail::matrix_double_10x5_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,4> matrix_double_10x5_row4; } template <> struct geometric_traits<detail::matrix_double_10x5_row4> { typedef detail::matrix_double_10x5_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,5> matrix_double_10x5_row5; } template <> struct geometric_traits<detail::matrix_double_10x5_row5> { typedef detail::matrix_double_10x5_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,6> matrix_double_10x5_row6; } template <> struct geometric_traits<detail::matrix_double_10x5_row6> { typedef detail::matrix_double_10x5_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,7> matrix_double_10x5_row7; } template <> struct geometric_traits<detail::matrix_double_10x5_row7> { typedef detail::matrix_double_10x5_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,8> matrix_double_10x5_row8; } template <> struct geometric_traits<detail::matrix_double_10x5_row8> { typedef detail::matrix_double_10x5_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x5,9> matrix_double_10x5_row9; } template <> struct geometric_traits<detail::matrix_double_10x5_row9> { typedef detail::matrix_double_10x5_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x5,0> matrix_double_10x5_column0; }template <> struct geometric_traits<detail::matrix_double_10x5_column0> { typedef detail::matrix_double_10x5_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x5,1> matrix_double_10x5_column1; }template <> struct geometric_traits<detail::matrix_double_10x5_column1> { typedef detail::matrix_double_10x5_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x5,2> matrix_double_10x5_column2; }template <> struct geometric_traits<detail::matrix_double_10x5_column2> { typedef detail::matrix_double_10x5_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x5,3> matrix_double_10x5_column3; }template <> struct geometric_traits<detail::matrix_double_10x5_column3> { typedef detail::matrix_double_10x5_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x5,4> matrix_double_10x5_column4; }template <> struct geometric_traits<detail::matrix_double_10x5_column4> { typedef detail::matrix_double_10x5_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x5>::type > : index_operator_matrix_access_policy < matrix_double_10x5 > { typedef index_operator_matrix_access_policy < matrix_double_10x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x5 > { typedef dimension<10> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 6> matrix_double_10x6; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,0> matrix_double_10x6_row0; } template <> struct geometric_traits<detail::matrix_double_10x6_row0> { typedef detail::matrix_double_10x6_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,1> matrix_double_10x6_row1; } template <> struct geometric_traits<detail::matrix_double_10x6_row1> { typedef detail::matrix_double_10x6_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,2> matrix_double_10x6_row2; } template <> struct geometric_traits<detail::matrix_double_10x6_row2> { typedef detail::matrix_double_10x6_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,3> matrix_double_10x6_row3; } template <> struct geometric_traits<detail::matrix_double_10x6_row3> { typedef detail::matrix_double_10x6_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,4> matrix_double_10x6_row4; } template <> struct geometric_traits<detail::matrix_double_10x6_row4> { typedef detail::matrix_double_10x6_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,5> matrix_double_10x6_row5; } template <> struct geometric_traits<detail::matrix_double_10x6_row5> { typedef detail::matrix_double_10x6_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,6> matrix_double_10x6_row6; } template <> struct geometric_traits<detail::matrix_double_10x6_row6> { typedef detail::matrix_double_10x6_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,7> matrix_double_10x6_row7; } template <> struct geometric_traits<detail::matrix_double_10x6_row7> { typedef detail::matrix_double_10x6_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,8> matrix_double_10x6_row8; } template <> struct geometric_traits<detail::matrix_double_10x6_row8> { typedef detail::matrix_double_10x6_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x6,9> matrix_double_10x6_row9; } template <> struct geometric_traits<detail::matrix_double_10x6_row9> { typedef detail::matrix_double_10x6_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,0> matrix_double_10x6_column0; }template <> struct geometric_traits<detail::matrix_double_10x6_column0> { typedef detail::matrix_double_10x6_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,1> matrix_double_10x6_column1; }template <> struct geometric_traits<detail::matrix_double_10x6_column1> { typedef detail::matrix_double_10x6_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,2> matrix_double_10x6_column2; }template <> struct geometric_traits<detail::matrix_double_10x6_column2> { typedef detail::matrix_double_10x6_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,3> matrix_double_10x6_column3; }template <> struct geometric_traits<detail::matrix_double_10x6_column3> { typedef detail::matrix_double_10x6_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,4> matrix_double_10x6_column4; }template <> struct geometric_traits<detail::matrix_double_10x6_column4> { typedef detail::matrix_double_10x6_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x6,5> matrix_double_10x6_column5; }template <> struct geometric_traits<detail::matrix_double_10x6_column5> { typedef detail::matrix_double_10x6_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x6>::type > : index_operator_matrix_access_policy < matrix_double_10x6 > { typedef index_operator_matrix_access_policy < matrix_double_10x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x6 > { typedef dimension<10> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 7> matrix_double_10x7; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,0> matrix_double_10x7_row0; } template <> struct geometric_traits<detail::matrix_double_10x7_row0> { typedef detail::matrix_double_10x7_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,1> matrix_double_10x7_row1; } template <> struct geometric_traits<detail::matrix_double_10x7_row1> { typedef detail::matrix_double_10x7_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,2> matrix_double_10x7_row2; } template <> struct geometric_traits<detail::matrix_double_10x7_row2> { typedef detail::matrix_double_10x7_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,3> matrix_double_10x7_row3; } template <> struct geometric_traits<detail::matrix_double_10x7_row3> { typedef detail::matrix_double_10x7_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,4> matrix_double_10x7_row4; } template <> struct geometric_traits<detail::matrix_double_10x7_row4> { typedef detail::matrix_double_10x7_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,5> matrix_double_10x7_row5; } template <> struct geometric_traits<detail::matrix_double_10x7_row5> { typedef detail::matrix_double_10x7_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,6> matrix_double_10x7_row6; } template <> struct geometric_traits<detail::matrix_double_10x7_row6> { typedef detail::matrix_double_10x7_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,7> matrix_double_10x7_row7; } template <> struct geometric_traits<detail::matrix_double_10x7_row7> { typedef detail::matrix_double_10x7_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,8> matrix_double_10x7_row8; } template <> struct geometric_traits<detail::matrix_double_10x7_row8> { typedef detail::matrix_double_10x7_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x7,9> matrix_double_10x7_row9; } template <> struct geometric_traits<detail::matrix_double_10x7_row9> { typedef detail::matrix_double_10x7_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,0> matrix_double_10x7_column0; }template <> struct geometric_traits<detail::matrix_double_10x7_column0> { typedef detail::matrix_double_10x7_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,1> matrix_double_10x7_column1; }template <> struct geometric_traits<detail::matrix_double_10x7_column1> { typedef detail::matrix_double_10x7_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,2> matrix_double_10x7_column2; }template <> struct geometric_traits<detail::matrix_double_10x7_column2> { typedef detail::matrix_double_10x7_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,3> matrix_double_10x7_column3; }template <> struct geometric_traits<detail::matrix_double_10x7_column3> { typedef detail::matrix_double_10x7_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,4> matrix_double_10x7_column4; }template <> struct geometric_traits<detail::matrix_double_10x7_column4> { typedef detail::matrix_double_10x7_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,5> matrix_double_10x7_column5; }template <> struct geometric_traits<detail::matrix_double_10x7_column5> { typedef detail::matrix_double_10x7_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x7,6> matrix_double_10x7_column6; }template <> struct geometric_traits<detail::matrix_double_10x7_column6> { typedef detail::matrix_double_10x7_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x7>::type > : index_operator_matrix_access_policy < matrix_double_10x7 > { typedef index_operator_matrix_access_policy < matrix_double_10x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x7 > { typedef dimension<10> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 8> matrix_double_10x8; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,0> matrix_double_10x8_row0; } template <> struct geometric_traits<detail::matrix_double_10x8_row0> { typedef detail::matrix_double_10x8_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,1> matrix_double_10x8_row1; } template <> struct geometric_traits<detail::matrix_double_10x8_row1> { typedef detail::matrix_double_10x8_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,2> matrix_double_10x8_row2; } template <> struct geometric_traits<detail::matrix_double_10x8_row2> { typedef detail::matrix_double_10x8_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,3> matrix_double_10x8_row3; } template <> struct geometric_traits<detail::matrix_double_10x8_row3> { typedef detail::matrix_double_10x8_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,4> matrix_double_10x8_row4; } template <> struct geometric_traits<detail::matrix_double_10x8_row4> { typedef detail::matrix_double_10x8_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,5> matrix_double_10x8_row5; } template <> struct geometric_traits<detail::matrix_double_10x8_row5> { typedef detail::matrix_double_10x8_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,6> matrix_double_10x8_row6; } template <> struct geometric_traits<detail::matrix_double_10x8_row6> { typedef detail::matrix_double_10x8_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,7> matrix_double_10x8_row7; } template <> struct geometric_traits<detail::matrix_double_10x8_row7> { typedef detail::matrix_double_10x8_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,8> matrix_double_10x8_row8; } template <> struct geometric_traits<detail::matrix_double_10x8_row8> { typedef detail::matrix_double_10x8_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x8,9> matrix_double_10x8_row9; } template <> struct geometric_traits<detail::matrix_double_10x8_row9> { typedef detail::matrix_double_10x8_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,0> matrix_double_10x8_column0; }template <> struct geometric_traits<detail::matrix_double_10x8_column0> { typedef detail::matrix_double_10x8_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,1> matrix_double_10x8_column1; }template <> struct geometric_traits<detail::matrix_double_10x8_column1> { typedef detail::matrix_double_10x8_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,2> matrix_double_10x8_column2; }template <> struct geometric_traits<detail::matrix_double_10x8_column2> { typedef detail::matrix_double_10x8_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,3> matrix_double_10x8_column3; }template <> struct geometric_traits<detail::matrix_double_10x8_column3> { typedef detail::matrix_double_10x8_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,4> matrix_double_10x8_column4; }template <> struct geometric_traits<detail::matrix_double_10x8_column4> { typedef detail::matrix_double_10x8_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,5> matrix_double_10x8_column5; }template <> struct geometric_traits<detail::matrix_double_10x8_column5> { typedef detail::matrix_double_10x8_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,6> matrix_double_10x8_column6; }template <> struct geometric_traits<detail::matrix_double_10x8_column6> { typedef detail::matrix_double_10x8_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x8,7> matrix_double_10x8_column7; }template <> struct geometric_traits<detail::matrix_double_10x8_column7> { typedef detail::matrix_double_10x8_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x8>::type > : index_operator_matrix_access_policy < matrix_double_10x8 > { typedef index_operator_matrix_access_policy < matrix_double_10x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x8 > { typedef dimension<10> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 9> matrix_double_10x9; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,0> matrix_double_10x9_row0; } template <> struct geometric_traits<detail::matrix_double_10x9_row0> { typedef detail::matrix_double_10x9_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,1> matrix_double_10x9_row1; } template <> struct geometric_traits<detail::matrix_double_10x9_row1> { typedef detail::matrix_double_10x9_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,2> matrix_double_10x9_row2; } template <> struct geometric_traits<detail::matrix_double_10x9_row2> { typedef detail::matrix_double_10x9_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,3> matrix_double_10x9_row3; } template <> struct geometric_traits<detail::matrix_double_10x9_row3> { typedef detail::matrix_double_10x9_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,4> matrix_double_10x9_row4; } template <> struct geometric_traits<detail::matrix_double_10x9_row4> { typedef detail::matrix_double_10x9_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,5> matrix_double_10x9_row5; } template <> struct geometric_traits<detail::matrix_double_10x9_row5> { typedef detail::matrix_double_10x9_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,6> matrix_double_10x9_row6; } template <> struct geometric_traits<detail::matrix_double_10x9_row6> { typedef detail::matrix_double_10x9_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,7> matrix_double_10x9_row7; } template <> struct geometric_traits<detail::matrix_double_10x9_row7> { typedef detail::matrix_double_10x9_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,8> matrix_double_10x9_row8; } template <> struct geometric_traits<detail::matrix_double_10x9_row8> { typedef detail::matrix_double_10x9_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x9,9> matrix_double_10x9_row9; } template <> struct geometric_traits<detail::matrix_double_10x9_row9> { typedef detail::matrix_double_10x9_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,0> matrix_double_10x9_column0; }template <> struct geometric_traits<detail::matrix_double_10x9_column0> { typedef detail::matrix_double_10x9_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,1> matrix_double_10x9_column1; }template <> struct geometric_traits<detail::matrix_double_10x9_column1> { typedef detail::matrix_double_10x9_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,2> matrix_double_10x9_column2; }template <> struct geometric_traits<detail::matrix_double_10x9_column2> { typedef detail::matrix_double_10x9_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,3> matrix_double_10x9_column3; }template <> struct geometric_traits<detail::matrix_double_10x9_column3> { typedef detail::matrix_double_10x9_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,4> matrix_double_10x9_column4; }template <> struct geometric_traits<detail::matrix_double_10x9_column4> { typedef detail::matrix_double_10x9_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,5> matrix_double_10x9_column5; }template <> struct geometric_traits<detail::matrix_double_10x9_column5> { typedef detail::matrix_double_10x9_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,6> matrix_double_10x9_column6; }template <> struct geometric_traits<detail::matrix_double_10x9_column6> { typedef detail::matrix_double_10x9_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,7> matrix_double_10x9_column7; }template <> struct geometric_traits<detail::matrix_double_10x9_column7> { typedef detail::matrix_double_10x9_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x9,8> matrix_double_10x9_column8; }template <> struct geometric_traits<detail::matrix_double_10x9_column8> { typedef detail::matrix_double_10x9_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x9>::type > : index_operator_matrix_access_policy < matrix_double_10x9 > { typedef index_operator_matrix_access_policy < matrix_double_10x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x9 > { typedef dimension<10> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<double, 10, 10> matrix_double_10x10; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,0> matrix_double_10x10_row0; } template <> struct geometric_traits<detail::matrix_double_10x10_row0> { typedef detail::matrix_double_10x10_row0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,1> matrix_double_10x10_row1; } template <> struct geometric_traits<detail::matrix_double_10x10_row1> { typedef detail::matrix_double_10x10_row1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,2> matrix_double_10x10_row2; } template <> struct geometric_traits<detail::matrix_double_10x10_row2> { typedef detail::matrix_double_10x10_row2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,3> matrix_double_10x10_row3; } template <> struct geometric_traits<detail::matrix_double_10x10_row3> { typedef detail::matrix_double_10x10_row3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,4> matrix_double_10x10_row4; } template <> struct geometric_traits<detail::matrix_double_10x10_row4> { typedef detail::matrix_double_10x10_row4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,5> matrix_double_10x10_row5; } template <> struct geometric_traits<detail::matrix_double_10x10_row5> { typedef detail::matrix_double_10x10_row5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,6> matrix_double_10x10_row6; } template <> struct geometric_traits<detail::matrix_double_10x10_row6> { typedef detail::matrix_double_10x10_row6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,7> matrix_double_10x10_row7; } template <> struct geometric_traits<detail::matrix_double_10x10_row7> { typedef detail::matrix_double_10x10_row7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,8> matrix_double_10x10_row8; } template <> struct geometric_traits<detail::matrix_double_10x10_row8> { typedef detail::matrix_double_10x10_row8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_double_10x10,9> matrix_double_10x10_row9; } template <> struct geometric_traits<detail::matrix_double_10x10_row9> { typedef detail::matrix_double_10x10_row9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,0> matrix_double_10x10_column0; }template <> struct geometric_traits<detail::matrix_double_10x10_column0> { typedef detail::matrix_double_10x10_column0 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,1> matrix_double_10x10_column1; }template <> struct geometric_traits<detail::matrix_double_10x10_column1> { typedef detail::matrix_double_10x10_column1 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,2> matrix_double_10x10_column2; }template <> struct geometric_traits<detail::matrix_double_10x10_column2> { typedef detail::matrix_double_10x10_column2 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,3> matrix_double_10x10_column3; }template <> struct geometric_traits<detail::matrix_double_10x10_column3> { typedef detail::matrix_double_10x10_column3 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,4> matrix_double_10x10_column4; }template <> struct geometric_traits<detail::matrix_double_10x10_column4> { typedef detail::matrix_double_10x10_column4 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,5> matrix_double_10x10_column5; }template <> struct geometric_traits<detail::matrix_double_10x10_column5> { typedef detail::matrix_double_10x10_column5 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,6> matrix_double_10x10_column6; }template <> struct geometric_traits<detail::matrix_double_10x10_column6> { typedef detail::matrix_double_10x10_column6 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,7> matrix_double_10x10_column7; }template <> struct geometric_traits<detail::matrix_double_10x10_column7> { typedef detail::matrix_double_10x10_column7 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,8> matrix_double_10x10_column8; }template <> struct geometric_traits<detail::matrix_double_10x10_column8> { typedef detail::matrix_double_10x10_column8 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_double_10x10,9> matrix_double_10x10_column9; }template <> struct geometric_traits<detail::matrix_double_10x10_column9> { typedef detail::matrix_double_10x10_column9 sequence_type; typedef boost::mpl::vector<double, double, double, double, double, double, double, double, double, double> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_double_10x10>::type > : index_operator_matrix_access_policy < matrix_double_10x10 > { typedef index_operator_matrix_access_policy < matrix_double_10x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_double_10x10 > { typedef dimension<10> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; }
    namespace geometrix { typedef matrix<float, 1, 1> matrix_float_1x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x1,0> matrix_float_1x1_row0; } template <> struct geometric_traits<detail::matrix_float_1x1_row0> { typedef detail::matrix_float_1x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x1,0> matrix_float_1x1_column0; }template <> struct geometric_traits<detail::matrix_float_1x1_column0> { typedef detail::matrix_float_1x1_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x1>::type > : index_operator_matrix_access_policy < matrix_float_1x1 > { typedef index_operator_matrix_access_policy < matrix_float_1x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x1 > { typedef dimension<1> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 2> matrix_float_1x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x2,0> matrix_float_1x2_row0; } template <> struct geometric_traits<detail::matrix_float_1x2_row0> { typedef detail::matrix_float_1x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x2,0> matrix_float_1x2_column0; }template <> struct geometric_traits<detail::matrix_float_1x2_column0> { typedef detail::matrix_float_1x2_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x2,1> matrix_float_1x2_column1; }template <> struct geometric_traits<detail::matrix_float_1x2_column1> { typedef detail::matrix_float_1x2_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x2>::type > : index_operator_matrix_access_policy < matrix_float_1x2 > { typedef index_operator_matrix_access_policy < matrix_float_1x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x2 > { typedef dimension<1> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 3> matrix_float_1x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x3,0> matrix_float_1x3_row0; } template <> struct geometric_traits<detail::matrix_float_1x3_row0> { typedef detail::matrix_float_1x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x3,0> matrix_float_1x3_column0; }template <> struct geometric_traits<detail::matrix_float_1x3_column0> { typedef detail::matrix_float_1x3_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x3,1> matrix_float_1x3_column1; }template <> struct geometric_traits<detail::matrix_float_1x3_column1> { typedef detail::matrix_float_1x3_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x3,2> matrix_float_1x3_column2; }template <> struct geometric_traits<detail::matrix_float_1x3_column2> { typedef detail::matrix_float_1x3_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x3>::type > : index_operator_matrix_access_policy < matrix_float_1x3 > { typedef index_operator_matrix_access_policy < matrix_float_1x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x3 > { typedef dimension<1> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 4> matrix_float_1x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x4,0> matrix_float_1x4_row0; } template <> struct geometric_traits<detail::matrix_float_1x4_row0> { typedef detail::matrix_float_1x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x4,0> matrix_float_1x4_column0; }template <> struct geometric_traits<detail::matrix_float_1x4_column0> { typedef detail::matrix_float_1x4_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x4,1> matrix_float_1x4_column1; }template <> struct geometric_traits<detail::matrix_float_1x4_column1> { typedef detail::matrix_float_1x4_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x4,2> matrix_float_1x4_column2; }template <> struct geometric_traits<detail::matrix_float_1x4_column2> { typedef detail::matrix_float_1x4_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x4,3> matrix_float_1x4_column3; }template <> struct geometric_traits<detail::matrix_float_1x4_column3> { typedef detail::matrix_float_1x4_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x4>::type > : index_operator_matrix_access_policy < matrix_float_1x4 > { typedef index_operator_matrix_access_policy < matrix_float_1x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x4 > { typedef dimension<1> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 5> matrix_float_1x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x5,0> matrix_float_1x5_row0; } template <> struct geometric_traits<detail::matrix_float_1x5_row0> { typedef detail::matrix_float_1x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x5,0> matrix_float_1x5_column0; }template <> struct geometric_traits<detail::matrix_float_1x5_column0> { typedef detail::matrix_float_1x5_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x5,1> matrix_float_1x5_column1; }template <> struct geometric_traits<detail::matrix_float_1x5_column1> { typedef detail::matrix_float_1x5_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x5,2> matrix_float_1x5_column2; }template <> struct geometric_traits<detail::matrix_float_1x5_column2> { typedef detail::matrix_float_1x5_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x5,3> matrix_float_1x5_column3; }template <> struct geometric_traits<detail::matrix_float_1x5_column3> { typedef detail::matrix_float_1x5_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x5,4> matrix_float_1x5_column4; }template <> struct geometric_traits<detail::matrix_float_1x5_column4> { typedef detail::matrix_float_1x5_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x5>::type > : index_operator_matrix_access_policy < matrix_float_1x5 > { typedef index_operator_matrix_access_policy < matrix_float_1x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x5 > { typedef dimension<1> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 6> matrix_float_1x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x6,0> matrix_float_1x6_row0; } template <> struct geometric_traits<detail::matrix_float_1x6_row0> { typedef detail::matrix_float_1x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,0> matrix_float_1x6_column0; }template <> struct geometric_traits<detail::matrix_float_1x6_column0> { typedef detail::matrix_float_1x6_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,1> matrix_float_1x6_column1; }template <> struct geometric_traits<detail::matrix_float_1x6_column1> { typedef detail::matrix_float_1x6_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,2> matrix_float_1x6_column2; }template <> struct geometric_traits<detail::matrix_float_1x6_column2> { typedef detail::matrix_float_1x6_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,3> matrix_float_1x6_column3; }template <> struct geometric_traits<detail::matrix_float_1x6_column3> { typedef detail::matrix_float_1x6_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,4> matrix_float_1x6_column4; }template <> struct geometric_traits<detail::matrix_float_1x6_column4> { typedef detail::matrix_float_1x6_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x6,5> matrix_float_1x6_column5; }template <> struct geometric_traits<detail::matrix_float_1x6_column5> { typedef detail::matrix_float_1x6_column5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x6>::type > : index_operator_matrix_access_policy < matrix_float_1x6 > { typedef index_operator_matrix_access_policy < matrix_float_1x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x6 > { typedef dimension<1> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 7> matrix_float_1x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x7,0> matrix_float_1x7_row0; } template <> struct geometric_traits<detail::matrix_float_1x7_row0> { typedef detail::matrix_float_1x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,0> matrix_float_1x7_column0; }template <> struct geometric_traits<detail::matrix_float_1x7_column0> { typedef detail::matrix_float_1x7_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,1> matrix_float_1x7_column1; }template <> struct geometric_traits<detail::matrix_float_1x7_column1> { typedef detail::matrix_float_1x7_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,2> matrix_float_1x7_column2; }template <> struct geometric_traits<detail::matrix_float_1x7_column2> { typedef detail::matrix_float_1x7_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,3> matrix_float_1x7_column3; }template <> struct geometric_traits<detail::matrix_float_1x7_column3> { typedef detail::matrix_float_1x7_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,4> matrix_float_1x7_column4; }template <> struct geometric_traits<detail::matrix_float_1x7_column4> { typedef detail::matrix_float_1x7_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,5> matrix_float_1x7_column5; }template <> struct geometric_traits<detail::matrix_float_1x7_column5> { typedef detail::matrix_float_1x7_column5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x7,6> matrix_float_1x7_column6; }template <> struct geometric_traits<detail::matrix_float_1x7_column6> { typedef detail::matrix_float_1x7_column6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x7>::type > : index_operator_matrix_access_policy < matrix_float_1x7 > { typedef index_operator_matrix_access_policy < matrix_float_1x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x7 > { typedef dimension<1> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 8> matrix_float_1x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x8,0> matrix_float_1x8_row0; } template <> struct geometric_traits<detail::matrix_float_1x8_row0> { typedef detail::matrix_float_1x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,0> matrix_float_1x8_column0; }template <> struct geometric_traits<detail::matrix_float_1x8_column0> { typedef detail::matrix_float_1x8_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,1> matrix_float_1x8_column1; }template <> struct geometric_traits<detail::matrix_float_1x8_column1> { typedef detail::matrix_float_1x8_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,2> matrix_float_1x8_column2; }template <> struct geometric_traits<detail::matrix_float_1x8_column2> { typedef detail::matrix_float_1x8_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,3> matrix_float_1x8_column3; }template <> struct geometric_traits<detail::matrix_float_1x8_column3> { typedef detail::matrix_float_1x8_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,4> matrix_float_1x8_column4; }template <> struct geometric_traits<detail::matrix_float_1x8_column4> { typedef detail::matrix_float_1x8_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,5> matrix_float_1x8_column5; }template <> struct geometric_traits<detail::matrix_float_1x8_column5> { typedef detail::matrix_float_1x8_column5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,6> matrix_float_1x8_column6; }template <> struct geometric_traits<detail::matrix_float_1x8_column6> { typedef detail::matrix_float_1x8_column6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x8,7> matrix_float_1x8_column7; }template <> struct geometric_traits<detail::matrix_float_1x8_column7> { typedef detail::matrix_float_1x8_column7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x8>::type > : index_operator_matrix_access_policy < matrix_float_1x8 > { typedef index_operator_matrix_access_policy < matrix_float_1x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x8 > { typedef dimension<1> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 9> matrix_float_1x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x9,0> matrix_float_1x9_row0; } template <> struct geometric_traits<detail::matrix_float_1x9_row0> { typedef detail::matrix_float_1x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,0> matrix_float_1x9_column0; }template <> struct geometric_traits<detail::matrix_float_1x9_column0> { typedef detail::matrix_float_1x9_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,1> matrix_float_1x9_column1; }template <> struct geometric_traits<detail::matrix_float_1x9_column1> { typedef detail::matrix_float_1x9_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,2> matrix_float_1x9_column2; }template <> struct geometric_traits<detail::matrix_float_1x9_column2> { typedef detail::matrix_float_1x9_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,3> matrix_float_1x9_column3; }template <> struct geometric_traits<detail::matrix_float_1x9_column3> { typedef detail::matrix_float_1x9_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,4> matrix_float_1x9_column4; }template <> struct geometric_traits<detail::matrix_float_1x9_column4> { typedef detail::matrix_float_1x9_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,5> matrix_float_1x9_column5; }template <> struct geometric_traits<detail::matrix_float_1x9_column5> { typedef detail::matrix_float_1x9_column5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,6> matrix_float_1x9_column6; }template <> struct geometric_traits<detail::matrix_float_1x9_column6> { typedef detail::matrix_float_1x9_column6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,7> matrix_float_1x9_column7; }template <> struct geometric_traits<detail::matrix_float_1x9_column7> { typedef detail::matrix_float_1x9_column7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x9,8> matrix_float_1x9_column8; }template <> struct geometric_traits<detail::matrix_float_1x9_column8> { typedef detail::matrix_float_1x9_column8 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x9>::type > : index_operator_matrix_access_policy < matrix_float_1x9 > { typedef index_operator_matrix_access_policy < matrix_float_1x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x9 > { typedef dimension<1> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 1, 10> matrix_float_1x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_1x10,0> matrix_float_1x10_row0; } template <> struct geometric_traits<detail::matrix_float_1x10_row0> { typedef detail::matrix_float_1x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,0> matrix_float_1x10_column0; }template <> struct geometric_traits<detail::matrix_float_1x10_column0> { typedef detail::matrix_float_1x10_column0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,1> matrix_float_1x10_column1; }template <> struct geometric_traits<detail::matrix_float_1x10_column1> { typedef detail::matrix_float_1x10_column1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,2> matrix_float_1x10_column2; }template <> struct geometric_traits<detail::matrix_float_1x10_column2> { typedef detail::matrix_float_1x10_column2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,3> matrix_float_1x10_column3; }template <> struct geometric_traits<detail::matrix_float_1x10_column3> { typedef detail::matrix_float_1x10_column3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,4> matrix_float_1x10_column4; }template <> struct geometric_traits<detail::matrix_float_1x10_column4> { typedef detail::matrix_float_1x10_column4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,5> matrix_float_1x10_column5; }template <> struct geometric_traits<detail::matrix_float_1x10_column5> { typedef detail::matrix_float_1x10_column5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,6> matrix_float_1x10_column6; }template <> struct geometric_traits<detail::matrix_float_1x10_column6> { typedef detail::matrix_float_1x10_column6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,7> matrix_float_1x10_column7; }template <> struct geometric_traits<detail::matrix_float_1x10_column7> { typedef detail::matrix_float_1x10_column7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,8> matrix_float_1x10_column8; }template <> struct geometric_traits<detail::matrix_float_1x10_column8> { typedef detail::matrix_float_1x10_column8 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_1x10,9> matrix_float_1x10_column9; }template <> struct geometric_traits<detail::matrix_float_1x10_column9> { typedef detail::matrix_float_1x10_column9 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_1x10>::type > : index_operator_matrix_access_policy < matrix_float_1x10 > { typedef index_operator_matrix_access_policy < matrix_float_1x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_1x10 > { typedef dimension<1> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 1> matrix_float_2x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x1,0> matrix_float_2x1_row0; } template <> struct geometric_traits<detail::matrix_float_2x1_row0> { typedef detail::matrix_float_2x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x1,1> matrix_float_2x1_row1; } template <> struct geometric_traits<detail::matrix_float_2x1_row1> { typedef detail::matrix_float_2x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x1,0> matrix_float_2x1_column0; }template <> struct geometric_traits<detail::matrix_float_2x1_column0> { typedef detail::matrix_float_2x1_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x1>::type > : index_operator_matrix_access_policy < matrix_float_2x1 > { typedef index_operator_matrix_access_policy < matrix_float_2x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x1 > { typedef dimension<2> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 2> matrix_float_2x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x2,0> matrix_float_2x2_row0; } template <> struct geometric_traits<detail::matrix_float_2x2_row0> { typedef detail::matrix_float_2x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x2,1> matrix_float_2x2_row1; } template <> struct geometric_traits<detail::matrix_float_2x2_row1> { typedef detail::matrix_float_2x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x2,0> matrix_float_2x2_column0; }template <> struct geometric_traits<detail::matrix_float_2x2_column0> { typedef detail::matrix_float_2x2_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x2,1> matrix_float_2x2_column1; }template <> struct geometric_traits<detail::matrix_float_2x2_column1> { typedef detail::matrix_float_2x2_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x2>::type > : index_operator_matrix_access_policy < matrix_float_2x2 > { typedef index_operator_matrix_access_policy < matrix_float_2x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x2 > { typedef dimension<2> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 3> matrix_float_2x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x3,0> matrix_float_2x3_row0; } template <> struct geometric_traits<detail::matrix_float_2x3_row0> { typedef detail::matrix_float_2x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x3,1> matrix_float_2x3_row1; } template <> struct geometric_traits<detail::matrix_float_2x3_row1> { typedef detail::matrix_float_2x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x3,0> matrix_float_2x3_column0; }template <> struct geometric_traits<detail::matrix_float_2x3_column0> { typedef detail::matrix_float_2x3_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x3,1> matrix_float_2x3_column1; }template <> struct geometric_traits<detail::matrix_float_2x3_column1> { typedef detail::matrix_float_2x3_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x3,2> matrix_float_2x3_column2; }template <> struct geometric_traits<detail::matrix_float_2x3_column2> { typedef detail::matrix_float_2x3_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x3>::type > : index_operator_matrix_access_policy < matrix_float_2x3 > { typedef index_operator_matrix_access_policy < matrix_float_2x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x3 > { typedef dimension<2> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 4> matrix_float_2x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x4,0> matrix_float_2x4_row0; } template <> struct geometric_traits<detail::matrix_float_2x4_row0> { typedef detail::matrix_float_2x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x4,1> matrix_float_2x4_row1; } template <> struct geometric_traits<detail::matrix_float_2x4_row1> { typedef detail::matrix_float_2x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x4,0> matrix_float_2x4_column0; }template <> struct geometric_traits<detail::matrix_float_2x4_column0> { typedef detail::matrix_float_2x4_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x4,1> matrix_float_2x4_column1; }template <> struct geometric_traits<detail::matrix_float_2x4_column1> { typedef detail::matrix_float_2x4_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x4,2> matrix_float_2x4_column2; }template <> struct geometric_traits<detail::matrix_float_2x4_column2> { typedef detail::matrix_float_2x4_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x4,3> matrix_float_2x4_column3; }template <> struct geometric_traits<detail::matrix_float_2x4_column3> { typedef detail::matrix_float_2x4_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x4>::type > : index_operator_matrix_access_policy < matrix_float_2x4 > { typedef index_operator_matrix_access_policy < matrix_float_2x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x4 > { typedef dimension<2> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 5> matrix_float_2x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x5,0> matrix_float_2x5_row0; } template <> struct geometric_traits<detail::matrix_float_2x5_row0> { typedef detail::matrix_float_2x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x5,1> matrix_float_2x5_row1; } template <> struct geometric_traits<detail::matrix_float_2x5_row1> { typedef detail::matrix_float_2x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x5,0> matrix_float_2x5_column0; }template <> struct geometric_traits<detail::matrix_float_2x5_column0> { typedef detail::matrix_float_2x5_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x5,1> matrix_float_2x5_column1; }template <> struct geometric_traits<detail::matrix_float_2x5_column1> { typedef detail::matrix_float_2x5_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x5,2> matrix_float_2x5_column2; }template <> struct geometric_traits<detail::matrix_float_2x5_column2> { typedef detail::matrix_float_2x5_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x5,3> matrix_float_2x5_column3; }template <> struct geometric_traits<detail::matrix_float_2x5_column3> { typedef detail::matrix_float_2x5_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x5,4> matrix_float_2x5_column4; }template <> struct geometric_traits<detail::matrix_float_2x5_column4> { typedef detail::matrix_float_2x5_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x5>::type > : index_operator_matrix_access_policy < matrix_float_2x5 > { typedef index_operator_matrix_access_policy < matrix_float_2x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x5 > { typedef dimension<2> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 6> matrix_float_2x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x6,0> matrix_float_2x6_row0; } template <> struct geometric_traits<detail::matrix_float_2x6_row0> { typedef detail::matrix_float_2x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x6,1> matrix_float_2x6_row1; } template <> struct geometric_traits<detail::matrix_float_2x6_row1> { typedef detail::matrix_float_2x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,0> matrix_float_2x6_column0; }template <> struct geometric_traits<detail::matrix_float_2x6_column0> { typedef detail::matrix_float_2x6_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,1> matrix_float_2x6_column1; }template <> struct geometric_traits<detail::matrix_float_2x6_column1> { typedef detail::matrix_float_2x6_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,2> matrix_float_2x6_column2; }template <> struct geometric_traits<detail::matrix_float_2x6_column2> { typedef detail::matrix_float_2x6_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,3> matrix_float_2x6_column3; }template <> struct geometric_traits<detail::matrix_float_2x6_column3> { typedef detail::matrix_float_2x6_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,4> matrix_float_2x6_column4; }template <> struct geometric_traits<detail::matrix_float_2x6_column4> { typedef detail::matrix_float_2x6_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x6,5> matrix_float_2x6_column5; }template <> struct geometric_traits<detail::matrix_float_2x6_column5> { typedef detail::matrix_float_2x6_column5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x6>::type > : index_operator_matrix_access_policy < matrix_float_2x6 > { typedef index_operator_matrix_access_policy < matrix_float_2x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x6 > { typedef dimension<2> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 7> matrix_float_2x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x7,0> matrix_float_2x7_row0; } template <> struct geometric_traits<detail::matrix_float_2x7_row0> { typedef detail::matrix_float_2x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x7,1> matrix_float_2x7_row1; } template <> struct geometric_traits<detail::matrix_float_2x7_row1> { typedef detail::matrix_float_2x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,0> matrix_float_2x7_column0; }template <> struct geometric_traits<detail::matrix_float_2x7_column0> { typedef detail::matrix_float_2x7_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,1> matrix_float_2x7_column1; }template <> struct geometric_traits<detail::matrix_float_2x7_column1> { typedef detail::matrix_float_2x7_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,2> matrix_float_2x7_column2; }template <> struct geometric_traits<detail::matrix_float_2x7_column2> { typedef detail::matrix_float_2x7_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,3> matrix_float_2x7_column3; }template <> struct geometric_traits<detail::matrix_float_2x7_column3> { typedef detail::matrix_float_2x7_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,4> matrix_float_2x7_column4; }template <> struct geometric_traits<detail::matrix_float_2x7_column4> { typedef detail::matrix_float_2x7_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,5> matrix_float_2x7_column5; }template <> struct geometric_traits<detail::matrix_float_2x7_column5> { typedef detail::matrix_float_2x7_column5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x7,6> matrix_float_2x7_column6; }template <> struct geometric_traits<detail::matrix_float_2x7_column6> { typedef detail::matrix_float_2x7_column6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x7>::type > : index_operator_matrix_access_policy < matrix_float_2x7 > { typedef index_operator_matrix_access_policy < matrix_float_2x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x7 > { typedef dimension<2> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 8> matrix_float_2x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x8,0> matrix_float_2x8_row0; } template <> struct geometric_traits<detail::matrix_float_2x8_row0> { typedef detail::matrix_float_2x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x8,1> matrix_float_2x8_row1; } template <> struct geometric_traits<detail::matrix_float_2x8_row1> { typedef detail::matrix_float_2x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,0> matrix_float_2x8_column0; }template <> struct geometric_traits<detail::matrix_float_2x8_column0> { typedef detail::matrix_float_2x8_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,1> matrix_float_2x8_column1; }template <> struct geometric_traits<detail::matrix_float_2x8_column1> { typedef detail::matrix_float_2x8_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,2> matrix_float_2x8_column2; }template <> struct geometric_traits<detail::matrix_float_2x8_column2> { typedef detail::matrix_float_2x8_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,3> matrix_float_2x8_column3; }template <> struct geometric_traits<detail::matrix_float_2x8_column3> { typedef detail::matrix_float_2x8_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,4> matrix_float_2x8_column4; }template <> struct geometric_traits<detail::matrix_float_2x8_column4> { typedef detail::matrix_float_2x8_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,5> matrix_float_2x8_column5; }template <> struct geometric_traits<detail::matrix_float_2x8_column5> { typedef detail::matrix_float_2x8_column5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,6> matrix_float_2x8_column6; }template <> struct geometric_traits<detail::matrix_float_2x8_column6> { typedef detail::matrix_float_2x8_column6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x8,7> matrix_float_2x8_column7; }template <> struct geometric_traits<detail::matrix_float_2x8_column7> { typedef detail::matrix_float_2x8_column7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x8>::type > : index_operator_matrix_access_policy < matrix_float_2x8 > { typedef index_operator_matrix_access_policy < matrix_float_2x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x8 > { typedef dimension<2> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 9> matrix_float_2x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x9,0> matrix_float_2x9_row0; } template <> struct geometric_traits<detail::matrix_float_2x9_row0> { typedef detail::matrix_float_2x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x9,1> matrix_float_2x9_row1; } template <> struct geometric_traits<detail::matrix_float_2x9_row1> { typedef detail::matrix_float_2x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,0> matrix_float_2x9_column0; }template <> struct geometric_traits<detail::matrix_float_2x9_column0> { typedef detail::matrix_float_2x9_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,1> matrix_float_2x9_column1; }template <> struct geometric_traits<detail::matrix_float_2x9_column1> { typedef detail::matrix_float_2x9_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,2> matrix_float_2x9_column2; }template <> struct geometric_traits<detail::matrix_float_2x9_column2> { typedef detail::matrix_float_2x9_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,3> matrix_float_2x9_column3; }template <> struct geometric_traits<detail::matrix_float_2x9_column3> { typedef detail::matrix_float_2x9_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,4> matrix_float_2x9_column4; }template <> struct geometric_traits<detail::matrix_float_2x9_column4> { typedef detail::matrix_float_2x9_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,5> matrix_float_2x9_column5; }template <> struct geometric_traits<detail::matrix_float_2x9_column5> { typedef detail::matrix_float_2x9_column5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,6> matrix_float_2x9_column6; }template <> struct geometric_traits<detail::matrix_float_2x9_column6> { typedef detail::matrix_float_2x9_column6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,7> matrix_float_2x9_column7; }template <> struct geometric_traits<detail::matrix_float_2x9_column7> { typedef detail::matrix_float_2x9_column7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x9,8> matrix_float_2x9_column8; }template <> struct geometric_traits<detail::matrix_float_2x9_column8> { typedef detail::matrix_float_2x9_column8 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x9>::type > : index_operator_matrix_access_policy < matrix_float_2x9 > { typedef index_operator_matrix_access_policy < matrix_float_2x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x9 > { typedef dimension<2> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 2, 10> matrix_float_2x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x10,0> matrix_float_2x10_row0; } template <> struct geometric_traits<detail::matrix_float_2x10_row0> { typedef detail::matrix_float_2x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_2x10,1> matrix_float_2x10_row1; } template <> struct geometric_traits<detail::matrix_float_2x10_row1> { typedef detail::matrix_float_2x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,0> matrix_float_2x10_column0; }template <> struct geometric_traits<detail::matrix_float_2x10_column0> { typedef detail::matrix_float_2x10_column0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,1> matrix_float_2x10_column1; }template <> struct geometric_traits<detail::matrix_float_2x10_column1> { typedef detail::matrix_float_2x10_column1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,2> matrix_float_2x10_column2; }template <> struct geometric_traits<detail::matrix_float_2x10_column2> { typedef detail::matrix_float_2x10_column2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,3> matrix_float_2x10_column3; }template <> struct geometric_traits<detail::matrix_float_2x10_column3> { typedef detail::matrix_float_2x10_column3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,4> matrix_float_2x10_column4; }template <> struct geometric_traits<detail::matrix_float_2x10_column4> { typedef detail::matrix_float_2x10_column4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,5> matrix_float_2x10_column5; }template <> struct geometric_traits<detail::matrix_float_2x10_column5> { typedef detail::matrix_float_2x10_column5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,6> matrix_float_2x10_column6; }template <> struct geometric_traits<detail::matrix_float_2x10_column6> { typedef detail::matrix_float_2x10_column6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,7> matrix_float_2x10_column7; }template <> struct geometric_traits<detail::matrix_float_2x10_column7> { typedef detail::matrix_float_2x10_column7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,8> matrix_float_2x10_column8; }template <> struct geometric_traits<detail::matrix_float_2x10_column8> { typedef detail::matrix_float_2x10_column8 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_2x10,9> matrix_float_2x10_column9; }template <> struct geometric_traits<detail::matrix_float_2x10_column9> { typedef detail::matrix_float_2x10_column9 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_2x10>::type > : index_operator_matrix_access_policy < matrix_float_2x10 > { typedef index_operator_matrix_access_policy < matrix_float_2x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_2x10 > { typedef dimension<2> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 1> matrix_float_3x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x1,0> matrix_float_3x1_row0; } template <> struct geometric_traits<detail::matrix_float_3x1_row0> { typedef detail::matrix_float_3x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x1,1> matrix_float_3x1_row1; } template <> struct geometric_traits<detail::matrix_float_3x1_row1> { typedef detail::matrix_float_3x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x1,2> matrix_float_3x1_row2; } template <> struct geometric_traits<detail::matrix_float_3x1_row2> { typedef detail::matrix_float_3x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x1,0> matrix_float_3x1_column0; }template <> struct geometric_traits<detail::matrix_float_3x1_column0> { typedef detail::matrix_float_3x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x1>::type > : index_operator_matrix_access_policy < matrix_float_3x1 > { typedef index_operator_matrix_access_policy < matrix_float_3x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x1 > { typedef dimension<3> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 2> matrix_float_3x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x2,0> matrix_float_3x2_row0; } template <> struct geometric_traits<detail::matrix_float_3x2_row0> { typedef detail::matrix_float_3x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x2,1> matrix_float_3x2_row1; } template <> struct geometric_traits<detail::matrix_float_3x2_row1> { typedef detail::matrix_float_3x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x2,2> matrix_float_3x2_row2; } template <> struct geometric_traits<detail::matrix_float_3x2_row2> { typedef detail::matrix_float_3x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x2,0> matrix_float_3x2_column0; }template <> struct geometric_traits<detail::matrix_float_3x2_column0> { typedef detail::matrix_float_3x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x2,1> matrix_float_3x2_column1; }template <> struct geometric_traits<detail::matrix_float_3x2_column1> { typedef detail::matrix_float_3x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x2>::type > : index_operator_matrix_access_policy < matrix_float_3x2 > { typedef index_operator_matrix_access_policy < matrix_float_3x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x2 > { typedef dimension<3> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 3> matrix_float_3x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x3,0> matrix_float_3x3_row0; } template <> struct geometric_traits<detail::matrix_float_3x3_row0> { typedef detail::matrix_float_3x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x3,1> matrix_float_3x3_row1; } template <> struct geometric_traits<detail::matrix_float_3x3_row1> { typedef detail::matrix_float_3x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x3,2> matrix_float_3x3_row2; } template <> struct geometric_traits<detail::matrix_float_3x3_row2> { typedef detail::matrix_float_3x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x3,0> matrix_float_3x3_column0; }template <> struct geometric_traits<detail::matrix_float_3x3_column0> { typedef detail::matrix_float_3x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x3,1> matrix_float_3x3_column1; }template <> struct geometric_traits<detail::matrix_float_3x3_column1> { typedef detail::matrix_float_3x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x3,2> matrix_float_3x3_column2; }template <> struct geometric_traits<detail::matrix_float_3x3_column2> { typedef detail::matrix_float_3x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x3>::type > : index_operator_matrix_access_policy < matrix_float_3x3 > { typedef index_operator_matrix_access_policy < matrix_float_3x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x3 > { typedef dimension<3> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 4> matrix_float_3x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x4,0> matrix_float_3x4_row0; } template <> struct geometric_traits<detail::matrix_float_3x4_row0> { typedef detail::matrix_float_3x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x4,1> matrix_float_3x4_row1; } template <> struct geometric_traits<detail::matrix_float_3x4_row1> { typedef detail::matrix_float_3x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x4,2> matrix_float_3x4_row2; } template <> struct geometric_traits<detail::matrix_float_3x4_row2> { typedef detail::matrix_float_3x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x4,0> matrix_float_3x4_column0; }template <> struct geometric_traits<detail::matrix_float_3x4_column0> { typedef detail::matrix_float_3x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x4,1> matrix_float_3x4_column1; }template <> struct geometric_traits<detail::matrix_float_3x4_column1> { typedef detail::matrix_float_3x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x4,2> matrix_float_3x4_column2; }template <> struct geometric_traits<detail::matrix_float_3x4_column2> { typedef detail::matrix_float_3x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x4,3> matrix_float_3x4_column3; }template <> struct geometric_traits<detail::matrix_float_3x4_column3> { typedef detail::matrix_float_3x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x4>::type > : index_operator_matrix_access_policy < matrix_float_3x4 > { typedef index_operator_matrix_access_policy < matrix_float_3x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x4 > { typedef dimension<3> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 5> matrix_float_3x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x5,0> matrix_float_3x5_row0; } template <> struct geometric_traits<detail::matrix_float_3x5_row0> { typedef detail::matrix_float_3x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x5,1> matrix_float_3x5_row1; } template <> struct geometric_traits<detail::matrix_float_3x5_row1> { typedef detail::matrix_float_3x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x5,2> matrix_float_3x5_row2; } template <> struct geometric_traits<detail::matrix_float_3x5_row2> { typedef detail::matrix_float_3x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x5,0> matrix_float_3x5_column0; }template <> struct geometric_traits<detail::matrix_float_3x5_column0> { typedef detail::matrix_float_3x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x5,1> matrix_float_3x5_column1; }template <> struct geometric_traits<detail::matrix_float_3x5_column1> { typedef detail::matrix_float_3x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x5,2> matrix_float_3x5_column2; }template <> struct geometric_traits<detail::matrix_float_3x5_column2> { typedef detail::matrix_float_3x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x5,3> matrix_float_3x5_column3; }template <> struct geometric_traits<detail::matrix_float_3x5_column3> { typedef detail::matrix_float_3x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x5,4> matrix_float_3x5_column4; }template <> struct geometric_traits<detail::matrix_float_3x5_column4> { typedef detail::matrix_float_3x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x5>::type > : index_operator_matrix_access_policy < matrix_float_3x5 > { typedef index_operator_matrix_access_policy < matrix_float_3x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x5 > { typedef dimension<3> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 6> matrix_float_3x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x6,0> matrix_float_3x6_row0; } template <> struct geometric_traits<detail::matrix_float_3x6_row0> { typedef detail::matrix_float_3x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x6,1> matrix_float_3x6_row1; } template <> struct geometric_traits<detail::matrix_float_3x6_row1> { typedef detail::matrix_float_3x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x6,2> matrix_float_3x6_row2; } template <> struct geometric_traits<detail::matrix_float_3x6_row2> { typedef detail::matrix_float_3x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,0> matrix_float_3x6_column0; }template <> struct geometric_traits<detail::matrix_float_3x6_column0> { typedef detail::matrix_float_3x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,1> matrix_float_3x6_column1; }template <> struct geometric_traits<detail::matrix_float_3x6_column1> { typedef detail::matrix_float_3x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,2> matrix_float_3x6_column2; }template <> struct geometric_traits<detail::matrix_float_3x6_column2> { typedef detail::matrix_float_3x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,3> matrix_float_3x6_column3; }template <> struct geometric_traits<detail::matrix_float_3x6_column3> { typedef detail::matrix_float_3x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,4> matrix_float_3x6_column4; }template <> struct geometric_traits<detail::matrix_float_3x6_column4> { typedef detail::matrix_float_3x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x6,5> matrix_float_3x6_column5; }template <> struct geometric_traits<detail::matrix_float_3x6_column5> { typedef detail::matrix_float_3x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x6>::type > : index_operator_matrix_access_policy < matrix_float_3x6 > { typedef index_operator_matrix_access_policy < matrix_float_3x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x6 > { typedef dimension<3> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 7> matrix_float_3x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x7,0> matrix_float_3x7_row0; } template <> struct geometric_traits<detail::matrix_float_3x7_row0> { typedef detail::matrix_float_3x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x7,1> matrix_float_3x7_row1; } template <> struct geometric_traits<detail::matrix_float_3x7_row1> { typedef detail::matrix_float_3x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x7,2> matrix_float_3x7_row2; } template <> struct geometric_traits<detail::matrix_float_3x7_row2> { typedef detail::matrix_float_3x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,0> matrix_float_3x7_column0; }template <> struct geometric_traits<detail::matrix_float_3x7_column0> { typedef detail::matrix_float_3x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,1> matrix_float_3x7_column1; }template <> struct geometric_traits<detail::matrix_float_3x7_column1> { typedef detail::matrix_float_3x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,2> matrix_float_3x7_column2; }template <> struct geometric_traits<detail::matrix_float_3x7_column2> { typedef detail::matrix_float_3x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,3> matrix_float_3x7_column3; }template <> struct geometric_traits<detail::matrix_float_3x7_column3> { typedef detail::matrix_float_3x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,4> matrix_float_3x7_column4; }template <> struct geometric_traits<detail::matrix_float_3x7_column4> { typedef detail::matrix_float_3x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,5> matrix_float_3x7_column5; }template <> struct geometric_traits<detail::matrix_float_3x7_column5> { typedef detail::matrix_float_3x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x7,6> matrix_float_3x7_column6; }template <> struct geometric_traits<detail::matrix_float_3x7_column6> { typedef detail::matrix_float_3x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x7>::type > : index_operator_matrix_access_policy < matrix_float_3x7 > { typedef index_operator_matrix_access_policy < matrix_float_3x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x7 > { typedef dimension<3> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 8> matrix_float_3x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x8,0> matrix_float_3x8_row0; } template <> struct geometric_traits<detail::matrix_float_3x8_row0> { typedef detail::matrix_float_3x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x8,1> matrix_float_3x8_row1; } template <> struct geometric_traits<detail::matrix_float_3x8_row1> { typedef detail::matrix_float_3x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x8,2> matrix_float_3x8_row2; } template <> struct geometric_traits<detail::matrix_float_3x8_row2> { typedef detail::matrix_float_3x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,0> matrix_float_3x8_column0; }template <> struct geometric_traits<detail::matrix_float_3x8_column0> { typedef detail::matrix_float_3x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,1> matrix_float_3x8_column1; }template <> struct geometric_traits<detail::matrix_float_3x8_column1> { typedef detail::matrix_float_3x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,2> matrix_float_3x8_column2; }template <> struct geometric_traits<detail::matrix_float_3x8_column2> { typedef detail::matrix_float_3x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,3> matrix_float_3x8_column3; }template <> struct geometric_traits<detail::matrix_float_3x8_column3> { typedef detail::matrix_float_3x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,4> matrix_float_3x8_column4; }template <> struct geometric_traits<detail::matrix_float_3x8_column4> { typedef detail::matrix_float_3x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,5> matrix_float_3x8_column5; }template <> struct geometric_traits<detail::matrix_float_3x8_column5> { typedef detail::matrix_float_3x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,6> matrix_float_3x8_column6; }template <> struct geometric_traits<detail::matrix_float_3x8_column6> { typedef detail::matrix_float_3x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x8,7> matrix_float_3x8_column7; }template <> struct geometric_traits<detail::matrix_float_3x8_column7> { typedef detail::matrix_float_3x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x8>::type > : index_operator_matrix_access_policy < matrix_float_3x8 > { typedef index_operator_matrix_access_policy < matrix_float_3x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x8 > { typedef dimension<3> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 9> matrix_float_3x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x9,0> matrix_float_3x9_row0; } template <> struct geometric_traits<detail::matrix_float_3x9_row0> { typedef detail::matrix_float_3x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x9,1> matrix_float_3x9_row1; } template <> struct geometric_traits<detail::matrix_float_3x9_row1> { typedef detail::matrix_float_3x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x9,2> matrix_float_3x9_row2; } template <> struct geometric_traits<detail::matrix_float_3x9_row2> { typedef detail::matrix_float_3x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,0> matrix_float_3x9_column0; }template <> struct geometric_traits<detail::matrix_float_3x9_column0> { typedef detail::matrix_float_3x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,1> matrix_float_3x9_column1; }template <> struct geometric_traits<detail::matrix_float_3x9_column1> { typedef detail::matrix_float_3x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,2> matrix_float_3x9_column2; }template <> struct geometric_traits<detail::matrix_float_3x9_column2> { typedef detail::matrix_float_3x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,3> matrix_float_3x9_column3; }template <> struct geometric_traits<detail::matrix_float_3x9_column3> { typedef detail::matrix_float_3x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,4> matrix_float_3x9_column4; }template <> struct geometric_traits<detail::matrix_float_3x9_column4> { typedef detail::matrix_float_3x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,5> matrix_float_3x9_column5; }template <> struct geometric_traits<detail::matrix_float_3x9_column5> { typedef detail::matrix_float_3x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,6> matrix_float_3x9_column6; }template <> struct geometric_traits<detail::matrix_float_3x9_column6> { typedef detail::matrix_float_3x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,7> matrix_float_3x9_column7; }template <> struct geometric_traits<detail::matrix_float_3x9_column7> { typedef detail::matrix_float_3x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x9,8> matrix_float_3x9_column8; }template <> struct geometric_traits<detail::matrix_float_3x9_column8> { typedef detail::matrix_float_3x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x9>::type > : index_operator_matrix_access_policy < matrix_float_3x9 > { typedef index_operator_matrix_access_policy < matrix_float_3x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x9 > { typedef dimension<3> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 3, 10> matrix_float_3x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x10,0> matrix_float_3x10_row0; } template <> struct geometric_traits<detail::matrix_float_3x10_row0> { typedef detail::matrix_float_3x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x10,1> matrix_float_3x10_row1; } template <> struct geometric_traits<detail::matrix_float_3x10_row1> { typedef detail::matrix_float_3x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_3x10,2> matrix_float_3x10_row2; } template <> struct geometric_traits<detail::matrix_float_3x10_row2> { typedef detail::matrix_float_3x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,0> matrix_float_3x10_column0; }template <> struct geometric_traits<detail::matrix_float_3x10_column0> { typedef detail::matrix_float_3x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,1> matrix_float_3x10_column1; }template <> struct geometric_traits<detail::matrix_float_3x10_column1> { typedef detail::matrix_float_3x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,2> matrix_float_3x10_column2; }template <> struct geometric_traits<detail::matrix_float_3x10_column2> { typedef detail::matrix_float_3x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,3> matrix_float_3x10_column3; }template <> struct geometric_traits<detail::matrix_float_3x10_column3> { typedef detail::matrix_float_3x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,4> matrix_float_3x10_column4; }template <> struct geometric_traits<detail::matrix_float_3x10_column4> { typedef detail::matrix_float_3x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,5> matrix_float_3x10_column5; }template <> struct geometric_traits<detail::matrix_float_3x10_column5> { typedef detail::matrix_float_3x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,6> matrix_float_3x10_column6; }template <> struct geometric_traits<detail::matrix_float_3x10_column6> { typedef detail::matrix_float_3x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,7> matrix_float_3x10_column7; }template <> struct geometric_traits<detail::matrix_float_3x10_column7> { typedef detail::matrix_float_3x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,8> matrix_float_3x10_column8; }template <> struct geometric_traits<detail::matrix_float_3x10_column8> { typedef detail::matrix_float_3x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_3x10,9> matrix_float_3x10_column9; }template <> struct geometric_traits<detail::matrix_float_3x10_column9> { typedef detail::matrix_float_3x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_3x10>::type > : index_operator_matrix_access_policy < matrix_float_3x10 > { typedef index_operator_matrix_access_policy < matrix_float_3x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_3x10 > { typedef dimension<3> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 1> matrix_float_4x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x1,0> matrix_float_4x1_row0; } template <> struct geometric_traits<detail::matrix_float_4x1_row0> { typedef detail::matrix_float_4x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x1,1> matrix_float_4x1_row1; } template <> struct geometric_traits<detail::matrix_float_4x1_row1> { typedef detail::matrix_float_4x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x1,2> matrix_float_4x1_row2; } template <> struct geometric_traits<detail::matrix_float_4x1_row2> { typedef detail::matrix_float_4x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x1,3> matrix_float_4x1_row3; } template <> struct geometric_traits<detail::matrix_float_4x1_row3> { typedef detail::matrix_float_4x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x1,0> matrix_float_4x1_column0; }template <> struct geometric_traits<detail::matrix_float_4x1_column0> { typedef detail::matrix_float_4x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x1>::type > : index_operator_matrix_access_policy < matrix_float_4x1 > { typedef index_operator_matrix_access_policy < matrix_float_4x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x1 > { typedef dimension<4> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 2> matrix_float_4x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x2,0> matrix_float_4x2_row0; } template <> struct geometric_traits<detail::matrix_float_4x2_row0> { typedef detail::matrix_float_4x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x2,1> matrix_float_4x2_row1; } template <> struct geometric_traits<detail::matrix_float_4x2_row1> { typedef detail::matrix_float_4x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x2,2> matrix_float_4x2_row2; } template <> struct geometric_traits<detail::matrix_float_4x2_row2> { typedef detail::matrix_float_4x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x2,3> matrix_float_4x2_row3; } template <> struct geometric_traits<detail::matrix_float_4x2_row3> { typedef detail::matrix_float_4x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x2,0> matrix_float_4x2_column0; }template <> struct geometric_traits<detail::matrix_float_4x2_column0> { typedef detail::matrix_float_4x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x2,1> matrix_float_4x2_column1; }template <> struct geometric_traits<detail::matrix_float_4x2_column1> { typedef detail::matrix_float_4x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x2>::type > : index_operator_matrix_access_policy < matrix_float_4x2 > { typedef index_operator_matrix_access_policy < matrix_float_4x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x2 > { typedef dimension<4> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 3> matrix_float_4x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x3,0> matrix_float_4x3_row0; } template <> struct geometric_traits<detail::matrix_float_4x3_row0> { typedef detail::matrix_float_4x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x3,1> matrix_float_4x3_row1; } template <> struct geometric_traits<detail::matrix_float_4x3_row1> { typedef detail::matrix_float_4x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x3,2> matrix_float_4x3_row2; } template <> struct geometric_traits<detail::matrix_float_4x3_row2> { typedef detail::matrix_float_4x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x3,3> matrix_float_4x3_row3; } template <> struct geometric_traits<detail::matrix_float_4x3_row3> { typedef detail::matrix_float_4x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x3,0> matrix_float_4x3_column0; }template <> struct geometric_traits<detail::matrix_float_4x3_column0> { typedef detail::matrix_float_4x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x3,1> matrix_float_4x3_column1; }template <> struct geometric_traits<detail::matrix_float_4x3_column1> { typedef detail::matrix_float_4x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x3,2> matrix_float_4x3_column2; }template <> struct geometric_traits<detail::matrix_float_4x3_column2> { typedef detail::matrix_float_4x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x3>::type > : index_operator_matrix_access_policy < matrix_float_4x3 > { typedef index_operator_matrix_access_policy < matrix_float_4x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x3 > { typedef dimension<4> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 4> matrix_float_4x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x4,0> matrix_float_4x4_row0; } template <> struct geometric_traits<detail::matrix_float_4x4_row0> { typedef detail::matrix_float_4x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x4,1> matrix_float_4x4_row1; } template <> struct geometric_traits<detail::matrix_float_4x4_row1> { typedef detail::matrix_float_4x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x4,2> matrix_float_4x4_row2; } template <> struct geometric_traits<detail::matrix_float_4x4_row2> { typedef detail::matrix_float_4x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x4,3> matrix_float_4x4_row3; } template <> struct geometric_traits<detail::matrix_float_4x4_row3> { typedef detail::matrix_float_4x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x4,0> matrix_float_4x4_column0; }template <> struct geometric_traits<detail::matrix_float_4x4_column0> { typedef detail::matrix_float_4x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x4,1> matrix_float_4x4_column1; }template <> struct geometric_traits<detail::matrix_float_4x4_column1> { typedef detail::matrix_float_4x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x4,2> matrix_float_4x4_column2; }template <> struct geometric_traits<detail::matrix_float_4x4_column2> { typedef detail::matrix_float_4x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x4,3> matrix_float_4x4_column3; }template <> struct geometric_traits<detail::matrix_float_4x4_column3> { typedef detail::matrix_float_4x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x4>::type > : index_operator_matrix_access_policy < matrix_float_4x4 > { typedef index_operator_matrix_access_policy < matrix_float_4x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x4 > { typedef dimension<4> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 5> matrix_float_4x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x5,0> matrix_float_4x5_row0; } template <> struct geometric_traits<detail::matrix_float_4x5_row0> { typedef detail::matrix_float_4x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x5,1> matrix_float_4x5_row1; } template <> struct geometric_traits<detail::matrix_float_4x5_row1> { typedef detail::matrix_float_4x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x5,2> matrix_float_4x5_row2; } template <> struct geometric_traits<detail::matrix_float_4x5_row2> { typedef detail::matrix_float_4x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x5,3> matrix_float_4x5_row3; } template <> struct geometric_traits<detail::matrix_float_4x5_row3> { typedef detail::matrix_float_4x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x5,0> matrix_float_4x5_column0; }template <> struct geometric_traits<detail::matrix_float_4x5_column0> { typedef detail::matrix_float_4x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x5,1> matrix_float_4x5_column1; }template <> struct geometric_traits<detail::matrix_float_4x5_column1> { typedef detail::matrix_float_4x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x5,2> matrix_float_4x5_column2; }template <> struct geometric_traits<detail::matrix_float_4x5_column2> { typedef detail::matrix_float_4x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x5,3> matrix_float_4x5_column3; }template <> struct geometric_traits<detail::matrix_float_4x5_column3> { typedef detail::matrix_float_4x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x5,4> matrix_float_4x5_column4; }template <> struct geometric_traits<detail::matrix_float_4x5_column4> { typedef detail::matrix_float_4x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x5>::type > : index_operator_matrix_access_policy < matrix_float_4x5 > { typedef index_operator_matrix_access_policy < matrix_float_4x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x5 > { typedef dimension<4> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 6> matrix_float_4x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x6,0> matrix_float_4x6_row0; } template <> struct geometric_traits<detail::matrix_float_4x6_row0> { typedef detail::matrix_float_4x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x6,1> matrix_float_4x6_row1; } template <> struct geometric_traits<detail::matrix_float_4x6_row1> { typedef detail::matrix_float_4x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x6,2> matrix_float_4x6_row2; } template <> struct geometric_traits<detail::matrix_float_4x6_row2> { typedef detail::matrix_float_4x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x6,3> matrix_float_4x6_row3; } template <> struct geometric_traits<detail::matrix_float_4x6_row3> { typedef detail::matrix_float_4x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,0> matrix_float_4x6_column0; }template <> struct geometric_traits<detail::matrix_float_4x6_column0> { typedef detail::matrix_float_4x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,1> matrix_float_4x6_column1; }template <> struct geometric_traits<detail::matrix_float_4x6_column1> { typedef detail::matrix_float_4x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,2> matrix_float_4x6_column2; }template <> struct geometric_traits<detail::matrix_float_4x6_column2> { typedef detail::matrix_float_4x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,3> matrix_float_4x6_column3; }template <> struct geometric_traits<detail::matrix_float_4x6_column3> { typedef detail::matrix_float_4x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,4> matrix_float_4x6_column4; }template <> struct geometric_traits<detail::matrix_float_4x6_column4> { typedef detail::matrix_float_4x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x6,5> matrix_float_4x6_column5; }template <> struct geometric_traits<detail::matrix_float_4x6_column5> { typedef detail::matrix_float_4x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x6>::type > : index_operator_matrix_access_policy < matrix_float_4x6 > { typedef index_operator_matrix_access_policy < matrix_float_4x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x6 > { typedef dimension<4> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 7> matrix_float_4x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x7,0> matrix_float_4x7_row0; } template <> struct geometric_traits<detail::matrix_float_4x7_row0> { typedef detail::matrix_float_4x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x7,1> matrix_float_4x7_row1; } template <> struct geometric_traits<detail::matrix_float_4x7_row1> { typedef detail::matrix_float_4x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x7,2> matrix_float_4x7_row2; } template <> struct geometric_traits<detail::matrix_float_4x7_row2> { typedef detail::matrix_float_4x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x7,3> matrix_float_4x7_row3; } template <> struct geometric_traits<detail::matrix_float_4x7_row3> { typedef detail::matrix_float_4x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,0> matrix_float_4x7_column0; }template <> struct geometric_traits<detail::matrix_float_4x7_column0> { typedef detail::matrix_float_4x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,1> matrix_float_4x7_column1; }template <> struct geometric_traits<detail::matrix_float_4x7_column1> { typedef detail::matrix_float_4x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,2> matrix_float_4x7_column2; }template <> struct geometric_traits<detail::matrix_float_4x7_column2> { typedef detail::matrix_float_4x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,3> matrix_float_4x7_column3; }template <> struct geometric_traits<detail::matrix_float_4x7_column3> { typedef detail::matrix_float_4x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,4> matrix_float_4x7_column4; }template <> struct geometric_traits<detail::matrix_float_4x7_column4> { typedef detail::matrix_float_4x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,5> matrix_float_4x7_column5; }template <> struct geometric_traits<detail::matrix_float_4x7_column5> { typedef detail::matrix_float_4x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x7,6> matrix_float_4x7_column6; }template <> struct geometric_traits<detail::matrix_float_4x7_column6> { typedef detail::matrix_float_4x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x7>::type > : index_operator_matrix_access_policy < matrix_float_4x7 > { typedef index_operator_matrix_access_policy < matrix_float_4x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x7 > { typedef dimension<4> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 8> matrix_float_4x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x8,0> matrix_float_4x8_row0; } template <> struct geometric_traits<detail::matrix_float_4x8_row0> { typedef detail::matrix_float_4x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x8,1> matrix_float_4x8_row1; } template <> struct geometric_traits<detail::matrix_float_4x8_row1> { typedef detail::matrix_float_4x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x8,2> matrix_float_4x8_row2; } template <> struct geometric_traits<detail::matrix_float_4x8_row2> { typedef detail::matrix_float_4x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x8,3> matrix_float_4x8_row3; } template <> struct geometric_traits<detail::matrix_float_4x8_row3> { typedef detail::matrix_float_4x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,0> matrix_float_4x8_column0; }template <> struct geometric_traits<detail::matrix_float_4x8_column0> { typedef detail::matrix_float_4x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,1> matrix_float_4x8_column1; }template <> struct geometric_traits<detail::matrix_float_4x8_column1> { typedef detail::matrix_float_4x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,2> matrix_float_4x8_column2; }template <> struct geometric_traits<detail::matrix_float_4x8_column2> { typedef detail::matrix_float_4x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,3> matrix_float_4x8_column3; }template <> struct geometric_traits<detail::matrix_float_4x8_column3> { typedef detail::matrix_float_4x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,4> matrix_float_4x8_column4; }template <> struct geometric_traits<detail::matrix_float_4x8_column4> { typedef detail::matrix_float_4x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,5> matrix_float_4x8_column5; }template <> struct geometric_traits<detail::matrix_float_4x8_column5> { typedef detail::matrix_float_4x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,6> matrix_float_4x8_column6; }template <> struct geometric_traits<detail::matrix_float_4x8_column6> { typedef detail::matrix_float_4x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x8,7> matrix_float_4x8_column7; }template <> struct geometric_traits<detail::matrix_float_4x8_column7> { typedef detail::matrix_float_4x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x8>::type > : index_operator_matrix_access_policy < matrix_float_4x8 > { typedef index_operator_matrix_access_policy < matrix_float_4x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x8 > { typedef dimension<4> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 9> matrix_float_4x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x9,0> matrix_float_4x9_row0; } template <> struct geometric_traits<detail::matrix_float_4x9_row0> { typedef detail::matrix_float_4x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x9,1> matrix_float_4x9_row1; } template <> struct geometric_traits<detail::matrix_float_4x9_row1> { typedef detail::matrix_float_4x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x9,2> matrix_float_4x9_row2; } template <> struct geometric_traits<detail::matrix_float_4x9_row2> { typedef detail::matrix_float_4x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x9,3> matrix_float_4x9_row3; } template <> struct geometric_traits<detail::matrix_float_4x9_row3> { typedef detail::matrix_float_4x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,0> matrix_float_4x9_column0; }template <> struct geometric_traits<detail::matrix_float_4x9_column0> { typedef detail::matrix_float_4x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,1> matrix_float_4x9_column1; }template <> struct geometric_traits<detail::matrix_float_4x9_column1> { typedef detail::matrix_float_4x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,2> matrix_float_4x9_column2; }template <> struct geometric_traits<detail::matrix_float_4x9_column2> { typedef detail::matrix_float_4x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,3> matrix_float_4x9_column3; }template <> struct geometric_traits<detail::matrix_float_4x9_column3> { typedef detail::matrix_float_4x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,4> matrix_float_4x9_column4; }template <> struct geometric_traits<detail::matrix_float_4x9_column4> { typedef detail::matrix_float_4x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,5> matrix_float_4x9_column5; }template <> struct geometric_traits<detail::matrix_float_4x9_column5> { typedef detail::matrix_float_4x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,6> matrix_float_4x9_column6; }template <> struct geometric_traits<detail::matrix_float_4x9_column6> { typedef detail::matrix_float_4x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,7> matrix_float_4x9_column7; }template <> struct geometric_traits<detail::matrix_float_4x9_column7> { typedef detail::matrix_float_4x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x9,8> matrix_float_4x9_column8; }template <> struct geometric_traits<detail::matrix_float_4x9_column8> { typedef detail::matrix_float_4x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x9>::type > : index_operator_matrix_access_policy < matrix_float_4x9 > { typedef index_operator_matrix_access_policy < matrix_float_4x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x9 > { typedef dimension<4> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 4, 10> matrix_float_4x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x10,0> matrix_float_4x10_row0; } template <> struct geometric_traits<detail::matrix_float_4x10_row0> { typedef detail::matrix_float_4x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x10,1> matrix_float_4x10_row1; } template <> struct geometric_traits<detail::matrix_float_4x10_row1> { typedef detail::matrix_float_4x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x10,2> matrix_float_4x10_row2; } template <> struct geometric_traits<detail::matrix_float_4x10_row2> { typedef detail::matrix_float_4x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_4x10,3> matrix_float_4x10_row3; } template <> struct geometric_traits<detail::matrix_float_4x10_row3> { typedef detail::matrix_float_4x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,0> matrix_float_4x10_column0; }template <> struct geometric_traits<detail::matrix_float_4x10_column0> { typedef detail::matrix_float_4x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,1> matrix_float_4x10_column1; }template <> struct geometric_traits<detail::matrix_float_4x10_column1> { typedef detail::matrix_float_4x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,2> matrix_float_4x10_column2; }template <> struct geometric_traits<detail::matrix_float_4x10_column2> { typedef detail::matrix_float_4x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,3> matrix_float_4x10_column3; }template <> struct geometric_traits<detail::matrix_float_4x10_column3> { typedef detail::matrix_float_4x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,4> matrix_float_4x10_column4; }template <> struct geometric_traits<detail::matrix_float_4x10_column4> { typedef detail::matrix_float_4x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,5> matrix_float_4x10_column5; }template <> struct geometric_traits<detail::matrix_float_4x10_column5> { typedef detail::matrix_float_4x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,6> matrix_float_4x10_column6; }template <> struct geometric_traits<detail::matrix_float_4x10_column6> { typedef detail::matrix_float_4x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,7> matrix_float_4x10_column7; }template <> struct geometric_traits<detail::matrix_float_4x10_column7> { typedef detail::matrix_float_4x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,8> matrix_float_4x10_column8; }template <> struct geometric_traits<detail::matrix_float_4x10_column8> { typedef detail::matrix_float_4x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_4x10,9> matrix_float_4x10_column9; }template <> struct geometric_traits<detail::matrix_float_4x10_column9> { typedef detail::matrix_float_4x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_4x10>::type > : index_operator_matrix_access_policy < matrix_float_4x10 > { typedef index_operator_matrix_access_policy < matrix_float_4x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_4x10 > { typedef dimension<4> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 1> matrix_float_5x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x1,0> matrix_float_5x1_row0; } template <> struct geometric_traits<detail::matrix_float_5x1_row0> { typedef detail::matrix_float_5x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x1,1> matrix_float_5x1_row1; } template <> struct geometric_traits<detail::matrix_float_5x1_row1> { typedef detail::matrix_float_5x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x1,2> matrix_float_5x1_row2; } template <> struct geometric_traits<detail::matrix_float_5x1_row2> { typedef detail::matrix_float_5x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x1,3> matrix_float_5x1_row3; } template <> struct geometric_traits<detail::matrix_float_5x1_row3> { typedef detail::matrix_float_5x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x1,4> matrix_float_5x1_row4; } template <> struct geometric_traits<detail::matrix_float_5x1_row4> { typedef detail::matrix_float_5x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x1,0> matrix_float_5x1_column0; }template <> struct geometric_traits<detail::matrix_float_5x1_column0> { typedef detail::matrix_float_5x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x1>::type > : index_operator_matrix_access_policy < matrix_float_5x1 > { typedef index_operator_matrix_access_policy < matrix_float_5x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x1 > { typedef dimension<5> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 2> matrix_float_5x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x2,0> matrix_float_5x2_row0; } template <> struct geometric_traits<detail::matrix_float_5x2_row0> { typedef detail::matrix_float_5x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x2,1> matrix_float_5x2_row1; } template <> struct geometric_traits<detail::matrix_float_5x2_row1> { typedef detail::matrix_float_5x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x2,2> matrix_float_5x2_row2; } template <> struct geometric_traits<detail::matrix_float_5x2_row2> { typedef detail::matrix_float_5x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x2,3> matrix_float_5x2_row3; } template <> struct geometric_traits<detail::matrix_float_5x2_row3> { typedef detail::matrix_float_5x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x2,4> matrix_float_5x2_row4; } template <> struct geometric_traits<detail::matrix_float_5x2_row4> { typedef detail::matrix_float_5x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x2,0> matrix_float_5x2_column0; }template <> struct geometric_traits<detail::matrix_float_5x2_column0> { typedef detail::matrix_float_5x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x2,1> matrix_float_5x2_column1; }template <> struct geometric_traits<detail::matrix_float_5x2_column1> { typedef detail::matrix_float_5x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x2>::type > : index_operator_matrix_access_policy < matrix_float_5x2 > { typedef index_operator_matrix_access_policy < matrix_float_5x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x2 > { typedef dimension<5> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 3> matrix_float_5x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x3,0> matrix_float_5x3_row0; } template <> struct geometric_traits<detail::matrix_float_5x3_row0> { typedef detail::matrix_float_5x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x3,1> matrix_float_5x3_row1; } template <> struct geometric_traits<detail::matrix_float_5x3_row1> { typedef detail::matrix_float_5x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x3,2> matrix_float_5x3_row2; } template <> struct geometric_traits<detail::matrix_float_5x3_row2> { typedef detail::matrix_float_5x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x3,3> matrix_float_5x3_row3; } template <> struct geometric_traits<detail::matrix_float_5x3_row3> { typedef detail::matrix_float_5x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x3,4> matrix_float_5x3_row4; } template <> struct geometric_traits<detail::matrix_float_5x3_row4> { typedef detail::matrix_float_5x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x3,0> matrix_float_5x3_column0; }template <> struct geometric_traits<detail::matrix_float_5x3_column0> { typedef detail::matrix_float_5x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x3,1> matrix_float_5x3_column1; }template <> struct geometric_traits<detail::matrix_float_5x3_column1> { typedef detail::matrix_float_5x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x3,2> matrix_float_5x3_column2; }template <> struct geometric_traits<detail::matrix_float_5x3_column2> { typedef detail::matrix_float_5x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x3>::type > : index_operator_matrix_access_policy < matrix_float_5x3 > { typedef index_operator_matrix_access_policy < matrix_float_5x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x3 > { typedef dimension<5> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 4> matrix_float_5x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x4,0> matrix_float_5x4_row0; } template <> struct geometric_traits<detail::matrix_float_5x4_row0> { typedef detail::matrix_float_5x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x4,1> matrix_float_5x4_row1; } template <> struct geometric_traits<detail::matrix_float_5x4_row1> { typedef detail::matrix_float_5x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x4,2> matrix_float_5x4_row2; } template <> struct geometric_traits<detail::matrix_float_5x4_row2> { typedef detail::matrix_float_5x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x4,3> matrix_float_5x4_row3; } template <> struct geometric_traits<detail::matrix_float_5x4_row3> { typedef detail::matrix_float_5x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x4,4> matrix_float_5x4_row4; } template <> struct geometric_traits<detail::matrix_float_5x4_row4> { typedef detail::matrix_float_5x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x4,0> matrix_float_5x4_column0; }template <> struct geometric_traits<detail::matrix_float_5x4_column0> { typedef detail::matrix_float_5x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x4,1> matrix_float_5x4_column1; }template <> struct geometric_traits<detail::matrix_float_5x4_column1> { typedef detail::matrix_float_5x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x4,2> matrix_float_5x4_column2; }template <> struct geometric_traits<detail::matrix_float_5x4_column2> { typedef detail::matrix_float_5x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x4,3> matrix_float_5x4_column3; }template <> struct geometric_traits<detail::matrix_float_5x4_column3> { typedef detail::matrix_float_5x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x4>::type > : index_operator_matrix_access_policy < matrix_float_5x4 > { typedef index_operator_matrix_access_policy < matrix_float_5x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x4 > { typedef dimension<5> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 5> matrix_float_5x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x5,0> matrix_float_5x5_row0; } template <> struct geometric_traits<detail::matrix_float_5x5_row0> { typedef detail::matrix_float_5x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x5,1> matrix_float_5x5_row1; } template <> struct geometric_traits<detail::matrix_float_5x5_row1> { typedef detail::matrix_float_5x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x5,2> matrix_float_5x5_row2; } template <> struct geometric_traits<detail::matrix_float_5x5_row2> { typedef detail::matrix_float_5x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x5,3> matrix_float_5x5_row3; } template <> struct geometric_traits<detail::matrix_float_5x5_row3> { typedef detail::matrix_float_5x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x5,4> matrix_float_5x5_row4; } template <> struct geometric_traits<detail::matrix_float_5x5_row4> { typedef detail::matrix_float_5x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x5,0> matrix_float_5x5_column0; }template <> struct geometric_traits<detail::matrix_float_5x5_column0> { typedef detail::matrix_float_5x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x5,1> matrix_float_5x5_column1; }template <> struct geometric_traits<detail::matrix_float_5x5_column1> { typedef detail::matrix_float_5x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x5,2> matrix_float_5x5_column2; }template <> struct geometric_traits<detail::matrix_float_5x5_column2> { typedef detail::matrix_float_5x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x5,3> matrix_float_5x5_column3; }template <> struct geometric_traits<detail::matrix_float_5x5_column3> { typedef detail::matrix_float_5x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x5,4> matrix_float_5x5_column4; }template <> struct geometric_traits<detail::matrix_float_5x5_column4> { typedef detail::matrix_float_5x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x5>::type > : index_operator_matrix_access_policy < matrix_float_5x5 > { typedef index_operator_matrix_access_policy < matrix_float_5x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x5 > { typedef dimension<5> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 6> matrix_float_5x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x6,0> matrix_float_5x6_row0; } template <> struct geometric_traits<detail::matrix_float_5x6_row0> { typedef detail::matrix_float_5x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x6,1> matrix_float_5x6_row1; } template <> struct geometric_traits<detail::matrix_float_5x6_row1> { typedef detail::matrix_float_5x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x6,2> matrix_float_5x6_row2; } template <> struct geometric_traits<detail::matrix_float_5x6_row2> { typedef detail::matrix_float_5x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x6,3> matrix_float_5x6_row3; } template <> struct geometric_traits<detail::matrix_float_5x6_row3> { typedef detail::matrix_float_5x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x6,4> matrix_float_5x6_row4; } template <> struct geometric_traits<detail::matrix_float_5x6_row4> { typedef detail::matrix_float_5x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,0> matrix_float_5x6_column0; }template <> struct geometric_traits<detail::matrix_float_5x6_column0> { typedef detail::matrix_float_5x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,1> matrix_float_5x6_column1; }template <> struct geometric_traits<detail::matrix_float_5x6_column1> { typedef detail::matrix_float_5x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,2> matrix_float_5x6_column2; }template <> struct geometric_traits<detail::matrix_float_5x6_column2> { typedef detail::matrix_float_5x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,3> matrix_float_5x6_column3; }template <> struct geometric_traits<detail::matrix_float_5x6_column3> { typedef detail::matrix_float_5x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,4> matrix_float_5x6_column4; }template <> struct geometric_traits<detail::matrix_float_5x6_column4> { typedef detail::matrix_float_5x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x6,5> matrix_float_5x6_column5; }template <> struct geometric_traits<detail::matrix_float_5x6_column5> { typedef detail::matrix_float_5x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x6>::type > : index_operator_matrix_access_policy < matrix_float_5x6 > { typedef index_operator_matrix_access_policy < matrix_float_5x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x6 > { typedef dimension<5> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 7> matrix_float_5x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x7,0> matrix_float_5x7_row0; } template <> struct geometric_traits<detail::matrix_float_5x7_row0> { typedef detail::matrix_float_5x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x7,1> matrix_float_5x7_row1; } template <> struct geometric_traits<detail::matrix_float_5x7_row1> { typedef detail::matrix_float_5x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x7,2> matrix_float_5x7_row2; } template <> struct geometric_traits<detail::matrix_float_5x7_row2> { typedef detail::matrix_float_5x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x7,3> matrix_float_5x7_row3; } template <> struct geometric_traits<detail::matrix_float_5x7_row3> { typedef detail::matrix_float_5x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x7,4> matrix_float_5x7_row4; } template <> struct geometric_traits<detail::matrix_float_5x7_row4> { typedef detail::matrix_float_5x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,0> matrix_float_5x7_column0; }template <> struct geometric_traits<detail::matrix_float_5x7_column0> { typedef detail::matrix_float_5x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,1> matrix_float_5x7_column1; }template <> struct geometric_traits<detail::matrix_float_5x7_column1> { typedef detail::matrix_float_5x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,2> matrix_float_5x7_column2; }template <> struct geometric_traits<detail::matrix_float_5x7_column2> { typedef detail::matrix_float_5x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,3> matrix_float_5x7_column3; }template <> struct geometric_traits<detail::matrix_float_5x7_column3> { typedef detail::matrix_float_5x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,4> matrix_float_5x7_column4; }template <> struct geometric_traits<detail::matrix_float_5x7_column4> { typedef detail::matrix_float_5x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,5> matrix_float_5x7_column5; }template <> struct geometric_traits<detail::matrix_float_5x7_column5> { typedef detail::matrix_float_5x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x7,6> matrix_float_5x7_column6; }template <> struct geometric_traits<detail::matrix_float_5x7_column6> { typedef detail::matrix_float_5x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x7>::type > : index_operator_matrix_access_policy < matrix_float_5x7 > { typedef index_operator_matrix_access_policy < matrix_float_5x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x7 > { typedef dimension<5> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 8> matrix_float_5x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x8,0> matrix_float_5x8_row0; } template <> struct geometric_traits<detail::matrix_float_5x8_row0> { typedef detail::matrix_float_5x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x8,1> matrix_float_5x8_row1; } template <> struct geometric_traits<detail::matrix_float_5x8_row1> { typedef detail::matrix_float_5x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x8,2> matrix_float_5x8_row2; } template <> struct geometric_traits<detail::matrix_float_5x8_row2> { typedef detail::matrix_float_5x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x8,3> matrix_float_5x8_row3; } template <> struct geometric_traits<detail::matrix_float_5x8_row3> { typedef detail::matrix_float_5x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x8,4> matrix_float_5x8_row4; } template <> struct geometric_traits<detail::matrix_float_5x8_row4> { typedef detail::matrix_float_5x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,0> matrix_float_5x8_column0; }template <> struct geometric_traits<detail::matrix_float_5x8_column0> { typedef detail::matrix_float_5x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,1> matrix_float_5x8_column1; }template <> struct geometric_traits<detail::matrix_float_5x8_column1> { typedef detail::matrix_float_5x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,2> matrix_float_5x8_column2; }template <> struct geometric_traits<detail::matrix_float_5x8_column2> { typedef detail::matrix_float_5x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,3> matrix_float_5x8_column3; }template <> struct geometric_traits<detail::matrix_float_5x8_column3> { typedef detail::matrix_float_5x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,4> matrix_float_5x8_column4; }template <> struct geometric_traits<detail::matrix_float_5x8_column4> { typedef detail::matrix_float_5x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,5> matrix_float_5x8_column5; }template <> struct geometric_traits<detail::matrix_float_5x8_column5> { typedef detail::matrix_float_5x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,6> matrix_float_5x8_column6; }template <> struct geometric_traits<detail::matrix_float_5x8_column6> { typedef detail::matrix_float_5x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x8,7> matrix_float_5x8_column7; }template <> struct geometric_traits<detail::matrix_float_5x8_column7> { typedef detail::matrix_float_5x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x8>::type > : index_operator_matrix_access_policy < matrix_float_5x8 > { typedef index_operator_matrix_access_policy < matrix_float_5x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x8 > { typedef dimension<5> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 9> matrix_float_5x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x9,0> matrix_float_5x9_row0; } template <> struct geometric_traits<detail::matrix_float_5x9_row0> { typedef detail::matrix_float_5x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x9,1> matrix_float_5x9_row1; } template <> struct geometric_traits<detail::matrix_float_5x9_row1> { typedef detail::matrix_float_5x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x9,2> matrix_float_5x9_row2; } template <> struct geometric_traits<detail::matrix_float_5x9_row2> { typedef detail::matrix_float_5x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x9,3> matrix_float_5x9_row3; } template <> struct geometric_traits<detail::matrix_float_5x9_row3> { typedef detail::matrix_float_5x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x9,4> matrix_float_5x9_row4; } template <> struct geometric_traits<detail::matrix_float_5x9_row4> { typedef detail::matrix_float_5x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,0> matrix_float_5x9_column0; }template <> struct geometric_traits<detail::matrix_float_5x9_column0> { typedef detail::matrix_float_5x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,1> matrix_float_5x9_column1; }template <> struct geometric_traits<detail::matrix_float_5x9_column1> { typedef detail::matrix_float_5x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,2> matrix_float_5x9_column2; }template <> struct geometric_traits<detail::matrix_float_5x9_column2> { typedef detail::matrix_float_5x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,3> matrix_float_5x9_column3; }template <> struct geometric_traits<detail::matrix_float_5x9_column3> { typedef detail::matrix_float_5x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,4> matrix_float_5x9_column4; }template <> struct geometric_traits<detail::matrix_float_5x9_column4> { typedef detail::matrix_float_5x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,5> matrix_float_5x9_column5; }template <> struct geometric_traits<detail::matrix_float_5x9_column5> { typedef detail::matrix_float_5x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,6> matrix_float_5x9_column6; }template <> struct geometric_traits<detail::matrix_float_5x9_column6> { typedef detail::matrix_float_5x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,7> matrix_float_5x9_column7; }template <> struct geometric_traits<detail::matrix_float_5x9_column7> { typedef detail::matrix_float_5x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x9,8> matrix_float_5x9_column8; }template <> struct geometric_traits<detail::matrix_float_5x9_column8> { typedef detail::matrix_float_5x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x9>::type > : index_operator_matrix_access_policy < matrix_float_5x9 > { typedef index_operator_matrix_access_policy < matrix_float_5x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x9 > { typedef dimension<5> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 5, 10> matrix_float_5x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x10,0> matrix_float_5x10_row0; } template <> struct geometric_traits<detail::matrix_float_5x10_row0> { typedef detail::matrix_float_5x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x10,1> matrix_float_5x10_row1; } template <> struct geometric_traits<detail::matrix_float_5x10_row1> { typedef detail::matrix_float_5x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x10,2> matrix_float_5x10_row2; } template <> struct geometric_traits<detail::matrix_float_5x10_row2> { typedef detail::matrix_float_5x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x10,3> matrix_float_5x10_row3; } template <> struct geometric_traits<detail::matrix_float_5x10_row3> { typedef detail::matrix_float_5x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_5x10,4> matrix_float_5x10_row4; } template <> struct geometric_traits<detail::matrix_float_5x10_row4> { typedef detail::matrix_float_5x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,0> matrix_float_5x10_column0; }template <> struct geometric_traits<detail::matrix_float_5x10_column0> { typedef detail::matrix_float_5x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,1> matrix_float_5x10_column1; }template <> struct geometric_traits<detail::matrix_float_5x10_column1> { typedef detail::matrix_float_5x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,2> matrix_float_5x10_column2; }template <> struct geometric_traits<detail::matrix_float_5x10_column2> { typedef detail::matrix_float_5x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,3> matrix_float_5x10_column3; }template <> struct geometric_traits<detail::matrix_float_5x10_column3> { typedef detail::matrix_float_5x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,4> matrix_float_5x10_column4; }template <> struct geometric_traits<detail::matrix_float_5x10_column4> { typedef detail::matrix_float_5x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,5> matrix_float_5x10_column5; }template <> struct geometric_traits<detail::matrix_float_5x10_column5> { typedef detail::matrix_float_5x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,6> matrix_float_5x10_column6; }template <> struct geometric_traits<detail::matrix_float_5x10_column6> { typedef detail::matrix_float_5x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,7> matrix_float_5x10_column7; }template <> struct geometric_traits<detail::matrix_float_5x10_column7> { typedef detail::matrix_float_5x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,8> matrix_float_5x10_column8; }template <> struct geometric_traits<detail::matrix_float_5x10_column8> { typedef detail::matrix_float_5x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_5x10,9> matrix_float_5x10_column9; }template <> struct geometric_traits<detail::matrix_float_5x10_column9> { typedef detail::matrix_float_5x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_5x10>::type > : index_operator_matrix_access_policy < matrix_float_5x10 > { typedef index_operator_matrix_access_policy < matrix_float_5x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_5x10 > { typedef dimension<5> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 1> matrix_float_6x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,0> matrix_float_6x1_row0; } template <> struct geometric_traits<detail::matrix_float_6x1_row0> { typedef detail::matrix_float_6x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,1> matrix_float_6x1_row1; } template <> struct geometric_traits<detail::matrix_float_6x1_row1> { typedef detail::matrix_float_6x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,2> matrix_float_6x1_row2; } template <> struct geometric_traits<detail::matrix_float_6x1_row2> { typedef detail::matrix_float_6x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,3> matrix_float_6x1_row3; } template <> struct geometric_traits<detail::matrix_float_6x1_row3> { typedef detail::matrix_float_6x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,4> matrix_float_6x1_row4; } template <> struct geometric_traits<detail::matrix_float_6x1_row4> { typedef detail::matrix_float_6x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x1,5> matrix_float_6x1_row5; } template <> struct geometric_traits<detail::matrix_float_6x1_row5> { typedef detail::matrix_float_6x1_row5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x1,0> matrix_float_6x1_column0; }template <> struct geometric_traits<detail::matrix_float_6x1_column0> { typedef detail::matrix_float_6x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x1>::type > : index_operator_matrix_access_policy < matrix_float_6x1 > { typedef index_operator_matrix_access_policy < matrix_float_6x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x1 > { typedef dimension<6> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 2> matrix_float_6x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,0> matrix_float_6x2_row0; } template <> struct geometric_traits<detail::matrix_float_6x2_row0> { typedef detail::matrix_float_6x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,1> matrix_float_6x2_row1; } template <> struct geometric_traits<detail::matrix_float_6x2_row1> { typedef detail::matrix_float_6x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,2> matrix_float_6x2_row2; } template <> struct geometric_traits<detail::matrix_float_6x2_row2> { typedef detail::matrix_float_6x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,3> matrix_float_6x2_row3; } template <> struct geometric_traits<detail::matrix_float_6x2_row3> { typedef detail::matrix_float_6x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,4> matrix_float_6x2_row4; } template <> struct geometric_traits<detail::matrix_float_6x2_row4> { typedef detail::matrix_float_6x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x2,5> matrix_float_6x2_row5; } template <> struct geometric_traits<detail::matrix_float_6x2_row5> { typedef detail::matrix_float_6x2_row5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x2,0> matrix_float_6x2_column0; }template <> struct geometric_traits<detail::matrix_float_6x2_column0> { typedef detail::matrix_float_6x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x2,1> matrix_float_6x2_column1; }template <> struct geometric_traits<detail::matrix_float_6x2_column1> { typedef detail::matrix_float_6x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x2>::type > : index_operator_matrix_access_policy < matrix_float_6x2 > { typedef index_operator_matrix_access_policy < matrix_float_6x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x2 > { typedef dimension<6> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 3> matrix_float_6x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,0> matrix_float_6x3_row0; } template <> struct geometric_traits<detail::matrix_float_6x3_row0> { typedef detail::matrix_float_6x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,1> matrix_float_6x3_row1; } template <> struct geometric_traits<detail::matrix_float_6x3_row1> { typedef detail::matrix_float_6x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,2> matrix_float_6x3_row2; } template <> struct geometric_traits<detail::matrix_float_6x3_row2> { typedef detail::matrix_float_6x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,3> matrix_float_6x3_row3; } template <> struct geometric_traits<detail::matrix_float_6x3_row3> { typedef detail::matrix_float_6x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,4> matrix_float_6x3_row4; } template <> struct geometric_traits<detail::matrix_float_6x3_row4> { typedef detail::matrix_float_6x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x3,5> matrix_float_6x3_row5; } template <> struct geometric_traits<detail::matrix_float_6x3_row5> { typedef detail::matrix_float_6x3_row5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x3,0> matrix_float_6x3_column0; }template <> struct geometric_traits<detail::matrix_float_6x3_column0> { typedef detail::matrix_float_6x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x3,1> matrix_float_6x3_column1; }template <> struct geometric_traits<detail::matrix_float_6x3_column1> { typedef detail::matrix_float_6x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x3,2> matrix_float_6x3_column2; }template <> struct geometric_traits<detail::matrix_float_6x3_column2> { typedef detail::matrix_float_6x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x3>::type > : index_operator_matrix_access_policy < matrix_float_6x3 > { typedef index_operator_matrix_access_policy < matrix_float_6x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x3 > { typedef dimension<6> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 4> matrix_float_6x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,0> matrix_float_6x4_row0; } template <> struct geometric_traits<detail::matrix_float_6x4_row0> { typedef detail::matrix_float_6x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,1> matrix_float_6x4_row1; } template <> struct geometric_traits<detail::matrix_float_6x4_row1> { typedef detail::matrix_float_6x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,2> matrix_float_6x4_row2; } template <> struct geometric_traits<detail::matrix_float_6x4_row2> { typedef detail::matrix_float_6x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,3> matrix_float_6x4_row3; } template <> struct geometric_traits<detail::matrix_float_6x4_row3> { typedef detail::matrix_float_6x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,4> matrix_float_6x4_row4; } template <> struct geometric_traits<detail::matrix_float_6x4_row4> { typedef detail::matrix_float_6x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x4,5> matrix_float_6x4_row5; } template <> struct geometric_traits<detail::matrix_float_6x4_row5> { typedef detail::matrix_float_6x4_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x4,0> matrix_float_6x4_column0; }template <> struct geometric_traits<detail::matrix_float_6x4_column0> { typedef detail::matrix_float_6x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x4,1> matrix_float_6x4_column1; }template <> struct geometric_traits<detail::matrix_float_6x4_column1> { typedef detail::matrix_float_6x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x4,2> matrix_float_6x4_column2; }template <> struct geometric_traits<detail::matrix_float_6x4_column2> { typedef detail::matrix_float_6x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x4,3> matrix_float_6x4_column3; }template <> struct geometric_traits<detail::matrix_float_6x4_column3> { typedef detail::matrix_float_6x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x4>::type > : index_operator_matrix_access_policy < matrix_float_6x4 > { typedef index_operator_matrix_access_policy < matrix_float_6x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x4 > { typedef dimension<6> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 5> matrix_float_6x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,0> matrix_float_6x5_row0; } template <> struct geometric_traits<detail::matrix_float_6x5_row0> { typedef detail::matrix_float_6x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,1> matrix_float_6x5_row1; } template <> struct geometric_traits<detail::matrix_float_6x5_row1> { typedef detail::matrix_float_6x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,2> matrix_float_6x5_row2; } template <> struct geometric_traits<detail::matrix_float_6x5_row2> { typedef detail::matrix_float_6x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,3> matrix_float_6x5_row3; } template <> struct geometric_traits<detail::matrix_float_6x5_row3> { typedef detail::matrix_float_6x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,4> matrix_float_6x5_row4; } template <> struct geometric_traits<detail::matrix_float_6x5_row4> { typedef detail::matrix_float_6x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x5,5> matrix_float_6x5_row5; } template <> struct geometric_traits<detail::matrix_float_6x5_row5> { typedef detail::matrix_float_6x5_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x5,0> matrix_float_6x5_column0; }template <> struct geometric_traits<detail::matrix_float_6x5_column0> { typedef detail::matrix_float_6x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x5,1> matrix_float_6x5_column1; }template <> struct geometric_traits<detail::matrix_float_6x5_column1> { typedef detail::matrix_float_6x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x5,2> matrix_float_6x5_column2; }template <> struct geometric_traits<detail::matrix_float_6x5_column2> { typedef detail::matrix_float_6x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x5,3> matrix_float_6x5_column3; }template <> struct geometric_traits<detail::matrix_float_6x5_column3> { typedef detail::matrix_float_6x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x5,4> matrix_float_6x5_column4; }template <> struct geometric_traits<detail::matrix_float_6x5_column4> { typedef detail::matrix_float_6x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x5>::type > : index_operator_matrix_access_policy < matrix_float_6x5 > { typedef index_operator_matrix_access_policy < matrix_float_6x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x5 > { typedef dimension<6> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 6> matrix_float_6x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,0> matrix_float_6x6_row0; } template <> struct geometric_traits<detail::matrix_float_6x6_row0> { typedef detail::matrix_float_6x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,1> matrix_float_6x6_row1; } template <> struct geometric_traits<detail::matrix_float_6x6_row1> { typedef detail::matrix_float_6x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,2> matrix_float_6x6_row2; } template <> struct geometric_traits<detail::matrix_float_6x6_row2> { typedef detail::matrix_float_6x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,3> matrix_float_6x6_row3; } template <> struct geometric_traits<detail::matrix_float_6x6_row3> { typedef detail::matrix_float_6x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,4> matrix_float_6x6_row4; } template <> struct geometric_traits<detail::matrix_float_6x6_row4> { typedef detail::matrix_float_6x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x6,5> matrix_float_6x6_row5; } template <> struct geometric_traits<detail::matrix_float_6x6_row5> { typedef detail::matrix_float_6x6_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,0> matrix_float_6x6_column0; }template <> struct geometric_traits<detail::matrix_float_6x6_column0> { typedef detail::matrix_float_6x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,1> matrix_float_6x6_column1; }template <> struct geometric_traits<detail::matrix_float_6x6_column1> { typedef detail::matrix_float_6x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,2> matrix_float_6x6_column2; }template <> struct geometric_traits<detail::matrix_float_6x6_column2> { typedef detail::matrix_float_6x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,3> matrix_float_6x6_column3; }template <> struct geometric_traits<detail::matrix_float_6x6_column3> { typedef detail::matrix_float_6x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,4> matrix_float_6x6_column4; }template <> struct geometric_traits<detail::matrix_float_6x6_column4> { typedef detail::matrix_float_6x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x6,5> matrix_float_6x6_column5; }template <> struct geometric_traits<detail::matrix_float_6x6_column5> { typedef detail::matrix_float_6x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x6>::type > : index_operator_matrix_access_policy < matrix_float_6x6 > { typedef index_operator_matrix_access_policy < matrix_float_6x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x6 > { typedef dimension<6> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 7> matrix_float_6x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,0> matrix_float_6x7_row0; } template <> struct geometric_traits<detail::matrix_float_6x7_row0> { typedef detail::matrix_float_6x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,1> matrix_float_6x7_row1; } template <> struct geometric_traits<detail::matrix_float_6x7_row1> { typedef detail::matrix_float_6x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,2> matrix_float_6x7_row2; } template <> struct geometric_traits<detail::matrix_float_6x7_row2> { typedef detail::matrix_float_6x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,3> matrix_float_6x7_row3; } template <> struct geometric_traits<detail::matrix_float_6x7_row3> { typedef detail::matrix_float_6x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,4> matrix_float_6x7_row4; } template <> struct geometric_traits<detail::matrix_float_6x7_row4> { typedef detail::matrix_float_6x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x7,5> matrix_float_6x7_row5; } template <> struct geometric_traits<detail::matrix_float_6x7_row5> { typedef detail::matrix_float_6x7_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,0> matrix_float_6x7_column0; }template <> struct geometric_traits<detail::matrix_float_6x7_column0> { typedef detail::matrix_float_6x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,1> matrix_float_6x7_column1; }template <> struct geometric_traits<detail::matrix_float_6x7_column1> { typedef detail::matrix_float_6x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,2> matrix_float_6x7_column2; }template <> struct geometric_traits<detail::matrix_float_6x7_column2> { typedef detail::matrix_float_6x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,3> matrix_float_6x7_column3; }template <> struct geometric_traits<detail::matrix_float_6x7_column3> { typedef detail::matrix_float_6x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,4> matrix_float_6x7_column4; }template <> struct geometric_traits<detail::matrix_float_6x7_column4> { typedef detail::matrix_float_6x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,5> matrix_float_6x7_column5; }template <> struct geometric_traits<detail::matrix_float_6x7_column5> { typedef detail::matrix_float_6x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x7,6> matrix_float_6x7_column6; }template <> struct geometric_traits<detail::matrix_float_6x7_column6> { typedef detail::matrix_float_6x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x7>::type > : index_operator_matrix_access_policy < matrix_float_6x7 > { typedef index_operator_matrix_access_policy < matrix_float_6x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x7 > { typedef dimension<6> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 8> matrix_float_6x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,0> matrix_float_6x8_row0; } template <> struct geometric_traits<detail::matrix_float_6x8_row0> { typedef detail::matrix_float_6x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,1> matrix_float_6x8_row1; } template <> struct geometric_traits<detail::matrix_float_6x8_row1> { typedef detail::matrix_float_6x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,2> matrix_float_6x8_row2; } template <> struct geometric_traits<detail::matrix_float_6x8_row2> { typedef detail::matrix_float_6x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,3> matrix_float_6x8_row3; } template <> struct geometric_traits<detail::matrix_float_6x8_row3> { typedef detail::matrix_float_6x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,4> matrix_float_6x8_row4; } template <> struct geometric_traits<detail::matrix_float_6x8_row4> { typedef detail::matrix_float_6x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x8,5> matrix_float_6x8_row5; } template <> struct geometric_traits<detail::matrix_float_6x8_row5> { typedef detail::matrix_float_6x8_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,0> matrix_float_6x8_column0; }template <> struct geometric_traits<detail::matrix_float_6x8_column0> { typedef detail::matrix_float_6x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,1> matrix_float_6x8_column1; }template <> struct geometric_traits<detail::matrix_float_6x8_column1> { typedef detail::matrix_float_6x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,2> matrix_float_6x8_column2; }template <> struct geometric_traits<detail::matrix_float_6x8_column2> { typedef detail::matrix_float_6x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,3> matrix_float_6x8_column3; }template <> struct geometric_traits<detail::matrix_float_6x8_column3> { typedef detail::matrix_float_6x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,4> matrix_float_6x8_column4; }template <> struct geometric_traits<detail::matrix_float_6x8_column4> { typedef detail::matrix_float_6x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,5> matrix_float_6x8_column5; }template <> struct geometric_traits<detail::matrix_float_6x8_column5> { typedef detail::matrix_float_6x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,6> matrix_float_6x8_column6; }template <> struct geometric_traits<detail::matrix_float_6x8_column6> { typedef detail::matrix_float_6x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x8,7> matrix_float_6x8_column7; }template <> struct geometric_traits<detail::matrix_float_6x8_column7> { typedef detail::matrix_float_6x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x8>::type > : index_operator_matrix_access_policy < matrix_float_6x8 > { typedef index_operator_matrix_access_policy < matrix_float_6x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x8 > { typedef dimension<6> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 9> matrix_float_6x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,0> matrix_float_6x9_row0; } template <> struct geometric_traits<detail::matrix_float_6x9_row0> { typedef detail::matrix_float_6x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,1> matrix_float_6x9_row1; } template <> struct geometric_traits<detail::matrix_float_6x9_row1> { typedef detail::matrix_float_6x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,2> matrix_float_6x9_row2; } template <> struct geometric_traits<detail::matrix_float_6x9_row2> { typedef detail::matrix_float_6x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,3> matrix_float_6x9_row3; } template <> struct geometric_traits<detail::matrix_float_6x9_row3> { typedef detail::matrix_float_6x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,4> matrix_float_6x9_row4; } template <> struct geometric_traits<detail::matrix_float_6x9_row4> { typedef detail::matrix_float_6x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x9,5> matrix_float_6x9_row5; } template <> struct geometric_traits<detail::matrix_float_6x9_row5> { typedef detail::matrix_float_6x9_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,0> matrix_float_6x9_column0; }template <> struct geometric_traits<detail::matrix_float_6x9_column0> { typedef detail::matrix_float_6x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,1> matrix_float_6x9_column1; }template <> struct geometric_traits<detail::matrix_float_6x9_column1> { typedef detail::matrix_float_6x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,2> matrix_float_6x9_column2; }template <> struct geometric_traits<detail::matrix_float_6x9_column2> { typedef detail::matrix_float_6x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,3> matrix_float_6x9_column3; }template <> struct geometric_traits<detail::matrix_float_6x9_column3> { typedef detail::matrix_float_6x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,4> matrix_float_6x9_column4; }template <> struct geometric_traits<detail::matrix_float_6x9_column4> { typedef detail::matrix_float_6x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,5> matrix_float_6x9_column5; }template <> struct geometric_traits<detail::matrix_float_6x9_column5> { typedef detail::matrix_float_6x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,6> matrix_float_6x9_column6; }template <> struct geometric_traits<detail::matrix_float_6x9_column6> { typedef detail::matrix_float_6x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,7> matrix_float_6x9_column7; }template <> struct geometric_traits<detail::matrix_float_6x9_column7> { typedef detail::matrix_float_6x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x9,8> matrix_float_6x9_column8; }template <> struct geometric_traits<detail::matrix_float_6x9_column8> { typedef detail::matrix_float_6x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x9>::type > : index_operator_matrix_access_policy < matrix_float_6x9 > { typedef index_operator_matrix_access_policy < matrix_float_6x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x9 > { typedef dimension<6> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 6, 10> matrix_float_6x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,0> matrix_float_6x10_row0; } template <> struct geometric_traits<detail::matrix_float_6x10_row0> { typedef detail::matrix_float_6x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,1> matrix_float_6x10_row1; } template <> struct geometric_traits<detail::matrix_float_6x10_row1> { typedef detail::matrix_float_6x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,2> matrix_float_6x10_row2; } template <> struct geometric_traits<detail::matrix_float_6x10_row2> { typedef detail::matrix_float_6x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,3> matrix_float_6x10_row3; } template <> struct geometric_traits<detail::matrix_float_6x10_row3> { typedef detail::matrix_float_6x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,4> matrix_float_6x10_row4; } template <> struct geometric_traits<detail::matrix_float_6x10_row4> { typedef detail::matrix_float_6x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_6x10,5> matrix_float_6x10_row5; } template <> struct geometric_traits<detail::matrix_float_6x10_row5> { typedef detail::matrix_float_6x10_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,0> matrix_float_6x10_column0; }template <> struct geometric_traits<detail::matrix_float_6x10_column0> { typedef detail::matrix_float_6x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,1> matrix_float_6x10_column1; }template <> struct geometric_traits<detail::matrix_float_6x10_column1> { typedef detail::matrix_float_6x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,2> matrix_float_6x10_column2; }template <> struct geometric_traits<detail::matrix_float_6x10_column2> { typedef detail::matrix_float_6x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,3> matrix_float_6x10_column3; }template <> struct geometric_traits<detail::matrix_float_6x10_column3> { typedef detail::matrix_float_6x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,4> matrix_float_6x10_column4; }template <> struct geometric_traits<detail::matrix_float_6x10_column4> { typedef detail::matrix_float_6x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,5> matrix_float_6x10_column5; }template <> struct geometric_traits<detail::matrix_float_6x10_column5> { typedef detail::matrix_float_6x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,6> matrix_float_6x10_column6; }template <> struct geometric_traits<detail::matrix_float_6x10_column6> { typedef detail::matrix_float_6x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,7> matrix_float_6x10_column7; }template <> struct geometric_traits<detail::matrix_float_6x10_column7> { typedef detail::matrix_float_6x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,8> matrix_float_6x10_column8; }template <> struct geometric_traits<detail::matrix_float_6x10_column8> { typedef detail::matrix_float_6x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_6x10,9> matrix_float_6x10_column9; }template <> struct geometric_traits<detail::matrix_float_6x10_column9> { typedef detail::matrix_float_6x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_6x10>::type > : index_operator_matrix_access_policy < matrix_float_6x10 > { typedef index_operator_matrix_access_policy < matrix_float_6x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_6x10 > { typedef dimension<6> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 1> matrix_float_7x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,0> matrix_float_7x1_row0; } template <> struct geometric_traits<detail::matrix_float_7x1_row0> { typedef detail::matrix_float_7x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,1> matrix_float_7x1_row1; } template <> struct geometric_traits<detail::matrix_float_7x1_row1> { typedef detail::matrix_float_7x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,2> matrix_float_7x1_row2; } template <> struct geometric_traits<detail::matrix_float_7x1_row2> { typedef detail::matrix_float_7x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,3> matrix_float_7x1_row3; } template <> struct geometric_traits<detail::matrix_float_7x1_row3> { typedef detail::matrix_float_7x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,4> matrix_float_7x1_row4; } template <> struct geometric_traits<detail::matrix_float_7x1_row4> { typedef detail::matrix_float_7x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,5> matrix_float_7x1_row5; } template <> struct geometric_traits<detail::matrix_float_7x1_row5> { typedef detail::matrix_float_7x1_row5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x1,6> matrix_float_7x1_row6; } template <> struct geometric_traits<detail::matrix_float_7x1_row6> { typedef detail::matrix_float_7x1_row6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x1,0> matrix_float_7x1_column0; }template <> struct geometric_traits<detail::matrix_float_7x1_column0> { typedef detail::matrix_float_7x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x1>::type > : index_operator_matrix_access_policy < matrix_float_7x1 > { typedef index_operator_matrix_access_policy < matrix_float_7x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x1 > { typedef dimension<7> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 2> matrix_float_7x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,0> matrix_float_7x2_row0; } template <> struct geometric_traits<detail::matrix_float_7x2_row0> { typedef detail::matrix_float_7x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,1> matrix_float_7x2_row1; } template <> struct geometric_traits<detail::matrix_float_7x2_row1> { typedef detail::matrix_float_7x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,2> matrix_float_7x2_row2; } template <> struct geometric_traits<detail::matrix_float_7x2_row2> { typedef detail::matrix_float_7x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,3> matrix_float_7x2_row3; } template <> struct geometric_traits<detail::matrix_float_7x2_row3> { typedef detail::matrix_float_7x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,4> matrix_float_7x2_row4; } template <> struct geometric_traits<detail::matrix_float_7x2_row4> { typedef detail::matrix_float_7x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,5> matrix_float_7x2_row5; } template <> struct geometric_traits<detail::matrix_float_7x2_row5> { typedef detail::matrix_float_7x2_row5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x2,6> matrix_float_7x2_row6; } template <> struct geometric_traits<detail::matrix_float_7x2_row6> { typedef detail::matrix_float_7x2_row6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x2,0> matrix_float_7x2_column0; }template <> struct geometric_traits<detail::matrix_float_7x2_column0> { typedef detail::matrix_float_7x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x2,1> matrix_float_7x2_column1; }template <> struct geometric_traits<detail::matrix_float_7x2_column1> { typedef detail::matrix_float_7x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x2>::type > : index_operator_matrix_access_policy < matrix_float_7x2 > { typedef index_operator_matrix_access_policy < matrix_float_7x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x2 > { typedef dimension<7> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 3> matrix_float_7x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,0> matrix_float_7x3_row0; } template <> struct geometric_traits<detail::matrix_float_7x3_row0> { typedef detail::matrix_float_7x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,1> matrix_float_7x3_row1; } template <> struct geometric_traits<detail::matrix_float_7x3_row1> { typedef detail::matrix_float_7x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,2> matrix_float_7x3_row2; } template <> struct geometric_traits<detail::matrix_float_7x3_row2> { typedef detail::matrix_float_7x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,3> matrix_float_7x3_row3; } template <> struct geometric_traits<detail::matrix_float_7x3_row3> { typedef detail::matrix_float_7x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,4> matrix_float_7x3_row4; } template <> struct geometric_traits<detail::matrix_float_7x3_row4> { typedef detail::matrix_float_7x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,5> matrix_float_7x3_row5; } template <> struct geometric_traits<detail::matrix_float_7x3_row5> { typedef detail::matrix_float_7x3_row5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x3,6> matrix_float_7x3_row6; } template <> struct geometric_traits<detail::matrix_float_7x3_row6> { typedef detail::matrix_float_7x3_row6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x3,0> matrix_float_7x3_column0; }template <> struct geometric_traits<detail::matrix_float_7x3_column0> { typedef detail::matrix_float_7x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x3,1> matrix_float_7x3_column1; }template <> struct geometric_traits<detail::matrix_float_7x3_column1> { typedef detail::matrix_float_7x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x3,2> matrix_float_7x3_column2; }template <> struct geometric_traits<detail::matrix_float_7x3_column2> { typedef detail::matrix_float_7x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x3>::type > : index_operator_matrix_access_policy < matrix_float_7x3 > { typedef index_operator_matrix_access_policy < matrix_float_7x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x3 > { typedef dimension<7> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 4> matrix_float_7x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,0> matrix_float_7x4_row0; } template <> struct geometric_traits<detail::matrix_float_7x4_row0> { typedef detail::matrix_float_7x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,1> matrix_float_7x4_row1; } template <> struct geometric_traits<detail::matrix_float_7x4_row1> { typedef detail::matrix_float_7x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,2> matrix_float_7x4_row2; } template <> struct geometric_traits<detail::matrix_float_7x4_row2> { typedef detail::matrix_float_7x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,3> matrix_float_7x4_row3; } template <> struct geometric_traits<detail::matrix_float_7x4_row3> { typedef detail::matrix_float_7x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,4> matrix_float_7x4_row4; } template <> struct geometric_traits<detail::matrix_float_7x4_row4> { typedef detail::matrix_float_7x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,5> matrix_float_7x4_row5; } template <> struct geometric_traits<detail::matrix_float_7x4_row5> { typedef detail::matrix_float_7x4_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x4,6> matrix_float_7x4_row6; } template <> struct geometric_traits<detail::matrix_float_7x4_row6> { typedef detail::matrix_float_7x4_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x4,0> matrix_float_7x4_column0; }template <> struct geometric_traits<detail::matrix_float_7x4_column0> { typedef detail::matrix_float_7x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x4,1> matrix_float_7x4_column1; }template <> struct geometric_traits<detail::matrix_float_7x4_column1> { typedef detail::matrix_float_7x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x4,2> matrix_float_7x4_column2; }template <> struct geometric_traits<detail::matrix_float_7x4_column2> { typedef detail::matrix_float_7x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x4,3> matrix_float_7x4_column3; }template <> struct geometric_traits<detail::matrix_float_7x4_column3> { typedef detail::matrix_float_7x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x4>::type > : index_operator_matrix_access_policy < matrix_float_7x4 > { typedef index_operator_matrix_access_policy < matrix_float_7x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x4 > { typedef dimension<7> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 5> matrix_float_7x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,0> matrix_float_7x5_row0; } template <> struct geometric_traits<detail::matrix_float_7x5_row0> { typedef detail::matrix_float_7x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,1> matrix_float_7x5_row1; } template <> struct geometric_traits<detail::matrix_float_7x5_row1> { typedef detail::matrix_float_7x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,2> matrix_float_7x5_row2; } template <> struct geometric_traits<detail::matrix_float_7x5_row2> { typedef detail::matrix_float_7x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,3> matrix_float_7x5_row3; } template <> struct geometric_traits<detail::matrix_float_7x5_row3> { typedef detail::matrix_float_7x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,4> matrix_float_7x5_row4; } template <> struct geometric_traits<detail::matrix_float_7x5_row4> { typedef detail::matrix_float_7x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,5> matrix_float_7x5_row5; } template <> struct geometric_traits<detail::matrix_float_7x5_row5> { typedef detail::matrix_float_7x5_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x5,6> matrix_float_7x5_row6; } template <> struct geometric_traits<detail::matrix_float_7x5_row6> { typedef detail::matrix_float_7x5_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x5,0> matrix_float_7x5_column0; }template <> struct geometric_traits<detail::matrix_float_7x5_column0> { typedef detail::matrix_float_7x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x5,1> matrix_float_7x5_column1; }template <> struct geometric_traits<detail::matrix_float_7x5_column1> { typedef detail::matrix_float_7x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x5,2> matrix_float_7x5_column2; }template <> struct geometric_traits<detail::matrix_float_7x5_column2> { typedef detail::matrix_float_7x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x5,3> matrix_float_7x5_column3; }template <> struct geometric_traits<detail::matrix_float_7x5_column3> { typedef detail::matrix_float_7x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x5,4> matrix_float_7x5_column4; }template <> struct geometric_traits<detail::matrix_float_7x5_column4> { typedef detail::matrix_float_7x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x5>::type > : index_operator_matrix_access_policy < matrix_float_7x5 > { typedef index_operator_matrix_access_policy < matrix_float_7x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x5 > { typedef dimension<7> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 6> matrix_float_7x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,0> matrix_float_7x6_row0; } template <> struct geometric_traits<detail::matrix_float_7x6_row0> { typedef detail::matrix_float_7x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,1> matrix_float_7x6_row1; } template <> struct geometric_traits<detail::matrix_float_7x6_row1> { typedef detail::matrix_float_7x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,2> matrix_float_7x6_row2; } template <> struct geometric_traits<detail::matrix_float_7x6_row2> { typedef detail::matrix_float_7x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,3> matrix_float_7x6_row3; } template <> struct geometric_traits<detail::matrix_float_7x6_row3> { typedef detail::matrix_float_7x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,4> matrix_float_7x6_row4; } template <> struct geometric_traits<detail::matrix_float_7x6_row4> { typedef detail::matrix_float_7x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,5> matrix_float_7x6_row5; } template <> struct geometric_traits<detail::matrix_float_7x6_row5> { typedef detail::matrix_float_7x6_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x6,6> matrix_float_7x6_row6; } template <> struct geometric_traits<detail::matrix_float_7x6_row6> { typedef detail::matrix_float_7x6_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,0> matrix_float_7x6_column0; }template <> struct geometric_traits<detail::matrix_float_7x6_column0> { typedef detail::matrix_float_7x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,1> matrix_float_7x6_column1; }template <> struct geometric_traits<detail::matrix_float_7x6_column1> { typedef detail::matrix_float_7x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,2> matrix_float_7x6_column2; }template <> struct geometric_traits<detail::matrix_float_7x6_column2> { typedef detail::matrix_float_7x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,3> matrix_float_7x6_column3; }template <> struct geometric_traits<detail::matrix_float_7x6_column3> { typedef detail::matrix_float_7x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,4> matrix_float_7x6_column4; }template <> struct geometric_traits<detail::matrix_float_7x6_column4> { typedef detail::matrix_float_7x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x6,5> matrix_float_7x6_column5; }template <> struct geometric_traits<detail::matrix_float_7x6_column5> { typedef detail::matrix_float_7x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x6>::type > : index_operator_matrix_access_policy < matrix_float_7x6 > { typedef index_operator_matrix_access_policy < matrix_float_7x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x6 > { typedef dimension<7> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 7> matrix_float_7x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,0> matrix_float_7x7_row0; } template <> struct geometric_traits<detail::matrix_float_7x7_row0> { typedef detail::matrix_float_7x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,1> matrix_float_7x7_row1; } template <> struct geometric_traits<detail::matrix_float_7x7_row1> { typedef detail::matrix_float_7x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,2> matrix_float_7x7_row2; } template <> struct geometric_traits<detail::matrix_float_7x7_row2> { typedef detail::matrix_float_7x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,3> matrix_float_7x7_row3; } template <> struct geometric_traits<detail::matrix_float_7x7_row3> { typedef detail::matrix_float_7x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,4> matrix_float_7x7_row4; } template <> struct geometric_traits<detail::matrix_float_7x7_row4> { typedef detail::matrix_float_7x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,5> matrix_float_7x7_row5; } template <> struct geometric_traits<detail::matrix_float_7x7_row5> { typedef detail::matrix_float_7x7_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x7,6> matrix_float_7x7_row6; } template <> struct geometric_traits<detail::matrix_float_7x7_row6> { typedef detail::matrix_float_7x7_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,0> matrix_float_7x7_column0; }template <> struct geometric_traits<detail::matrix_float_7x7_column0> { typedef detail::matrix_float_7x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,1> matrix_float_7x7_column1; }template <> struct geometric_traits<detail::matrix_float_7x7_column1> { typedef detail::matrix_float_7x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,2> matrix_float_7x7_column2; }template <> struct geometric_traits<detail::matrix_float_7x7_column2> { typedef detail::matrix_float_7x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,3> matrix_float_7x7_column3; }template <> struct geometric_traits<detail::matrix_float_7x7_column3> { typedef detail::matrix_float_7x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,4> matrix_float_7x7_column4; }template <> struct geometric_traits<detail::matrix_float_7x7_column4> { typedef detail::matrix_float_7x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,5> matrix_float_7x7_column5; }template <> struct geometric_traits<detail::matrix_float_7x7_column5> { typedef detail::matrix_float_7x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x7,6> matrix_float_7x7_column6; }template <> struct geometric_traits<detail::matrix_float_7x7_column6> { typedef detail::matrix_float_7x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x7>::type > : index_operator_matrix_access_policy < matrix_float_7x7 > { typedef index_operator_matrix_access_policy < matrix_float_7x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x7 > { typedef dimension<7> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 8> matrix_float_7x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,0> matrix_float_7x8_row0; } template <> struct geometric_traits<detail::matrix_float_7x8_row0> { typedef detail::matrix_float_7x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,1> matrix_float_7x8_row1; } template <> struct geometric_traits<detail::matrix_float_7x8_row1> { typedef detail::matrix_float_7x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,2> matrix_float_7x8_row2; } template <> struct geometric_traits<detail::matrix_float_7x8_row2> { typedef detail::matrix_float_7x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,3> matrix_float_7x8_row3; } template <> struct geometric_traits<detail::matrix_float_7x8_row3> { typedef detail::matrix_float_7x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,4> matrix_float_7x8_row4; } template <> struct geometric_traits<detail::matrix_float_7x8_row4> { typedef detail::matrix_float_7x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,5> matrix_float_7x8_row5; } template <> struct geometric_traits<detail::matrix_float_7x8_row5> { typedef detail::matrix_float_7x8_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x8,6> matrix_float_7x8_row6; } template <> struct geometric_traits<detail::matrix_float_7x8_row6> { typedef detail::matrix_float_7x8_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,0> matrix_float_7x8_column0; }template <> struct geometric_traits<detail::matrix_float_7x8_column0> { typedef detail::matrix_float_7x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,1> matrix_float_7x8_column1; }template <> struct geometric_traits<detail::matrix_float_7x8_column1> { typedef detail::matrix_float_7x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,2> matrix_float_7x8_column2; }template <> struct geometric_traits<detail::matrix_float_7x8_column2> { typedef detail::matrix_float_7x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,3> matrix_float_7x8_column3; }template <> struct geometric_traits<detail::matrix_float_7x8_column3> { typedef detail::matrix_float_7x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,4> matrix_float_7x8_column4; }template <> struct geometric_traits<detail::matrix_float_7x8_column4> { typedef detail::matrix_float_7x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,5> matrix_float_7x8_column5; }template <> struct geometric_traits<detail::matrix_float_7x8_column5> { typedef detail::matrix_float_7x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,6> matrix_float_7x8_column6; }template <> struct geometric_traits<detail::matrix_float_7x8_column6> { typedef detail::matrix_float_7x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x8,7> matrix_float_7x8_column7; }template <> struct geometric_traits<detail::matrix_float_7x8_column7> { typedef detail::matrix_float_7x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x8>::type > : index_operator_matrix_access_policy < matrix_float_7x8 > { typedef index_operator_matrix_access_policy < matrix_float_7x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x8 > { typedef dimension<7> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 9> matrix_float_7x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,0> matrix_float_7x9_row0; } template <> struct geometric_traits<detail::matrix_float_7x9_row0> { typedef detail::matrix_float_7x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,1> matrix_float_7x9_row1; } template <> struct geometric_traits<detail::matrix_float_7x9_row1> { typedef detail::matrix_float_7x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,2> matrix_float_7x9_row2; } template <> struct geometric_traits<detail::matrix_float_7x9_row2> { typedef detail::matrix_float_7x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,3> matrix_float_7x9_row3; } template <> struct geometric_traits<detail::matrix_float_7x9_row3> { typedef detail::matrix_float_7x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,4> matrix_float_7x9_row4; } template <> struct geometric_traits<detail::matrix_float_7x9_row4> { typedef detail::matrix_float_7x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,5> matrix_float_7x9_row5; } template <> struct geometric_traits<detail::matrix_float_7x9_row5> { typedef detail::matrix_float_7x9_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x9,6> matrix_float_7x9_row6; } template <> struct geometric_traits<detail::matrix_float_7x9_row6> { typedef detail::matrix_float_7x9_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,0> matrix_float_7x9_column0; }template <> struct geometric_traits<detail::matrix_float_7x9_column0> { typedef detail::matrix_float_7x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,1> matrix_float_7x9_column1; }template <> struct geometric_traits<detail::matrix_float_7x9_column1> { typedef detail::matrix_float_7x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,2> matrix_float_7x9_column2; }template <> struct geometric_traits<detail::matrix_float_7x9_column2> { typedef detail::matrix_float_7x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,3> matrix_float_7x9_column3; }template <> struct geometric_traits<detail::matrix_float_7x9_column3> { typedef detail::matrix_float_7x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,4> matrix_float_7x9_column4; }template <> struct geometric_traits<detail::matrix_float_7x9_column4> { typedef detail::matrix_float_7x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,5> matrix_float_7x9_column5; }template <> struct geometric_traits<detail::matrix_float_7x9_column5> { typedef detail::matrix_float_7x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,6> matrix_float_7x9_column6; }template <> struct geometric_traits<detail::matrix_float_7x9_column6> { typedef detail::matrix_float_7x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,7> matrix_float_7x9_column7; }template <> struct geometric_traits<detail::matrix_float_7x9_column7> { typedef detail::matrix_float_7x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x9,8> matrix_float_7x9_column8; }template <> struct geometric_traits<detail::matrix_float_7x9_column8> { typedef detail::matrix_float_7x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x9>::type > : index_operator_matrix_access_policy < matrix_float_7x9 > { typedef index_operator_matrix_access_policy < matrix_float_7x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x9 > { typedef dimension<7> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 7, 10> matrix_float_7x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,0> matrix_float_7x10_row0; } template <> struct geometric_traits<detail::matrix_float_7x10_row0> { typedef detail::matrix_float_7x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,1> matrix_float_7x10_row1; } template <> struct geometric_traits<detail::matrix_float_7x10_row1> { typedef detail::matrix_float_7x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,2> matrix_float_7x10_row2; } template <> struct geometric_traits<detail::matrix_float_7x10_row2> { typedef detail::matrix_float_7x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,3> matrix_float_7x10_row3; } template <> struct geometric_traits<detail::matrix_float_7x10_row3> { typedef detail::matrix_float_7x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,4> matrix_float_7x10_row4; } template <> struct geometric_traits<detail::matrix_float_7x10_row4> { typedef detail::matrix_float_7x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,5> matrix_float_7x10_row5; } template <> struct geometric_traits<detail::matrix_float_7x10_row5> { typedef detail::matrix_float_7x10_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_7x10,6> matrix_float_7x10_row6; } template <> struct geometric_traits<detail::matrix_float_7x10_row6> { typedef detail::matrix_float_7x10_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,0> matrix_float_7x10_column0; }template <> struct geometric_traits<detail::matrix_float_7x10_column0> { typedef detail::matrix_float_7x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,1> matrix_float_7x10_column1; }template <> struct geometric_traits<detail::matrix_float_7x10_column1> { typedef detail::matrix_float_7x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,2> matrix_float_7x10_column2; }template <> struct geometric_traits<detail::matrix_float_7x10_column2> { typedef detail::matrix_float_7x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,3> matrix_float_7x10_column3; }template <> struct geometric_traits<detail::matrix_float_7x10_column3> { typedef detail::matrix_float_7x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,4> matrix_float_7x10_column4; }template <> struct geometric_traits<detail::matrix_float_7x10_column4> { typedef detail::matrix_float_7x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,5> matrix_float_7x10_column5; }template <> struct geometric_traits<detail::matrix_float_7x10_column5> { typedef detail::matrix_float_7x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,6> matrix_float_7x10_column6; }template <> struct geometric_traits<detail::matrix_float_7x10_column6> { typedef detail::matrix_float_7x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,7> matrix_float_7x10_column7; }template <> struct geometric_traits<detail::matrix_float_7x10_column7> { typedef detail::matrix_float_7x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,8> matrix_float_7x10_column8; }template <> struct geometric_traits<detail::matrix_float_7x10_column8> { typedef detail::matrix_float_7x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_7x10,9> matrix_float_7x10_column9; }template <> struct geometric_traits<detail::matrix_float_7x10_column9> { typedef detail::matrix_float_7x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_7x10>::type > : index_operator_matrix_access_policy < matrix_float_7x10 > { typedef index_operator_matrix_access_policy < matrix_float_7x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_7x10 > { typedef dimension<7> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 1> matrix_float_8x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,0> matrix_float_8x1_row0; } template <> struct geometric_traits<detail::matrix_float_8x1_row0> { typedef detail::matrix_float_8x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,1> matrix_float_8x1_row1; } template <> struct geometric_traits<detail::matrix_float_8x1_row1> { typedef detail::matrix_float_8x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,2> matrix_float_8x1_row2; } template <> struct geometric_traits<detail::matrix_float_8x1_row2> { typedef detail::matrix_float_8x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,3> matrix_float_8x1_row3; } template <> struct geometric_traits<detail::matrix_float_8x1_row3> { typedef detail::matrix_float_8x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,4> matrix_float_8x1_row4; } template <> struct geometric_traits<detail::matrix_float_8x1_row4> { typedef detail::matrix_float_8x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,5> matrix_float_8x1_row5; } template <> struct geometric_traits<detail::matrix_float_8x1_row5> { typedef detail::matrix_float_8x1_row5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,6> matrix_float_8x1_row6; } template <> struct geometric_traits<detail::matrix_float_8x1_row6> { typedef detail::matrix_float_8x1_row6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x1,7> matrix_float_8x1_row7; } template <> struct geometric_traits<detail::matrix_float_8x1_row7> { typedef detail::matrix_float_8x1_row7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x1,0> matrix_float_8x1_column0; }template <> struct geometric_traits<detail::matrix_float_8x1_column0> { typedef detail::matrix_float_8x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x1>::type > : index_operator_matrix_access_policy < matrix_float_8x1 > { typedef index_operator_matrix_access_policy < matrix_float_8x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x1 > { typedef dimension<8> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 2> matrix_float_8x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,0> matrix_float_8x2_row0; } template <> struct geometric_traits<detail::matrix_float_8x2_row0> { typedef detail::matrix_float_8x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,1> matrix_float_8x2_row1; } template <> struct geometric_traits<detail::matrix_float_8x2_row1> { typedef detail::matrix_float_8x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,2> matrix_float_8x2_row2; } template <> struct geometric_traits<detail::matrix_float_8x2_row2> { typedef detail::matrix_float_8x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,3> matrix_float_8x2_row3; } template <> struct geometric_traits<detail::matrix_float_8x2_row3> { typedef detail::matrix_float_8x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,4> matrix_float_8x2_row4; } template <> struct geometric_traits<detail::matrix_float_8x2_row4> { typedef detail::matrix_float_8x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,5> matrix_float_8x2_row5; } template <> struct geometric_traits<detail::matrix_float_8x2_row5> { typedef detail::matrix_float_8x2_row5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,6> matrix_float_8x2_row6; } template <> struct geometric_traits<detail::matrix_float_8x2_row6> { typedef detail::matrix_float_8x2_row6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x2,7> matrix_float_8x2_row7; } template <> struct geometric_traits<detail::matrix_float_8x2_row7> { typedef detail::matrix_float_8x2_row7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x2,0> matrix_float_8x2_column0; }template <> struct geometric_traits<detail::matrix_float_8x2_column0> { typedef detail::matrix_float_8x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x2,1> matrix_float_8x2_column1; }template <> struct geometric_traits<detail::matrix_float_8x2_column1> { typedef detail::matrix_float_8x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x2>::type > : index_operator_matrix_access_policy < matrix_float_8x2 > { typedef index_operator_matrix_access_policy < matrix_float_8x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x2 > { typedef dimension<8> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 3> matrix_float_8x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,0> matrix_float_8x3_row0; } template <> struct geometric_traits<detail::matrix_float_8x3_row0> { typedef detail::matrix_float_8x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,1> matrix_float_8x3_row1; } template <> struct geometric_traits<detail::matrix_float_8x3_row1> { typedef detail::matrix_float_8x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,2> matrix_float_8x3_row2; } template <> struct geometric_traits<detail::matrix_float_8x3_row2> { typedef detail::matrix_float_8x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,3> matrix_float_8x3_row3; } template <> struct geometric_traits<detail::matrix_float_8x3_row3> { typedef detail::matrix_float_8x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,4> matrix_float_8x3_row4; } template <> struct geometric_traits<detail::matrix_float_8x3_row4> { typedef detail::matrix_float_8x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,5> matrix_float_8x3_row5; } template <> struct geometric_traits<detail::matrix_float_8x3_row5> { typedef detail::matrix_float_8x3_row5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,6> matrix_float_8x3_row6; } template <> struct geometric_traits<detail::matrix_float_8x3_row6> { typedef detail::matrix_float_8x3_row6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x3,7> matrix_float_8x3_row7; } template <> struct geometric_traits<detail::matrix_float_8x3_row7> { typedef detail::matrix_float_8x3_row7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x3,0> matrix_float_8x3_column0; }template <> struct geometric_traits<detail::matrix_float_8x3_column0> { typedef detail::matrix_float_8x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x3,1> matrix_float_8x3_column1; }template <> struct geometric_traits<detail::matrix_float_8x3_column1> { typedef detail::matrix_float_8x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x3,2> matrix_float_8x3_column2; }template <> struct geometric_traits<detail::matrix_float_8x3_column2> { typedef detail::matrix_float_8x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x3>::type > : index_operator_matrix_access_policy < matrix_float_8x3 > { typedef index_operator_matrix_access_policy < matrix_float_8x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x3 > { typedef dimension<8> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 4> matrix_float_8x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,0> matrix_float_8x4_row0; } template <> struct geometric_traits<detail::matrix_float_8x4_row0> { typedef detail::matrix_float_8x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,1> matrix_float_8x4_row1; } template <> struct geometric_traits<detail::matrix_float_8x4_row1> { typedef detail::matrix_float_8x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,2> matrix_float_8x4_row2; } template <> struct geometric_traits<detail::matrix_float_8x4_row2> { typedef detail::matrix_float_8x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,3> matrix_float_8x4_row3; } template <> struct geometric_traits<detail::matrix_float_8x4_row3> { typedef detail::matrix_float_8x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,4> matrix_float_8x4_row4; } template <> struct geometric_traits<detail::matrix_float_8x4_row4> { typedef detail::matrix_float_8x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,5> matrix_float_8x4_row5; } template <> struct geometric_traits<detail::matrix_float_8x4_row5> { typedef detail::matrix_float_8x4_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,6> matrix_float_8x4_row6; } template <> struct geometric_traits<detail::matrix_float_8x4_row6> { typedef detail::matrix_float_8x4_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x4,7> matrix_float_8x4_row7; } template <> struct geometric_traits<detail::matrix_float_8x4_row7> { typedef detail::matrix_float_8x4_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x4,0> matrix_float_8x4_column0; }template <> struct geometric_traits<detail::matrix_float_8x4_column0> { typedef detail::matrix_float_8x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x4,1> matrix_float_8x4_column1; }template <> struct geometric_traits<detail::matrix_float_8x4_column1> { typedef detail::matrix_float_8x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x4,2> matrix_float_8x4_column2; }template <> struct geometric_traits<detail::matrix_float_8x4_column2> { typedef detail::matrix_float_8x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x4,3> matrix_float_8x4_column3; }template <> struct geometric_traits<detail::matrix_float_8x4_column3> { typedef detail::matrix_float_8x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x4>::type > : index_operator_matrix_access_policy < matrix_float_8x4 > { typedef index_operator_matrix_access_policy < matrix_float_8x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x4 > { typedef dimension<8> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 5> matrix_float_8x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,0> matrix_float_8x5_row0; } template <> struct geometric_traits<detail::matrix_float_8x5_row0> { typedef detail::matrix_float_8x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,1> matrix_float_8x5_row1; } template <> struct geometric_traits<detail::matrix_float_8x5_row1> { typedef detail::matrix_float_8x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,2> matrix_float_8x5_row2; } template <> struct geometric_traits<detail::matrix_float_8x5_row2> { typedef detail::matrix_float_8x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,3> matrix_float_8x5_row3; } template <> struct geometric_traits<detail::matrix_float_8x5_row3> { typedef detail::matrix_float_8x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,4> matrix_float_8x5_row4; } template <> struct geometric_traits<detail::matrix_float_8x5_row4> { typedef detail::matrix_float_8x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,5> matrix_float_8x5_row5; } template <> struct geometric_traits<detail::matrix_float_8x5_row5> { typedef detail::matrix_float_8x5_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,6> matrix_float_8x5_row6; } template <> struct geometric_traits<detail::matrix_float_8x5_row6> { typedef detail::matrix_float_8x5_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x5,7> matrix_float_8x5_row7; } template <> struct geometric_traits<detail::matrix_float_8x5_row7> { typedef detail::matrix_float_8x5_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x5,0> matrix_float_8x5_column0; }template <> struct geometric_traits<detail::matrix_float_8x5_column0> { typedef detail::matrix_float_8x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x5,1> matrix_float_8x5_column1; }template <> struct geometric_traits<detail::matrix_float_8x5_column1> { typedef detail::matrix_float_8x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x5,2> matrix_float_8x5_column2; }template <> struct geometric_traits<detail::matrix_float_8x5_column2> { typedef detail::matrix_float_8x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x5,3> matrix_float_8x5_column3; }template <> struct geometric_traits<detail::matrix_float_8x5_column3> { typedef detail::matrix_float_8x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x5,4> matrix_float_8x5_column4; }template <> struct geometric_traits<detail::matrix_float_8x5_column4> { typedef detail::matrix_float_8x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x5>::type > : index_operator_matrix_access_policy < matrix_float_8x5 > { typedef index_operator_matrix_access_policy < matrix_float_8x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x5 > { typedef dimension<8> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 6> matrix_float_8x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,0> matrix_float_8x6_row0; } template <> struct geometric_traits<detail::matrix_float_8x6_row0> { typedef detail::matrix_float_8x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,1> matrix_float_8x6_row1; } template <> struct geometric_traits<detail::matrix_float_8x6_row1> { typedef detail::matrix_float_8x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,2> matrix_float_8x6_row2; } template <> struct geometric_traits<detail::matrix_float_8x6_row2> { typedef detail::matrix_float_8x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,3> matrix_float_8x6_row3; } template <> struct geometric_traits<detail::matrix_float_8x6_row3> { typedef detail::matrix_float_8x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,4> matrix_float_8x6_row4; } template <> struct geometric_traits<detail::matrix_float_8x6_row4> { typedef detail::matrix_float_8x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,5> matrix_float_8x6_row5; } template <> struct geometric_traits<detail::matrix_float_8x6_row5> { typedef detail::matrix_float_8x6_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,6> matrix_float_8x6_row6; } template <> struct geometric_traits<detail::matrix_float_8x6_row6> { typedef detail::matrix_float_8x6_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x6,7> matrix_float_8x6_row7; } template <> struct geometric_traits<detail::matrix_float_8x6_row7> { typedef detail::matrix_float_8x6_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,0> matrix_float_8x6_column0; }template <> struct geometric_traits<detail::matrix_float_8x6_column0> { typedef detail::matrix_float_8x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,1> matrix_float_8x6_column1; }template <> struct geometric_traits<detail::matrix_float_8x6_column1> { typedef detail::matrix_float_8x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,2> matrix_float_8x6_column2; }template <> struct geometric_traits<detail::matrix_float_8x6_column2> { typedef detail::matrix_float_8x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,3> matrix_float_8x6_column3; }template <> struct geometric_traits<detail::matrix_float_8x6_column3> { typedef detail::matrix_float_8x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,4> matrix_float_8x6_column4; }template <> struct geometric_traits<detail::matrix_float_8x6_column4> { typedef detail::matrix_float_8x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x6,5> matrix_float_8x6_column5; }template <> struct geometric_traits<detail::matrix_float_8x6_column5> { typedef detail::matrix_float_8x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x6>::type > : index_operator_matrix_access_policy < matrix_float_8x6 > { typedef index_operator_matrix_access_policy < matrix_float_8x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x6 > { typedef dimension<8> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 7> matrix_float_8x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,0> matrix_float_8x7_row0; } template <> struct geometric_traits<detail::matrix_float_8x7_row0> { typedef detail::matrix_float_8x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,1> matrix_float_8x7_row1; } template <> struct geometric_traits<detail::matrix_float_8x7_row1> { typedef detail::matrix_float_8x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,2> matrix_float_8x7_row2; } template <> struct geometric_traits<detail::matrix_float_8x7_row2> { typedef detail::matrix_float_8x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,3> matrix_float_8x7_row3; } template <> struct geometric_traits<detail::matrix_float_8x7_row3> { typedef detail::matrix_float_8x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,4> matrix_float_8x7_row4; } template <> struct geometric_traits<detail::matrix_float_8x7_row4> { typedef detail::matrix_float_8x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,5> matrix_float_8x7_row5; } template <> struct geometric_traits<detail::matrix_float_8x7_row5> { typedef detail::matrix_float_8x7_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,6> matrix_float_8x7_row6; } template <> struct geometric_traits<detail::matrix_float_8x7_row6> { typedef detail::matrix_float_8x7_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x7,7> matrix_float_8x7_row7; } template <> struct geometric_traits<detail::matrix_float_8x7_row7> { typedef detail::matrix_float_8x7_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,0> matrix_float_8x7_column0; }template <> struct geometric_traits<detail::matrix_float_8x7_column0> { typedef detail::matrix_float_8x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,1> matrix_float_8x7_column1; }template <> struct geometric_traits<detail::matrix_float_8x7_column1> { typedef detail::matrix_float_8x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,2> matrix_float_8x7_column2; }template <> struct geometric_traits<detail::matrix_float_8x7_column2> { typedef detail::matrix_float_8x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,3> matrix_float_8x7_column3; }template <> struct geometric_traits<detail::matrix_float_8x7_column3> { typedef detail::matrix_float_8x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,4> matrix_float_8x7_column4; }template <> struct geometric_traits<detail::matrix_float_8x7_column4> { typedef detail::matrix_float_8x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,5> matrix_float_8x7_column5; }template <> struct geometric_traits<detail::matrix_float_8x7_column5> { typedef detail::matrix_float_8x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x7,6> matrix_float_8x7_column6; }template <> struct geometric_traits<detail::matrix_float_8x7_column6> { typedef detail::matrix_float_8x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x7>::type > : index_operator_matrix_access_policy < matrix_float_8x7 > { typedef index_operator_matrix_access_policy < matrix_float_8x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x7 > { typedef dimension<8> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 8> matrix_float_8x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,0> matrix_float_8x8_row0; } template <> struct geometric_traits<detail::matrix_float_8x8_row0> { typedef detail::matrix_float_8x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,1> matrix_float_8x8_row1; } template <> struct geometric_traits<detail::matrix_float_8x8_row1> { typedef detail::matrix_float_8x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,2> matrix_float_8x8_row2; } template <> struct geometric_traits<detail::matrix_float_8x8_row2> { typedef detail::matrix_float_8x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,3> matrix_float_8x8_row3; } template <> struct geometric_traits<detail::matrix_float_8x8_row3> { typedef detail::matrix_float_8x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,4> matrix_float_8x8_row4; } template <> struct geometric_traits<detail::matrix_float_8x8_row4> { typedef detail::matrix_float_8x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,5> matrix_float_8x8_row5; } template <> struct geometric_traits<detail::matrix_float_8x8_row5> { typedef detail::matrix_float_8x8_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,6> matrix_float_8x8_row6; } template <> struct geometric_traits<detail::matrix_float_8x8_row6> { typedef detail::matrix_float_8x8_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x8,7> matrix_float_8x8_row7; } template <> struct geometric_traits<detail::matrix_float_8x8_row7> { typedef detail::matrix_float_8x8_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,0> matrix_float_8x8_column0; }template <> struct geometric_traits<detail::matrix_float_8x8_column0> { typedef detail::matrix_float_8x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,1> matrix_float_8x8_column1; }template <> struct geometric_traits<detail::matrix_float_8x8_column1> { typedef detail::matrix_float_8x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,2> matrix_float_8x8_column2; }template <> struct geometric_traits<detail::matrix_float_8x8_column2> { typedef detail::matrix_float_8x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,3> matrix_float_8x8_column3; }template <> struct geometric_traits<detail::matrix_float_8x8_column3> { typedef detail::matrix_float_8x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,4> matrix_float_8x8_column4; }template <> struct geometric_traits<detail::matrix_float_8x8_column4> { typedef detail::matrix_float_8x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,5> matrix_float_8x8_column5; }template <> struct geometric_traits<detail::matrix_float_8x8_column5> { typedef detail::matrix_float_8x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,6> matrix_float_8x8_column6; }template <> struct geometric_traits<detail::matrix_float_8x8_column6> { typedef detail::matrix_float_8x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x8,7> matrix_float_8x8_column7; }template <> struct geometric_traits<detail::matrix_float_8x8_column7> { typedef detail::matrix_float_8x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x8>::type > : index_operator_matrix_access_policy < matrix_float_8x8 > { typedef index_operator_matrix_access_policy < matrix_float_8x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x8 > { typedef dimension<8> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 9> matrix_float_8x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,0> matrix_float_8x9_row0; } template <> struct geometric_traits<detail::matrix_float_8x9_row0> { typedef detail::matrix_float_8x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,1> matrix_float_8x9_row1; } template <> struct geometric_traits<detail::matrix_float_8x9_row1> { typedef detail::matrix_float_8x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,2> matrix_float_8x9_row2; } template <> struct geometric_traits<detail::matrix_float_8x9_row2> { typedef detail::matrix_float_8x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,3> matrix_float_8x9_row3; } template <> struct geometric_traits<detail::matrix_float_8x9_row3> { typedef detail::matrix_float_8x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,4> matrix_float_8x9_row4; } template <> struct geometric_traits<detail::matrix_float_8x9_row4> { typedef detail::matrix_float_8x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,5> matrix_float_8x9_row5; } template <> struct geometric_traits<detail::matrix_float_8x9_row5> { typedef detail::matrix_float_8x9_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,6> matrix_float_8x9_row6; } template <> struct geometric_traits<detail::matrix_float_8x9_row6> { typedef detail::matrix_float_8x9_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x9,7> matrix_float_8x9_row7; } template <> struct geometric_traits<detail::matrix_float_8x9_row7> { typedef detail::matrix_float_8x9_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,0> matrix_float_8x9_column0; }template <> struct geometric_traits<detail::matrix_float_8x9_column0> { typedef detail::matrix_float_8x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,1> matrix_float_8x9_column1; }template <> struct geometric_traits<detail::matrix_float_8x9_column1> { typedef detail::matrix_float_8x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,2> matrix_float_8x9_column2; }template <> struct geometric_traits<detail::matrix_float_8x9_column2> { typedef detail::matrix_float_8x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,3> matrix_float_8x9_column3; }template <> struct geometric_traits<detail::matrix_float_8x9_column3> { typedef detail::matrix_float_8x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,4> matrix_float_8x9_column4; }template <> struct geometric_traits<detail::matrix_float_8x9_column4> { typedef detail::matrix_float_8x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,5> matrix_float_8x9_column5; }template <> struct geometric_traits<detail::matrix_float_8x9_column5> { typedef detail::matrix_float_8x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,6> matrix_float_8x9_column6; }template <> struct geometric_traits<detail::matrix_float_8x9_column6> { typedef detail::matrix_float_8x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,7> matrix_float_8x9_column7; }template <> struct geometric_traits<detail::matrix_float_8x9_column7> { typedef detail::matrix_float_8x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x9,8> matrix_float_8x9_column8; }template <> struct geometric_traits<detail::matrix_float_8x9_column8> { typedef detail::matrix_float_8x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x9>::type > : index_operator_matrix_access_policy < matrix_float_8x9 > { typedef index_operator_matrix_access_policy < matrix_float_8x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x9 > { typedef dimension<8> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 8, 10> matrix_float_8x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,0> matrix_float_8x10_row0; } template <> struct geometric_traits<detail::matrix_float_8x10_row0> { typedef detail::matrix_float_8x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,1> matrix_float_8x10_row1; } template <> struct geometric_traits<detail::matrix_float_8x10_row1> { typedef detail::matrix_float_8x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,2> matrix_float_8x10_row2; } template <> struct geometric_traits<detail::matrix_float_8x10_row2> { typedef detail::matrix_float_8x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,3> matrix_float_8x10_row3; } template <> struct geometric_traits<detail::matrix_float_8x10_row3> { typedef detail::matrix_float_8x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,4> matrix_float_8x10_row4; } template <> struct geometric_traits<detail::matrix_float_8x10_row4> { typedef detail::matrix_float_8x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,5> matrix_float_8x10_row5; } template <> struct geometric_traits<detail::matrix_float_8x10_row5> { typedef detail::matrix_float_8x10_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,6> matrix_float_8x10_row6; } template <> struct geometric_traits<detail::matrix_float_8x10_row6> { typedef detail::matrix_float_8x10_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_8x10,7> matrix_float_8x10_row7; } template <> struct geometric_traits<detail::matrix_float_8x10_row7> { typedef detail::matrix_float_8x10_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,0> matrix_float_8x10_column0; }template <> struct geometric_traits<detail::matrix_float_8x10_column0> { typedef detail::matrix_float_8x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,1> matrix_float_8x10_column1; }template <> struct geometric_traits<detail::matrix_float_8x10_column1> { typedef detail::matrix_float_8x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,2> matrix_float_8x10_column2; }template <> struct geometric_traits<detail::matrix_float_8x10_column2> { typedef detail::matrix_float_8x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,3> matrix_float_8x10_column3; }template <> struct geometric_traits<detail::matrix_float_8x10_column3> { typedef detail::matrix_float_8x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,4> matrix_float_8x10_column4; }template <> struct geometric_traits<detail::matrix_float_8x10_column4> { typedef detail::matrix_float_8x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,5> matrix_float_8x10_column5; }template <> struct geometric_traits<detail::matrix_float_8x10_column5> { typedef detail::matrix_float_8x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,6> matrix_float_8x10_column6; }template <> struct geometric_traits<detail::matrix_float_8x10_column6> { typedef detail::matrix_float_8x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,7> matrix_float_8x10_column7; }template <> struct geometric_traits<detail::matrix_float_8x10_column7> { typedef detail::matrix_float_8x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,8> matrix_float_8x10_column8; }template <> struct geometric_traits<detail::matrix_float_8x10_column8> { typedef detail::matrix_float_8x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_8x10,9> matrix_float_8x10_column9; }template <> struct geometric_traits<detail::matrix_float_8x10_column9> { typedef detail::matrix_float_8x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_8x10>::type > : index_operator_matrix_access_policy < matrix_float_8x10 > { typedef index_operator_matrix_access_policy < matrix_float_8x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_8x10 > { typedef dimension<8> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 1> matrix_float_9x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,0> matrix_float_9x1_row0; } template <> struct geometric_traits<detail::matrix_float_9x1_row0> { typedef detail::matrix_float_9x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,1> matrix_float_9x1_row1; } template <> struct geometric_traits<detail::matrix_float_9x1_row1> { typedef detail::matrix_float_9x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,2> matrix_float_9x1_row2; } template <> struct geometric_traits<detail::matrix_float_9x1_row2> { typedef detail::matrix_float_9x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,3> matrix_float_9x1_row3; } template <> struct geometric_traits<detail::matrix_float_9x1_row3> { typedef detail::matrix_float_9x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,4> matrix_float_9x1_row4; } template <> struct geometric_traits<detail::matrix_float_9x1_row4> { typedef detail::matrix_float_9x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,5> matrix_float_9x1_row5; } template <> struct geometric_traits<detail::matrix_float_9x1_row5> { typedef detail::matrix_float_9x1_row5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,6> matrix_float_9x1_row6; } template <> struct geometric_traits<detail::matrix_float_9x1_row6> { typedef detail::matrix_float_9x1_row6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,7> matrix_float_9x1_row7; } template <> struct geometric_traits<detail::matrix_float_9x1_row7> { typedef detail::matrix_float_9x1_row7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x1,8> matrix_float_9x1_row8; } template <> struct geometric_traits<detail::matrix_float_9x1_row8> { typedef detail::matrix_float_9x1_row8 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x1,0> matrix_float_9x1_column0; }template <> struct geometric_traits<detail::matrix_float_9x1_column0> { typedef detail::matrix_float_9x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x1>::type > : index_operator_matrix_access_policy < matrix_float_9x1 > { typedef index_operator_matrix_access_policy < matrix_float_9x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x1 > { typedef dimension<9> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 2> matrix_float_9x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,0> matrix_float_9x2_row0; } template <> struct geometric_traits<detail::matrix_float_9x2_row0> { typedef detail::matrix_float_9x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,1> matrix_float_9x2_row1; } template <> struct geometric_traits<detail::matrix_float_9x2_row1> { typedef detail::matrix_float_9x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,2> matrix_float_9x2_row2; } template <> struct geometric_traits<detail::matrix_float_9x2_row2> { typedef detail::matrix_float_9x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,3> matrix_float_9x2_row3; } template <> struct geometric_traits<detail::matrix_float_9x2_row3> { typedef detail::matrix_float_9x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,4> matrix_float_9x2_row4; } template <> struct geometric_traits<detail::matrix_float_9x2_row4> { typedef detail::matrix_float_9x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,5> matrix_float_9x2_row5; } template <> struct geometric_traits<detail::matrix_float_9x2_row5> { typedef detail::matrix_float_9x2_row5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,6> matrix_float_9x2_row6; } template <> struct geometric_traits<detail::matrix_float_9x2_row6> { typedef detail::matrix_float_9x2_row6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,7> matrix_float_9x2_row7; } template <> struct geometric_traits<detail::matrix_float_9x2_row7> { typedef detail::matrix_float_9x2_row7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x2,8> matrix_float_9x2_row8; } template <> struct geometric_traits<detail::matrix_float_9x2_row8> { typedef detail::matrix_float_9x2_row8 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x2,0> matrix_float_9x2_column0; }template <> struct geometric_traits<detail::matrix_float_9x2_column0> { typedef detail::matrix_float_9x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x2,1> matrix_float_9x2_column1; }template <> struct geometric_traits<detail::matrix_float_9x2_column1> { typedef detail::matrix_float_9x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x2>::type > : index_operator_matrix_access_policy < matrix_float_9x2 > { typedef index_operator_matrix_access_policy < matrix_float_9x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x2 > { typedef dimension<9> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 3> matrix_float_9x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,0> matrix_float_9x3_row0; } template <> struct geometric_traits<detail::matrix_float_9x3_row0> { typedef detail::matrix_float_9x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,1> matrix_float_9x3_row1; } template <> struct geometric_traits<detail::matrix_float_9x3_row1> { typedef detail::matrix_float_9x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,2> matrix_float_9x3_row2; } template <> struct geometric_traits<detail::matrix_float_9x3_row2> { typedef detail::matrix_float_9x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,3> matrix_float_9x3_row3; } template <> struct geometric_traits<detail::matrix_float_9x3_row3> { typedef detail::matrix_float_9x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,4> matrix_float_9x3_row4; } template <> struct geometric_traits<detail::matrix_float_9x3_row4> { typedef detail::matrix_float_9x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,5> matrix_float_9x3_row5; } template <> struct geometric_traits<detail::matrix_float_9x3_row5> { typedef detail::matrix_float_9x3_row5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,6> matrix_float_9x3_row6; } template <> struct geometric_traits<detail::matrix_float_9x3_row6> { typedef detail::matrix_float_9x3_row6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,7> matrix_float_9x3_row7; } template <> struct geometric_traits<detail::matrix_float_9x3_row7> { typedef detail::matrix_float_9x3_row7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x3,8> matrix_float_9x3_row8; } template <> struct geometric_traits<detail::matrix_float_9x3_row8> { typedef detail::matrix_float_9x3_row8 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x3,0> matrix_float_9x3_column0; }template <> struct geometric_traits<detail::matrix_float_9x3_column0> { typedef detail::matrix_float_9x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x3,1> matrix_float_9x3_column1; }template <> struct geometric_traits<detail::matrix_float_9x3_column1> { typedef detail::matrix_float_9x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x3,2> matrix_float_9x3_column2; }template <> struct geometric_traits<detail::matrix_float_9x3_column2> { typedef detail::matrix_float_9x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x3>::type > : index_operator_matrix_access_policy < matrix_float_9x3 > { typedef index_operator_matrix_access_policy < matrix_float_9x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x3 > { typedef dimension<9> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 4> matrix_float_9x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,0> matrix_float_9x4_row0; } template <> struct geometric_traits<detail::matrix_float_9x4_row0> { typedef detail::matrix_float_9x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,1> matrix_float_9x4_row1; } template <> struct geometric_traits<detail::matrix_float_9x4_row1> { typedef detail::matrix_float_9x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,2> matrix_float_9x4_row2; } template <> struct geometric_traits<detail::matrix_float_9x4_row2> { typedef detail::matrix_float_9x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,3> matrix_float_9x4_row3; } template <> struct geometric_traits<detail::matrix_float_9x4_row3> { typedef detail::matrix_float_9x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,4> matrix_float_9x4_row4; } template <> struct geometric_traits<detail::matrix_float_9x4_row4> { typedef detail::matrix_float_9x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,5> matrix_float_9x4_row5; } template <> struct geometric_traits<detail::matrix_float_9x4_row5> { typedef detail::matrix_float_9x4_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,6> matrix_float_9x4_row6; } template <> struct geometric_traits<detail::matrix_float_9x4_row6> { typedef detail::matrix_float_9x4_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,7> matrix_float_9x4_row7; } template <> struct geometric_traits<detail::matrix_float_9x4_row7> { typedef detail::matrix_float_9x4_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x4,8> matrix_float_9x4_row8; } template <> struct geometric_traits<detail::matrix_float_9x4_row8> { typedef detail::matrix_float_9x4_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x4,0> matrix_float_9x4_column0; }template <> struct geometric_traits<detail::matrix_float_9x4_column0> { typedef detail::matrix_float_9x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x4,1> matrix_float_9x4_column1; }template <> struct geometric_traits<detail::matrix_float_9x4_column1> { typedef detail::matrix_float_9x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x4,2> matrix_float_9x4_column2; }template <> struct geometric_traits<detail::matrix_float_9x4_column2> { typedef detail::matrix_float_9x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x4,3> matrix_float_9x4_column3; }template <> struct geometric_traits<detail::matrix_float_9x4_column3> { typedef detail::matrix_float_9x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x4>::type > : index_operator_matrix_access_policy < matrix_float_9x4 > { typedef index_operator_matrix_access_policy < matrix_float_9x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x4 > { typedef dimension<9> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 5> matrix_float_9x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,0> matrix_float_9x5_row0; } template <> struct geometric_traits<detail::matrix_float_9x5_row0> { typedef detail::matrix_float_9x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,1> matrix_float_9x5_row1; } template <> struct geometric_traits<detail::matrix_float_9x5_row1> { typedef detail::matrix_float_9x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,2> matrix_float_9x5_row2; } template <> struct geometric_traits<detail::matrix_float_9x5_row2> { typedef detail::matrix_float_9x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,3> matrix_float_9x5_row3; } template <> struct geometric_traits<detail::matrix_float_9x5_row3> { typedef detail::matrix_float_9x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,4> matrix_float_9x5_row4; } template <> struct geometric_traits<detail::matrix_float_9x5_row4> { typedef detail::matrix_float_9x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,5> matrix_float_9x5_row5; } template <> struct geometric_traits<detail::matrix_float_9x5_row5> { typedef detail::matrix_float_9x5_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,6> matrix_float_9x5_row6; } template <> struct geometric_traits<detail::matrix_float_9x5_row6> { typedef detail::matrix_float_9x5_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,7> matrix_float_9x5_row7; } template <> struct geometric_traits<detail::matrix_float_9x5_row7> { typedef detail::matrix_float_9x5_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x5,8> matrix_float_9x5_row8; } template <> struct geometric_traits<detail::matrix_float_9x5_row8> { typedef detail::matrix_float_9x5_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x5,0> matrix_float_9x5_column0; }template <> struct geometric_traits<detail::matrix_float_9x5_column0> { typedef detail::matrix_float_9x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x5,1> matrix_float_9x5_column1; }template <> struct geometric_traits<detail::matrix_float_9x5_column1> { typedef detail::matrix_float_9x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x5,2> matrix_float_9x5_column2; }template <> struct geometric_traits<detail::matrix_float_9x5_column2> { typedef detail::matrix_float_9x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x5,3> matrix_float_9x5_column3; }template <> struct geometric_traits<detail::matrix_float_9x5_column3> { typedef detail::matrix_float_9x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x5,4> matrix_float_9x5_column4; }template <> struct geometric_traits<detail::matrix_float_9x5_column4> { typedef detail::matrix_float_9x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x5>::type > : index_operator_matrix_access_policy < matrix_float_9x5 > { typedef index_operator_matrix_access_policy < matrix_float_9x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x5 > { typedef dimension<9> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 6> matrix_float_9x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,0> matrix_float_9x6_row0; } template <> struct geometric_traits<detail::matrix_float_9x6_row0> { typedef detail::matrix_float_9x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,1> matrix_float_9x6_row1; } template <> struct geometric_traits<detail::matrix_float_9x6_row1> { typedef detail::matrix_float_9x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,2> matrix_float_9x6_row2; } template <> struct geometric_traits<detail::matrix_float_9x6_row2> { typedef detail::matrix_float_9x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,3> matrix_float_9x6_row3; } template <> struct geometric_traits<detail::matrix_float_9x6_row3> { typedef detail::matrix_float_9x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,4> matrix_float_9x6_row4; } template <> struct geometric_traits<detail::matrix_float_9x6_row4> { typedef detail::matrix_float_9x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,5> matrix_float_9x6_row5; } template <> struct geometric_traits<detail::matrix_float_9x6_row5> { typedef detail::matrix_float_9x6_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,6> matrix_float_9x6_row6; } template <> struct geometric_traits<detail::matrix_float_9x6_row6> { typedef detail::matrix_float_9x6_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,7> matrix_float_9x6_row7; } template <> struct geometric_traits<detail::matrix_float_9x6_row7> { typedef detail::matrix_float_9x6_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x6,8> matrix_float_9x6_row8; } template <> struct geometric_traits<detail::matrix_float_9x6_row8> { typedef detail::matrix_float_9x6_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,0> matrix_float_9x6_column0; }template <> struct geometric_traits<detail::matrix_float_9x6_column0> { typedef detail::matrix_float_9x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,1> matrix_float_9x6_column1; }template <> struct geometric_traits<detail::matrix_float_9x6_column1> { typedef detail::matrix_float_9x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,2> matrix_float_9x6_column2; }template <> struct geometric_traits<detail::matrix_float_9x6_column2> { typedef detail::matrix_float_9x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,3> matrix_float_9x6_column3; }template <> struct geometric_traits<detail::matrix_float_9x6_column3> { typedef detail::matrix_float_9x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,4> matrix_float_9x6_column4; }template <> struct geometric_traits<detail::matrix_float_9x6_column4> { typedef detail::matrix_float_9x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x6,5> matrix_float_9x6_column5; }template <> struct geometric_traits<detail::matrix_float_9x6_column5> { typedef detail::matrix_float_9x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x6>::type > : index_operator_matrix_access_policy < matrix_float_9x6 > { typedef index_operator_matrix_access_policy < matrix_float_9x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x6 > { typedef dimension<9> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 7> matrix_float_9x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,0> matrix_float_9x7_row0; } template <> struct geometric_traits<detail::matrix_float_9x7_row0> { typedef detail::matrix_float_9x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,1> matrix_float_9x7_row1; } template <> struct geometric_traits<detail::matrix_float_9x7_row1> { typedef detail::matrix_float_9x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,2> matrix_float_9x7_row2; } template <> struct geometric_traits<detail::matrix_float_9x7_row2> { typedef detail::matrix_float_9x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,3> matrix_float_9x7_row3; } template <> struct geometric_traits<detail::matrix_float_9x7_row3> { typedef detail::matrix_float_9x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,4> matrix_float_9x7_row4; } template <> struct geometric_traits<detail::matrix_float_9x7_row4> { typedef detail::matrix_float_9x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,5> matrix_float_9x7_row5; } template <> struct geometric_traits<detail::matrix_float_9x7_row5> { typedef detail::matrix_float_9x7_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,6> matrix_float_9x7_row6; } template <> struct geometric_traits<detail::matrix_float_9x7_row6> { typedef detail::matrix_float_9x7_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,7> matrix_float_9x7_row7; } template <> struct geometric_traits<detail::matrix_float_9x7_row7> { typedef detail::matrix_float_9x7_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x7,8> matrix_float_9x7_row8; } template <> struct geometric_traits<detail::matrix_float_9x7_row8> { typedef detail::matrix_float_9x7_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,0> matrix_float_9x7_column0; }template <> struct geometric_traits<detail::matrix_float_9x7_column0> { typedef detail::matrix_float_9x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,1> matrix_float_9x7_column1; }template <> struct geometric_traits<detail::matrix_float_9x7_column1> { typedef detail::matrix_float_9x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,2> matrix_float_9x7_column2; }template <> struct geometric_traits<detail::matrix_float_9x7_column2> { typedef detail::matrix_float_9x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,3> matrix_float_9x7_column3; }template <> struct geometric_traits<detail::matrix_float_9x7_column3> { typedef detail::matrix_float_9x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,4> matrix_float_9x7_column4; }template <> struct geometric_traits<detail::matrix_float_9x7_column4> { typedef detail::matrix_float_9x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,5> matrix_float_9x7_column5; }template <> struct geometric_traits<detail::matrix_float_9x7_column5> { typedef detail::matrix_float_9x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x7,6> matrix_float_9x7_column6; }template <> struct geometric_traits<detail::matrix_float_9x7_column6> { typedef detail::matrix_float_9x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x7>::type > : index_operator_matrix_access_policy < matrix_float_9x7 > { typedef index_operator_matrix_access_policy < matrix_float_9x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x7 > { typedef dimension<9> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 8> matrix_float_9x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,0> matrix_float_9x8_row0; } template <> struct geometric_traits<detail::matrix_float_9x8_row0> { typedef detail::matrix_float_9x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,1> matrix_float_9x8_row1; } template <> struct geometric_traits<detail::matrix_float_9x8_row1> { typedef detail::matrix_float_9x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,2> matrix_float_9x8_row2; } template <> struct geometric_traits<detail::matrix_float_9x8_row2> { typedef detail::matrix_float_9x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,3> matrix_float_9x8_row3; } template <> struct geometric_traits<detail::matrix_float_9x8_row3> { typedef detail::matrix_float_9x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,4> matrix_float_9x8_row4; } template <> struct geometric_traits<detail::matrix_float_9x8_row4> { typedef detail::matrix_float_9x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,5> matrix_float_9x8_row5; } template <> struct geometric_traits<detail::matrix_float_9x8_row5> { typedef detail::matrix_float_9x8_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,6> matrix_float_9x8_row6; } template <> struct geometric_traits<detail::matrix_float_9x8_row6> { typedef detail::matrix_float_9x8_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,7> matrix_float_9x8_row7; } template <> struct geometric_traits<detail::matrix_float_9x8_row7> { typedef detail::matrix_float_9x8_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x8,8> matrix_float_9x8_row8; } template <> struct geometric_traits<detail::matrix_float_9x8_row8> { typedef detail::matrix_float_9x8_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,0> matrix_float_9x8_column0; }template <> struct geometric_traits<detail::matrix_float_9x8_column0> { typedef detail::matrix_float_9x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,1> matrix_float_9x8_column1; }template <> struct geometric_traits<detail::matrix_float_9x8_column1> { typedef detail::matrix_float_9x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,2> matrix_float_9x8_column2; }template <> struct geometric_traits<detail::matrix_float_9x8_column2> { typedef detail::matrix_float_9x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,3> matrix_float_9x8_column3; }template <> struct geometric_traits<detail::matrix_float_9x8_column3> { typedef detail::matrix_float_9x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,4> matrix_float_9x8_column4; }template <> struct geometric_traits<detail::matrix_float_9x8_column4> { typedef detail::matrix_float_9x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,5> matrix_float_9x8_column5; }template <> struct geometric_traits<detail::matrix_float_9x8_column5> { typedef detail::matrix_float_9x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,6> matrix_float_9x8_column6; }template <> struct geometric_traits<detail::matrix_float_9x8_column6> { typedef detail::matrix_float_9x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x8,7> matrix_float_9x8_column7; }template <> struct geometric_traits<detail::matrix_float_9x8_column7> { typedef detail::matrix_float_9x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x8>::type > : index_operator_matrix_access_policy < matrix_float_9x8 > { typedef index_operator_matrix_access_policy < matrix_float_9x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x8 > { typedef dimension<9> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 9> matrix_float_9x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,0> matrix_float_9x9_row0; } template <> struct geometric_traits<detail::matrix_float_9x9_row0> { typedef detail::matrix_float_9x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,1> matrix_float_9x9_row1; } template <> struct geometric_traits<detail::matrix_float_9x9_row1> { typedef detail::matrix_float_9x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,2> matrix_float_9x9_row2; } template <> struct geometric_traits<detail::matrix_float_9x9_row2> { typedef detail::matrix_float_9x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,3> matrix_float_9x9_row3; } template <> struct geometric_traits<detail::matrix_float_9x9_row3> { typedef detail::matrix_float_9x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,4> matrix_float_9x9_row4; } template <> struct geometric_traits<detail::matrix_float_9x9_row4> { typedef detail::matrix_float_9x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,5> matrix_float_9x9_row5; } template <> struct geometric_traits<detail::matrix_float_9x9_row5> { typedef detail::matrix_float_9x9_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,6> matrix_float_9x9_row6; } template <> struct geometric_traits<detail::matrix_float_9x9_row6> { typedef detail::matrix_float_9x9_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,7> matrix_float_9x9_row7; } template <> struct geometric_traits<detail::matrix_float_9x9_row7> { typedef detail::matrix_float_9x9_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x9,8> matrix_float_9x9_row8; } template <> struct geometric_traits<detail::matrix_float_9x9_row8> { typedef detail::matrix_float_9x9_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,0> matrix_float_9x9_column0; }template <> struct geometric_traits<detail::matrix_float_9x9_column0> { typedef detail::matrix_float_9x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,1> matrix_float_9x9_column1; }template <> struct geometric_traits<detail::matrix_float_9x9_column1> { typedef detail::matrix_float_9x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,2> matrix_float_9x9_column2; }template <> struct geometric_traits<detail::matrix_float_9x9_column2> { typedef detail::matrix_float_9x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,3> matrix_float_9x9_column3; }template <> struct geometric_traits<detail::matrix_float_9x9_column3> { typedef detail::matrix_float_9x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,4> matrix_float_9x9_column4; }template <> struct geometric_traits<detail::matrix_float_9x9_column4> { typedef detail::matrix_float_9x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,5> matrix_float_9x9_column5; }template <> struct geometric_traits<detail::matrix_float_9x9_column5> { typedef detail::matrix_float_9x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,6> matrix_float_9x9_column6; }template <> struct geometric_traits<detail::matrix_float_9x9_column6> { typedef detail::matrix_float_9x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,7> matrix_float_9x9_column7; }template <> struct geometric_traits<detail::matrix_float_9x9_column7> { typedef detail::matrix_float_9x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x9,8> matrix_float_9x9_column8; }template <> struct geometric_traits<detail::matrix_float_9x9_column8> { typedef detail::matrix_float_9x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x9>::type > : index_operator_matrix_access_policy < matrix_float_9x9 > { typedef index_operator_matrix_access_policy < matrix_float_9x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x9 > { typedef dimension<9> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 9, 10> matrix_float_9x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,0> matrix_float_9x10_row0; } template <> struct geometric_traits<detail::matrix_float_9x10_row0> { typedef detail::matrix_float_9x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,1> matrix_float_9x10_row1; } template <> struct geometric_traits<detail::matrix_float_9x10_row1> { typedef detail::matrix_float_9x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,2> matrix_float_9x10_row2; } template <> struct geometric_traits<detail::matrix_float_9x10_row2> { typedef detail::matrix_float_9x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,3> matrix_float_9x10_row3; } template <> struct geometric_traits<detail::matrix_float_9x10_row3> { typedef detail::matrix_float_9x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,4> matrix_float_9x10_row4; } template <> struct geometric_traits<detail::matrix_float_9x10_row4> { typedef detail::matrix_float_9x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,5> matrix_float_9x10_row5; } template <> struct geometric_traits<detail::matrix_float_9x10_row5> { typedef detail::matrix_float_9x10_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,6> matrix_float_9x10_row6; } template <> struct geometric_traits<detail::matrix_float_9x10_row6> { typedef detail::matrix_float_9x10_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,7> matrix_float_9x10_row7; } template <> struct geometric_traits<detail::matrix_float_9x10_row7> { typedef detail::matrix_float_9x10_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_9x10,8> matrix_float_9x10_row8; } template <> struct geometric_traits<detail::matrix_float_9x10_row8> { typedef detail::matrix_float_9x10_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,0> matrix_float_9x10_column0; }template <> struct geometric_traits<detail::matrix_float_9x10_column0> { typedef detail::matrix_float_9x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,1> matrix_float_9x10_column1; }template <> struct geometric_traits<detail::matrix_float_9x10_column1> { typedef detail::matrix_float_9x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,2> matrix_float_9x10_column2; }template <> struct geometric_traits<detail::matrix_float_9x10_column2> { typedef detail::matrix_float_9x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,3> matrix_float_9x10_column3; }template <> struct geometric_traits<detail::matrix_float_9x10_column3> { typedef detail::matrix_float_9x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,4> matrix_float_9x10_column4; }template <> struct geometric_traits<detail::matrix_float_9x10_column4> { typedef detail::matrix_float_9x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,5> matrix_float_9x10_column5; }template <> struct geometric_traits<detail::matrix_float_9x10_column5> { typedef detail::matrix_float_9x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,6> matrix_float_9x10_column6; }template <> struct geometric_traits<detail::matrix_float_9x10_column6> { typedef detail::matrix_float_9x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,7> matrix_float_9x10_column7; }template <> struct geometric_traits<detail::matrix_float_9x10_column7> { typedef detail::matrix_float_9x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,8> matrix_float_9x10_column8; }template <> struct geometric_traits<detail::matrix_float_9x10_column8> { typedef detail::matrix_float_9x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_9x10,9> matrix_float_9x10_column9; }template <> struct geometric_traits<detail::matrix_float_9x10_column9> { typedef detail::matrix_float_9x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_9x10>::type > : index_operator_matrix_access_policy < matrix_float_9x10 > { typedef index_operator_matrix_access_policy < matrix_float_9x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_9x10 > { typedef dimension<9> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 1> matrix_float_10x1; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,0> matrix_float_10x1_row0; } template <> struct geometric_traits<detail::matrix_float_10x1_row0> { typedef detail::matrix_float_10x1_row0 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,1> matrix_float_10x1_row1; } template <> struct geometric_traits<detail::matrix_float_10x1_row1> { typedef detail::matrix_float_10x1_row1 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,2> matrix_float_10x1_row2; } template <> struct geometric_traits<detail::matrix_float_10x1_row2> { typedef detail::matrix_float_10x1_row2 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,3> matrix_float_10x1_row3; } template <> struct geometric_traits<detail::matrix_float_10x1_row3> { typedef detail::matrix_float_10x1_row3 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,4> matrix_float_10x1_row4; } template <> struct geometric_traits<detail::matrix_float_10x1_row4> { typedef detail::matrix_float_10x1_row4 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,5> matrix_float_10x1_row5; } template <> struct geometric_traits<detail::matrix_float_10x1_row5> { typedef detail::matrix_float_10x1_row5 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,6> matrix_float_10x1_row6; } template <> struct geometric_traits<detail::matrix_float_10x1_row6> { typedef detail::matrix_float_10x1_row6 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,7> matrix_float_10x1_row7; } template <> struct geometric_traits<detail::matrix_float_10x1_row7> { typedef detail::matrix_float_10x1_row7 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,8> matrix_float_10x1_row8; } template <> struct geometric_traits<detail::matrix_float_10x1_row8> { typedef detail::matrix_float_10x1_row8 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x1,9> matrix_float_10x1_row9; } template <> struct geometric_traits<detail::matrix_float_10x1_row9> { typedef detail::matrix_float_10x1_row9 sequence_type; typedef boost::mpl::vector<float> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x1,0> matrix_float_10x1_column0; }template <> struct geometric_traits<detail::matrix_float_10x1_column0> { typedef detail::matrix_float_10x1_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x1>::type > : index_operator_matrix_access_policy < matrix_float_10x1 > { typedef index_operator_matrix_access_policy < matrix_float_10x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x1 > { typedef dimension<10> row_dimension; typedef dimension<1> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 2> matrix_float_10x2; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,0> matrix_float_10x2_row0; } template <> struct geometric_traits<detail::matrix_float_10x2_row0> { typedef detail::matrix_float_10x2_row0 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,1> matrix_float_10x2_row1; } template <> struct geometric_traits<detail::matrix_float_10x2_row1> { typedef detail::matrix_float_10x2_row1 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,2> matrix_float_10x2_row2; } template <> struct geometric_traits<detail::matrix_float_10x2_row2> { typedef detail::matrix_float_10x2_row2 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,3> matrix_float_10x2_row3; } template <> struct geometric_traits<detail::matrix_float_10x2_row3> { typedef detail::matrix_float_10x2_row3 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,4> matrix_float_10x2_row4; } template <> struct geometric_traits<detail::matrix_float_10x2_row4> { typedef detail::matrix_float_10x2_row4 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,5> matrix_float_10x2_row5; } template <> struct geometric_traits<detail::matrix_float_10x2_row5> { typedef detail::matrix_float_10x2_row5 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,6> matrix_float_10x2_row6; } template <> struct geometric_traits<detail::matrix_float_10x2_row6> { typedef detail::matrix_float_10x2_row6 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,7> matrix_float_10x2_row7; } template <> struct geometric_traits<detail::matrix_float_10x2_row7> { typedef detail::matrix_float_10x2_row7 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,8> matrix_float_10x2_row8; } template <> struct geometric_traits<detail::matrix_float_10x2_row8> { typedef detail::matrix_float_10x2_row8 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x2,9> matrix_float_10x2_row9; } template <> struct geometric_traits<detail::matrix_float_10x2_row9> { typedef detail::matrix_float_10x2_row9 sequence_type; typedef boost::mpl::vector<float, float> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x2,0> matrix_float_10x2_column0; }template <> struct geometric_traits<detail::matrix_float_10x2_column0> { typedef detail::matrix_float_10x2_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x2,1> matrix_float_10x2_column1; }template <> struct geometric_traits<detail::matrix_float_10x2_column1> { typedef detail::matrix_float_10x2_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x2>::type > : index_operator_matrix_access_policy < matrix_float_10x2 > { typedef index_operator_matrix_access_policy < matrix_float_10x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x2 > { typedef dimension<10> row_dimension; typedef dimension<2> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 3> matrix_float_10x3; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,0> matrix_float_10x3_row0; } template <> struct geometric_traits<detail::matrix_float_10x3_row0> { typedef detail::matrix_float_10x3_row0 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,1> matrix_float_10x3_row1; } template <> struct geometric_traits<detail::matrix_float_10x3_row1> { typedef detail::matrix_float_10x3_row1 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,2> matrix_float_10x3_row2; } template <> struct geometric_traits<detail::matrix_float_10x3_row2> { typedef detail::matrix_float_10x3_row2 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,3> matrix_float_10x3_row3; } template <> struct geometric_traits<detail::matrix_float_10x3_row3> { typedef detail::matrix_float_10x3_row3 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,4> matrix_float_10x3_row4; } template <> struct geometric_traits<detail::matrix_float_10x3_row4> { typedef detail::matrix_float_10x3_row4 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,5> matrix_float_10x3_row5; } template <> struct geometric_traits<detail::matrix_float_10x3_row5> { typedef detail::matrix_float_10x3_row5 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,6> matrix_float_10x3_row6; } template <> struct geometric_traits<detail::matrix_float_10x3_row6> { typedef detail::matrix_float_10x3_row6 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,7> matrix_float_10x3_row7; } template <> struct geometric_traits<detail::matrix_float_10x3_row7> { typedef detail::matrix_float_10x3_row7 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,8> matrix_float_10x3_row8; } template <> struct geometric_traits<detail::matrix_float_10x3_row8> { typedef detail::matrix_float_10x3_row8 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x3,9> matrix_float_10x3_row9; } template <> struct geometric_traits<detail::matrix_float_10x3_row9> { typedef detail::matrix_float_10x3_row9 sequence_type; typedef boost::mpl::vector<float, float, float> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x3,0> matrix_float_10x3_column0; }template <> struct geometric_traits<detail::matrix_float_10x3_column0> { typedef detail::matrix_float_10x3_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x3,1> matrix_float_10x3_column1; }template <> struct geometric_traits<detail::matrix_float_10x3_column1> { typedef detail::matrix_float_10x3_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x3,2> matrix_float_10x3_column2; }template <> struct geometric_traits<detail::matrix_float_10x3_column2> { typedef detail::matrix_float_10x3_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x3>::type > : index_operator_matrix_access_policy < matrix_float_10x3 > { typedef index_operator_matrix_access_policy < matrix_float_10x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x3 > { typedef dimension<10> row_dimension; typedef dimension<3> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 4> matrix_float_10x4; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,0> matrix_float_10x4_row0; } template <> struct geometric_traits<detail::matrix_float_10x4_row0> { typedef detail::matrix_float_10x4_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,1> matrix_float_10x4_row1; } template <> struct geometric_traits<detail::matrix_float_10x4_row1> { typedef detail::matrix_float_10x4_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,2> matrix_float_10x4_row2; } template <> struct geometric_traits<detail::matrix_float_10x4_row2> { typedef detail::matrix_float_10x4_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,3> matrix_float_10x4_row3; } template <> struct geometric_traits<detail::matrix_float_10x4_row3> { typedef detail::matrix_float_10x4_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,4> matrix_float_10x4_row4; } template <> struct geometric_traits<detail::matrix_float_10x4_row4> { typedef detail::matrix_float_10x4_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,5> matrix_float_10x4_row5; } template <> struct geometric_traits<detail::matrix_float_10x4_row5> { typedef detail::matrix_float_10x4_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,6> matrix_float_10x4_row6; } template <> struct geometric_traits<detail::matrix_float_10x4_row6> { typedef detail::matrix_float_10x4_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,7> matrix_float_10x4_row7; } template <> struct geometric_traits<detail::matrix_float_10x4_row7> { typedef detail::matrix_float_10x4_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,8> matrix_float_10x4_row8; } template <> struct geometric_traits<detail::matrix_float_10x4_row8> { typedef detail::matrix_float_10x4_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x4,9> matrix_float_10x4_row9; } template <> struct geometric_traits<detail::matrix_float_10x4_row9> { typedef detail::matrix_float_10x4_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x4,0> matrix_float_10x4_column0; }template <> struct geometric_traits<detail::matrix_float_10x4_column0> { typedef detail::matrix_float_10x4_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x4,1> matrix_float_10x4_column1; }template <> struct geometric_traits<detail::matrix_float_10x4_column1> { typedef detail::matrix_float_10x4_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x4,2> matrix_float_10x4_column2; }template <> struct geometric_traits<detail::matrix_float_10x4_column2> { typedef detail::matrix_float_10x4_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x4,3> matrix_float_10x4_column3; }template <> struct geometric_traits<detail::matrix_float_10x4_column3> { typedef detail::matrix_float_10x4_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x4>::type > : index_operator_matrix_access_policy < matrix_float_10x4 > { typedef index_operator_matrix_access_policy < matrix_float_10x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x4 > { typedef dimension<10> row_dimension; typedef dimension<4> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 5> matrix_float_10x5; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,0> matrix_float_10x5_row0; } template <> struct geometric_traits<detail::matrix_float_10x5_row0> { typedef detail::matrix_float_10x5_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,1> matrix_float_10x5_row1; } template <> struct geometric_traits<detail::matrix_float_10x5_row1> { typedef detail::matrix_float_10x5_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,2> matrix_float_10x5_row2; } template <> struct geometric_traits<detail::matrix_float_10x5_row2> { typedef detail::matrix_float_10x5_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,3> matrix_float_10x5_row3; } template <> struct geometric_traits<detail::matrix_float_10x5_row3> { typedef detail::matrix_float_10x5_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,4> matrix_float_10x5_row4; } template <> struct geometric_traits<detail::matrix_float_10x5_row4> { typedef detail::matrix_float_10x5_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,5> matrix_float_10x5_row5; } template <> struct geometric_traits<detail::matrix_float_10x5_row5> { typedef detail::matrix_float_10x5_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,6> matrix_float_10x5_row6; } template <> struct geometric_traits<detail::matrix_float_10x5_row6> { typedef detail::matrix_float_10x5_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,7> matrix_float_10x5_row7; } template <> struct geometric_traits<detail::matrix_float_10x5_row7> { typedef detail::matrix_float_10x5_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,8> matrix_float_10x5_row8; } template <> struct geometric_traits<detail::matrix_float_10x5_row8> { typedef detail::matrix_float_10x5_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x5,9> matrix_float_10x5_row9; } template <> struct geometric_traits<detail::matrix_float_10x5_row9> { typedef detail::matrix_float_10x5_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x5,0> matrix_float_10x5_column0; }template <> struct geometric_traits<detail::matrix_float_10x5_column0> { typedef detail::matrix_float_10x5_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x5,1> matrix_float_10x5_column1; }template <> struct geometric_traits<detail::matrix_float_10x5_column1> { typedef detail::matrix_float_10x5_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x5,2> matrix_float_10x5_column2; }template <> struct geometric_traits<detail::matrix_float_10x5_column2> { typedef detail::matrix_float_10x5_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x5,3> matrix_float_10x5_column3; }template <> struct geometric_traits<detail::matrix_float_10x5_column3> { typedef detail::matrix_float_10x5_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x5,4> matrix_float_10x5_column4; }template <> struct geometric_traits<detail::matrix_float_10x5_column4> { typedef detail::matrix_float_10x5_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x5>::type > : index_operator_matrix_access_policy < matrix_float_10x5 > { typedef index_operator_matrix_access_policy < matrix_float_10x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x5 > { typedef dimension<10> row_dimension; typedef dimension<5> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 6> matrix_float_10x6; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,0> matrix_float_10x6_row0; } template <> struct geometric_traits<detail::matrix_float_10x6_row0> { typedef detail::matrix_float_10x6_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,1> matrix_float_10x6_row1; } template <> struct geometric_traits<detail::matrix_float_10x6_row1> { typedef detail::matrix_float_10x6_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,2> matrix_float_10x6_row2; } template <> struct geometric_traits<detail::matrix_float_10x6_row2> { typedef detail::matrix_float_10x6_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,3> matrix_float_10x6_row3; } template <> struct geometric_traits<detail::matrix_float_10x6_row3> { typedef detail::matrix_float_10x6_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,4> matrix_float_10x6_row4; } template <> struct geometric_traits<detail::matrix_float_10x6_row4> { typedef detail::matrix_float_10x6_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,5> matrix_float_10x6_row5; } template <> struct geometric_traits<detail::matrix_float_10x6_row5> { typedef detail::matrix_float_10x6_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,6> matrix_float_10x6_row6; } template <> struct geometric_traits<detail::matrix_float_10x6_row6> { typedef detail::matrix_float_10x6_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,7> matrix_float_10x6_row7; } template <> struct geometric_traits<detail::matrix_float_10x6_row7> { typedef detail::matrix_float_10x6_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,8> matrix_float_10x6_row8; } template <> struct geometric_traits<detail::matrix_float_10x6_row8> { typedef detail::matrix_float_10x6_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x6,9> matrix_float_10x6_row9; } template <> struct geometric_traits<detail::matrix_float_10x6_row9> { typedef detail::matrix_float_10x6_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,0> matrix_float_10x6_column0; }template <> struct geometric_traits<detail::matrix_float_10x6_column0> { typedef detail::matrix_float_10x6_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,1> matrix_float_10x6_column1; }template <> struct geometric_traits<detail::matrix_float_10x6_column1> { typedef detail::matrix_float_10x6_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,2> matrix_float_10x6_column2; }template <> struct geometric_traits<detail::matrix_float_10x6_column2> { typedef detail::matrix_float_10x6_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,3> matrix_float_10x6_column3; }template <> struct geometric_traits<detail::matrix_float_10x6_column3> { typedef detail::matrix_float_10x6_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,4> matrix_float_10x6_column4; }template <> struct geometric_traits<detail::matrix_float_10x6_column4> { typedef detail::matrix_float_10x6_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x6,5> matrix_float_10x6_column5; }template <> struct geometric_traits<detail::matrix_float_10x6_column5> { typedef detail::matrix_float_10x6_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x6>::type > : index_operator_matrix_access_policy < matrix_float_10x6 > { typedef index_operator_matrix_access_policy < matrix_float_10x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x6 > { typedef dimension<10> row_dimension; typedef dimension<6> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 7> matrix_float_10x7; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,0> matrix_float_10x7_row0; } template <> struct geometric_traits<detail::matrix_float_10x7_row0> { typedef detail::matrix_float_10x7_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,1> matrix_float_10x7_row1; } template <> struct geometric_traits<detail::matrix_float_10x7_row1> { typedef detail::matrix_float_10x7_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,2> matrix_float_10x7_row2; } template <> struct geometric_traits<detail::matrix_float_10x7_row2> { typedef detail::matrix_float_10x7_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,3> matrix_float_10x7_row3; } template <> struct geometric_traits<detail::matrix_float_10x7_row3> { typedef detail::matrix_float_10x7_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,4> matrix_float_10x7_row4; } template <> struct geometric_traits<detail::matrix_float_10x7_row4> { typedef detail::matrix_float_10x7_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,5> matrix_float_10x7_row5; } template <> struct geometric_traits<detail::matrix_float_10x7_row5> { typedef detail::matrix_float_10x7_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,6> matrix_float_10x7_row6; } template <> struct geometric_traits<detail::matrix_float_10x7_row6> { typedef detail::matrix_float_10x7_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,7> matrix_float_10x7_row7; } template <> struct geometric_traits<detail::matrix_float_10x7_row7> { typedef detail::matrix_float_10x7_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,8> matrix_float_10x7_row8; } template <> struct geometric_traits<detail::matrix_float_10x7_row8> { typedef detail::matrix_float_10x7_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x7,9> matrix_float_10x7_row9; } template <> struct geometric_traits<detail::matrix_float_10x7_row9> { typedef detail::matrix_float_10x7_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,0> matrix_float_10x7_column0; }template <> struct geometric_traits<detail::matrix_float_10x7_column0> { typedef detail::matrix_float_10x7_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,1> matrix_float_10x7_column1; }template <> struct geometric_traits<detail::matrix_float_10x7_column1> { typedef detail::matrix_float_10x7_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,2> matrix_float_10x7_column2; }template <> struct geometric_traits<detail::matrix_float_10x7_column2> { typedef detail::matrix_float_10x7_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,3> matrix_float_10x7_column3; }template <> struct geometric_traits<detail::matrix_float_10x7_column3> { typedef detail::matrix_float_10x7_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,4> matrix_float_10x7_column4; }template <> struct geometric_traits<detail::matrix_float_10x7_column4> { typedef detail::matrix_float_10x7_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,5> matrix_float_10x7_column5; }template <> struct geometric_traits<detail::matrix_float_10x7_column5> { typedef detail::matrix_float_10x7_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x7,6> matrix_float_10x7_column6; }template <> struct geometric_traits<detail::matrix_float_10x7_column6> { typedef detail::matrix_float_10x7_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x7>::type > : index_operator_matrix_access_policy < matrix_float_10x7 > { typedef index_operator_matrix_access_policy < matrix_float_10x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x7 > { typedef dimension<10> row_dimension; typedef dimension<7> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 8> matrix_float_10x8; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,0> matrix_float_10x8_row0; } template <> struct geometric_traits<detail::matrix_float_10x8_row0> { typedef detail::matrix_float_10x8_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,1> matrix_float_10x8_row1; } template <> struct geometric_traits<detail::matrix_float_10x8_row1> { typedef detail::matrix_float_10x8_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,2> matrix_float_10x8_row2; } template <> struct geometric_traits<detail::matrix_float_10x8_row2> { typedef detail::matrix_float_10x8_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,3> matrix_float_10x8_row3; } template <> struct geometric_traits<detail::matrix_float_10x8_row3> { typedef detail::matrix_float_10x8_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,4> matrix_float_10x8_row4; } template <> struct geometric_traits<detail::matrix_float_10x8_row4> { typedef detail::matrix_float_10x8_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,5> matrix_float_10x8_row5; } template <> struct geometric_traits<detail::matrix_float_10x8_row5> { typedef detail::matrix_float_10x8_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,6> matrix_float_10x8_row6; } template <> struct geometric_traits<detail::matrix_float_10x8_row6> { typedef detail::matrix_float_10x8_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,7> matrix_float_10x8_row7; } template <> struct geometric_traits<detail::matrix_float_10x8_row7> { typedef detail::matrix_float_10x8_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,8> matrix_float_10x8_row8; } template <> struct geometric_traits<detail::matrix_float_10x8_row8> { typedef detail::matrix_float_10x8_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x8,9> matrix_float_10x8_row9; } template <> struct geometric_traits<detail::matrix_float_10x8_row9> { typedef detail::matrix_float_10x8_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,0> matrix_float_10x8_column0; }template <> struct geometric_traits<detail::matrix_float_10x8_column0> { typedef detail::matrix_float_10x8_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,1> matrix_float_10x8_column1; }template <> struct geometric_traits<detail::matrix_float_10x8_column1> { typedef detail::matrix_float_10x8_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,2> matrix_float_10x8_column2; }template <> struct geometric_traits<detail::matrix_float_10x8_column2> { typedef detail::matrix_float_10x8_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,3> matrix_float_10x8_column3; }template <> struct geometric_traits<detail::matrix_float_10x8_column3> { typedef detail::matrix_float_10x8_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,4> matrix_float_10x8_column4; }template <> struct geometric_traits<detail::matrix_float_10x8_column4> { typedef detail::matrix_float_10x8_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,5> matrix_float_10x8_column5; }template <> struct geometric_traits<detail::matrix_float_10x8_column5> { typedef detail::matrix_float_10x8_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,6> matrix_float_10x8_column6; }template <> struct geometric_traits<detail::matrix_float_10x8_column6> { typedef detail::matrix_float_10x8_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x8,7> matrix_float_10x8_column7; }template <> struct geometric_traits<detail::matrix_float_10x8_column7> { typedef detail::matrix_float_10x8_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x8>::type > : index_operator_matrix_access_policy < matrix_float_10x8 > { typedef index_operator_matrix_access_policy < matrix_float_10x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x8 > { typedef dimension<10> row_dimension; typedef dimension<8> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 9> matrix_float_10x9; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,0> matrix_float_10x9_row0; } template <> struct geometric_traits<detail::matrix_float_10x9_row0> { typedef detail::matrix_float_10x9_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,1> matrix_float_10x9_row1; } template <> struct geometric_traits<detail::matrix_float_10x9_row1> { typedef detail::matrix_float_10x9_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,2> matrix_float_10x9_row2; } template <> struct geometric_traits<detail::matrix_float_10x9_row2> { typedef detail::matrix_float_10x9_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,3> matrix_float_10x9_row3; } template <> struct geometric_traits<detail::matrix_float_10x9_row3> { typedef detail::matrix_float_10x9_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,4> matrix_float_10x9_row4; } template <> struct geometric_traits<detail::matrix_float_10x9_row4> { typedef detail::matrix_float_10x9_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,5> matrix_float_10x9_row5; } template <> struct geometric_traits<detail::matrix_float_10x9_row5> { typedef detail::matrix_float_10x9_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,6> matrix_float_10x9_row6; } template <> struct geometric_traits<detail::matrix_float_10x9_row6> { typedef detail::matrix_float_10x9_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,7> matrix_float_10x9_row7; } template <> struct geometric_traits<detail::matrix_float_10x9_row7> { typedef detail::matrix_float_10x9_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,8> matrix_float_10x9_row8; } template <> struct geometric_traits<detail::matrix_float_10x9_row8> { typedef detail::matrix_float_10x9_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x9,9> matrix_float_10x9_row9; } template <> struct geometric_traits<detail::matrix_float_10x9_row9> { typedef detail::matrix_float_10x9_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,0> matrix_float_10x9_column0; }template <> struct geometric_traits<detail::matrix_float_10x9_column0> { typedef detail::matrix_float_10x9_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,1> matrix_float_10x9_column1; }template <> struct geometric_traits<detail::matrix_float_10x9_column1> { typedef detail::matrix_float_10x9_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,2> matrix_float_10x9_column2; }template <> struct geometric_traits<detail::matrix_float_10x9_column2> { typedef detail::matrix_float_10x9_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,3> matrix_float_10x9_column3; }template <> struct geometric_traits<detail::matrix_float_10x9_column3> { typedef detail::matrix_float_10x9_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,4> matrix_float_10x9_column4; }template <> struct geometric_traits<detail::matrix_float_10x9_column4> { typedef detail::matrix_float_10x9_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,5> matrix_float_10x9_column5; }template <> struct geometric_traits<detail::matrix_float_10x9_column5> { typedef detail::matrix_float_10x9_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,6> matrix_float_10x9_column6; }template <> struct geometric_traits<detail::matrix_float_10x9_column6> { typedef detail::matrix_float_10x9_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,7> matrix_float_10x9_column7; }template <> struct geometric_traits<detail::matrix_float_10x9_column7> { typedef detail::matrix_float_10x9_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x9,8> matrix_float_10x9_column8; }template <> struct geometric_traits<detail::matrix_float_10x9_column8> { typedef detail::matrix_float_10x9_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x9>::type > : index_operator_matrix_access_policy < matrix_float_10x9 > { typedef index_operator_matrix_access_policy < matrix_float_10x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x9 > { typedef dimension<10> row_dimension; typedef dimension<9> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<float, 10, 10> matrix_float_10x10; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,0> matrix_float_10x10_row0; } template <> struct geometric_traits<detail::matrix_float_10x10_row0> { typedef detail::matrix_float_10x10_row0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,1> matrix_float_10x10_row1; } template <> struct geometric_traits<detail::matrix_float_10x10_row1> { typedef detail::matrix_float_10x10_row1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,2> matrix_float_10x10_row2; } template <> struct geometric_traits<detail::matrix_float_10x10_row2> { typedef detail::matrix_float_10x10_row2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,3> matrix_float_10x10_row3; } template <> struct geometric_traits<detail::matrix_float_10x10_row3> { typedef detail::matrix_float_10x10_row3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,4> matrix_float_10x10_row4; } template <> struct geometric_traits<detail::matrix_float_10x10_row4> { typedef detail::matrix_float_10x10_row4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,5> matrix_float_10x10_row5; } template <> struct geometric_traits<detail::matrix_float_10x10_row5> { typedef detail::matrix_float_10x10_row5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,6> matrix_float_10x10_row6; } template <> struct geometric_traits<detail::matrix_float_10x10_row6> { typedef detail::matrix_float_10x10_row6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,7> matrix_float_10x10_row7; } template <> struct geometric_traits<detail::matrix_float_10x10_row7> { typedef detail::matrix_float_10x10_row7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,8> matrix_float_10x10_row8; } template <> struct geometric_traits<detail::matrix_float_10x10_row8> { typedef detail::matrix_float_10x10_row8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_float_10x10,9> matrix_float_10x10_row9; } template <> struct geometric_traits<detail::matrix_float_10x10_row9> { typedef detail::matrix_float_10x10_row9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,0> matrix_float_10x10_column0; }template <> struct geometric_traits<detail::matrix_float_10x10_column0> { typedef detail::matrix_float_10x10_column0 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,1> matrix_float_10x10_column1; }template <> struct geometric_traits<detail::matrix_float_10x10_column1> { typedef detail::matrix_float_10x10_column1 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,2> matrix_float_10x10_column2; }template <> struct geometric_traits<detail::matrix_float_10x10_column2> { typedef detail::matrix_float_10x10_column2 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,3> matrix_float_10x10_column3; }template <> struct geometric_traits<detail::matrix_float_10x10_column3> { typedef detail::matrix_float_10x10_column3 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,4> matrix_float_10x10_column4; }template <> struct geometric_traits<detail::matrix_float_10x10_column4> { typedef detail::matrix_float_10x10_column4 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,5> matrix_float_10x10_column5; }template <> struct geometric_traits<detail::matrix_float_10x10_column5> { typedef detail::matrix_float_10x10_column5 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,6> matrix_float_10x10_column6; }template <> struct geometric_traits<detail::matrix_float_10x10_column6> { typedef detail::matrix_float_10x10_column6 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,7> matrix_float_10x10_column7; }template <> struct geometric_traits<detail::matrix_float_10x10_column7> { typedef detail::matrix_float_10x10_column7 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,8> matrix_float_10x10_column8; }template <> struct geometric_traits<detail::matrix_float_10x10_column8> { typedef detail::matrix_float_10x10_column8 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_float_10x10,9> matrix_float_10x10_column9; }template <> struct geometric_traits<detail::matrix_float_10x10_column9> { typedef detail::matrix_float_10x10_column9 sequence_type; typedef boost::mpl::vector<float, float, float, float, float, float, float, float, float, float> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_float_10x10>::type > : index_operator_matrix_access_policy < matrix_float_10x10 > { typedef index_operator_matrix_access_policy < matrix_float_10x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_float_10x10 > { typedef dimension<10> row_dimension; typedef dimension<10> col_dimension; typedef float arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; }
    namespace geometrix { typedef matrix<int, 1, 1> matrix_int_1x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x1,0> matrix_int_1x1_row0; } template <> struct geometric_traits<detail::matrix_int_1x1_row0> { typedef detail::matrix_int_1x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x1,0> matrix_int_1x1_column0; }template <> struct geometric_traits<detail::matrix_int_1x1_column0> { typedef detail::matrix_int_1x1_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x1>::type > : index_operator_matrix_access_policy < matrix_int_1x1 > { typedef index_operator_matrix_access_policy < matrix_int_1x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x1 > { typedef dimension<1> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 2> matrix_int_1x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x2,0> matrix_int_1x2_row0; } template <> struct geometric_traits<detail::matrix_int_1x2_row0> { typedef detail::matrix_int_1x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x2,0> matrix_int_1x2_column0; }template <> struct geometric_traits<detail::matrix_int_1x2_column0> { typedef detail::matrix_int_1x2_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x2,1> matrix_int_1x2_column1; }template <> struct geometric_traits<detail::matrix_int_1x2_column1> { typedef detail::matrix_int_1x2_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x2>::type > : index_operator_matrix_access_policy < matrix_int_1x2 > { typedef index_operator_matrix_access_policy < matrix_int_1x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x2 > { typedef dimension<1> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 3> matrix_int_1x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x3,0> matrix_int_1x3_row0; } template <> struct geometric_traits<detail::matrix_int_1x3_row0> { typedef detail::matrix_int_1x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x3,0> matrix_int_1x3_column0; }template <> struct geometric_traits<detail::matrix_int_1x3_column0> { typedef detail::matrix_int_1x3_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x3,1> matrix_int_1x3_column1; }template <> struct geometric_traits<detail::matrix_int_1x3_column1> { typedef detail::matrix_int_1x3_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x3,2> matrix_int_1x3_column2; }template <> struct geometric_traits<detail::matrix_int_1x3_column2> { typedef detail::matrix_int_1x3_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x3>::type > : index_operator_matrix_access_policy < matrix_int_1x3 > { typedef index_operator_matrix_access_policy < matrix_int_1x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x3 > { typedef dimension<1> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 4> matrix_int_1x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x4,0> matrix_int_1x4_row0; } template <> struct geometric_traits<detail::matrix_int_1x4_row0> { typedef detail::matrix_int_1x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x4,0> matrix_int_1x4_column0; }template <> struct geometric_traits<detail::matrix_int_1x4_column0> { typedef detail::matrix_int_1x4_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x4,1> matrix_int_1x4_column1; }template <> struct geometric_traits<detail::matrix_int_1x4_column1> { typedef detail::matrix_int_1x4_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x4,2> matrix_int_1x4_column2; }template <> struct geometric_traits<detail::matrix_int_1x4_column2> { typedef detail::matrix_int_1x4_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x4,3> matrix_int_1x4_column3; }template <> struct geometric_traits<detail::matrix_int_1x4_column3> { typedef detail::matrix_int_1x4_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x4>::type > : index_operator_matrix_access_policy < matrix_int_1x4 > { typedef index_operator_matrix_access_policy < matrix_int_1x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x4 > { typedef dimension<1> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 5> matrix_int_1x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x5,0> matrix_int_1x5_row0; } template <> struct geometric_traits<detail::matrix_int_1x5_row0> { typedef detail::matrix_int_1x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x5,0> matrix_int_1x5_column0; }template <> struct geometric_traits<detail::matrix_int_1x5_column0> { typedef detail::matrix_int_1x5_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x5,1> matrix_int_1x5_column1; }template <> struct geometric_traits<detail::matrix_int_1x5_column1> { typedef detail::matrix_int_1x5_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x5,2> matrix_int_1x5_column2; }template <> struct geometric_traits<detail::matrix_int_1x5_column2> { typedef detail::matrix_int_1x5_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x5,3> matrix_int_1x5_column3; }template <> struct geometric_traits<detail::matrix_int_1x5_column3> { typedef detail::matrix_int_1x5_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x5,4> matrix_int_1x5_column4; }template <> struct geometric_traits<detail::matrix_int_1x5_column4> { typedef detail::matrix_int_1x5_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x5>::type > : index_operator_matrix_access_policy < matrix_int_1x5 > { typedef index_operator_matrix_access_policy < matrix_int_1x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x5 > { typedef dimension<1> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 6> matrix_int_1x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x6,0> matrix_int_1x6_row0; } template <> struct geometric_traits<detail::matrix_int_1x6_row0> { typedef detail::matrix_int_1x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,0> matrix_int_1x6_column0; }template <> struct geometric_traits<detail::matrix_int_1x6_column0> { typedef detail::matrix_int_1x6_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,1> matrix_int_1x6_column1; }template <> struct geometric_traits<detail::matrix_int_1x6_column1> { typedef detail::matrix_int_1x6_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,2> matrix_int_1x6_column2; }template <> struct geometric_traits<detail::matrix_int_1x6_column2> { typedef detail::matrix_int_1x6_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,3> matrix_int_1x6_column3; }template <> struct geometric_traits<detail::matrix_int_1x6_column3> { typedef detail::matrix_int_1x6_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,4> matrix_int_1x6_column4; }template <> struct geometric_traits<detail::matrix_int_1x6_column4> { typedef detail::matrix_int_1x6_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x6,5> matrix_int_1x6_column5; }template <> struct geometric_traits<detail::matrix_int_1x6_column5> { typedef detail::matrix_int_1x6_column5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x6>::type > : index_operator_matrix_access_policy < matrix_int_1x6 > { typedef index_operator_matrix_access_policy < matrix_int_1x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x6 > { typedef dimension<1> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 7> matrix_int_1x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x7,0> matrix_int_1x7_row0; } template <> struct geometric_traits<detail::matrix_int_1x7_row0> { typedef detail::matrix_int_1x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,0> matrix_int_1x7_column0; }template <> struct geometric_traits<detail::matrix_int_1x7_column0> { typedef detail::matrix_int_1x7_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,1> matrix_int_1x7_column1; }template <> struct geometric_traits<detail::matrix_int_1x7_column1> { typedef detail::matrix_int_1x7_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,2> matrix_int_1x7_column2; }template <> struct geometric_traits<detail::matrix_int_1x7_column2> { typedef detail::matrix_int_1x7_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,3> matrix_int_1x7_column3; }template <> struct geometric_traits<detail::matrix_int_1x7_column3> { typedef detail::matrix_int_1x7_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,4> matrix_int_1x7_column4; }template <> struct geometric_traits<detail::matrix_int_1x7_column4> { typedef detail::matrix_int_1x7_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,5> matrix_int_1x7_column5; }template <> struct geometric_traits<detail::matrix_int_1x7_column5> { typedef detail::matrix_int_1x7_column5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x7,6> matrix_int_1x7_column6; }template <> struct geometric_traits<detail::matrix_int_1x7_column6> { typedef detail::matrix_int_1x7_column6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x7>::type > : index_operator_matrix_access_policy < matrix_int_1x7 > { typedef index_operator_matrix_access_policy < matrix_int_1x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x7 > { typedef dimension<1> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 8> matrix_int_1x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x8,0> matrix_int_1x8_row0; } template <> struct geometric_traits<detail::matrix_int_1x8_row0> { typedef detail::matrix_int_1x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,0> matrix_int_1x8_column0; }template <> struct geometric_traits<detail::matrix_int_1x8_column0> { typedef detail::matrix_int_1x8_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,1> matrix_int_1x8_column1; }template <> struct geometric_traits<detail::matrix_int_1x8_column1> { typedef detail::matrix_int_1x8_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,2> matrix_int_1x8_column2; }template <> struct geometric_traits<detail::matrix_int_1x8_column2> { typedef detail::matrix_int_1x8_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,3> matrix_int_1x8_column3; }template <> struct geometric_traits<detail::matrix_int_1x8_column3> { typedef detail::matrix_int_1x8_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,4> matrix_int_1x8_column4; }template <> struct geometric_traits<detail::matrix_int_1x8_column4> { typedef detail::matrix_int_1x8_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,5> matrix_int_1x8_column5; }template <> struct geometric_traits<detail::matrix_int_1x8_column5> { typedef detail::matrix_int_1x8_column5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,6> matrix_int_1x8_column6; }template <> struct geometric_traits<detail::matrix_int_1x8_column6> { typedef detail::matrix_int_1x8_column6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x8,7> matrix_int_1x8_column7; }template <> struct geometric_traits<detail::matrix_int_1x8_column7> { typedef detail::matrix_int_1x8_column7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x8>::type > : index_operator_matrix_access_policy < matrix_int_1x8 > { typedef index_operator_matrix_access_policy < matrix_int_1x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x8 > { typedef dimension<1> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 9> matrix_int_1x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x9,0> matrix_int_1x9_row0; } template <> struct geometric_traits<detail::matrix_int_1x9_row0> { typedef detail::matrix_int_1x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,0> matrix_int_1x9_column0; }template <> struct geometric_traits<detail::matrix_int_1x9_column0> { typedef detail::matrix_int_1x9_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,1> matrix_int_1x9_column1; }template <> struct geometric_traits<detail::matrix_int_1x9_column1> { typedef detail::matrix_int_1x9_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,2> matrix_int_1x9_column2; }template <> struct geometric_traits<detail::matrix_int_1x9_column2> { typedef detail::matrix_int_1x9_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,3> matrix_int_1x9_column3; }template <> struct geometric_traits<detail::matrix_int_1x9_column3> { typedef detail::matrix_int_1x9_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,4> matrix_int_1x9_column4; }template <> struct geometric_traits<detail::matrix_int_1x9_column4> { typedef detail::matrix_int_1x9_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,5> matrix_int_1x9_column5; }template <> struct geometric_traits<detail::matrix_int_1x9_column5> { typedef detail::matrix_int_1x9_column5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,6> matrix_int_1x9_column6; }template <> struct geometric_traits<detail::matrix_int_1x9_column6> { typedef detail::matrix_int_1x9_column6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,7> matrix_int_1x9_column7; }template <> struct geometric_traits<detail::matrix_int_1x9_column7> { typedef detail::matrix_int_1x9_column7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x9,8> matrix_int_1x9_column8; }template <> struct geometric_traits<detail::matrix_int_1x9_column8> { typedef detail::matrix_int_1x9_column8 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x9>::type > : index_operator_matrix_access_policy < matrix_int_1x9 > { typedef index_operator_matrix_access_policy < matrix_int_1x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x9 > { typedef dimension<1> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 1, 10> matrix_int_1x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_1x10,0> matrix_int_1x10_row0; } template <> struct geometric_traits<detail::matrix_int_1x10_row0> { typedef detail::matrix_int_1x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,0> matrix_int_1x10_column0; }template <> struct geometric_traits<detail::matrix_int_1x10_column0> { typedef detail::matrix_int_1x10_column0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,1> matrix_int_1x10_column1; }template <> struct geometric_traits<detail::matrix_int_1x10_column1> { typedef detail::matrix_int_1x10_column1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,2> matrix_int_1x10_column2; }template <> struct geometric_traits<detail::matrix_int_1x10_column2> { typedef detail::matrix_int_1x10_column2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,3> matrix_int_1x10_column3; }template <> struct geometric_traits<detail::matrix_int_1x10_column3> { typedef detail::matrix_int_1x10_column3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,4> matrix_int_1x10_column4; }template <> struct geometric_traits<detail::matrix_int_1x10_column4> { typedef detail::matrix_int_1x10_column4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,5> matrix_int_1x10_column5; }template <> struct geometric_traits<detail::matrix_int_1x10_column5> { typedef detail::matrix_int_1x10_column5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,6> matrix_int_1x10_column6; }template <> struct geometric_traits<detail::matrix_int_1x10_column6> { typedef detail::matrix_int_1x10_column6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,7> matrix_int_1x10_column7; }template <> struct geometric_traits<detail::matrix_int_1x10_column7> { typedef detail::matrix_int_1x10_column7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,8> matrix_int_1x10_column8; }template <> struct geometric_traits<detail::matrix_int_1x10_column8> { typedef detail::matrix_int_1x10_column8 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_1x10,9> matrix_int_1x10_column9; }template <> struct geometric_traits<detail::matrix_int_1x10_column9> { typedef detail::matrix_int_1x10_column9 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_1x10>::type > : index_operator_matrix_access_policy < matrix_int_1x10 > { typedef index_operator_matrix_access_policy < matrix_int_1x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_1x10 > { typedef dimension<1> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 1> matrix_int_2x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x1,0> matrix_int_2x1_row0; } template <> struct geometric_traits<detail::matrix_int_2x1_row0> { typedef detail::matrix_int_2x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x1,1> matrix_int_2x1_row1; } template <> struct geometric_traits<detail::matrix_int_2x1_row1> { typedef detail::matrix_int_2x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x1,0> matrix_int_2x1_column0; }template <> struct geometric_traits<detail::matrix_int_2x1_column0> { typedef detail::matrix_int_2x1_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x1>::type > : index_operator_matrix_access_policy < matrix_int_2x1 > { typedef index_operator_matrix_access_policy < matrix_int_2x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x1 > { typedef dimension<2> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 2> matrix_int_2x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x2,0> matrix_int_2x2_row0; } template <> struct geometric_traits<detail::matrix_int_2x2_row0> { typedef detail::matrix_int_2x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x2,1> matrix_int_2x2_row1; } template <> struct geometric_traits<detail::matrix_int_2x2_row1> { typedef detail::matrix_int_2x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x2,0> matrix_int_2x2_column0; }template <> struct geometric_traits<detail::matrix_int_2x2_column0> { typedef detail::matrix_int_2x2_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x2,1> matrix_int_2x2_column1; }template <> struct geometric_traits<detail::matrix_int_2x2_column1> { typedef detail::matrix_int_2x2_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x2>::type > : index_operator_matrix_access_policy < matrix_int_2x2 > { typedef index_operator_matrix_access_policy < matrix_int_2x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x2 > { typedef dimension<2> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 3> matrix_int_2x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x3,0> matrix_int_2x3_row0; } template <> struct geometric_traits<detail::matrix_int_2x3_row0> { typedef detail::matrix_int_2x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x3,1> matrix_int_2x3_row1; } template <> struct geometric_traits<detail::matrix_int_2x3_row1> { typedef detail::matrix_int_2x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x3,0> matrix_int_2x3_column0; }template <> struct geometric_traits<detail::matrix_int_2x3_column0> { typedef detail::matrix_int_2x3_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x3,1> matrix_int_2x3_column1; }template <> struct geometric_traits<detail::matrix_int_2x3_column1> { typedef detail::matrix_int_2x3_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x3,2> matrix_int_2x3_column2; }template <> struct geometric_traits<detail::matrix_int_2x3_column2> { typedef detail::matrix_int_2x3_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x3>::type > : index_operator_matrix_access_policy < matrix_int_2x3 > { typedef index_operator_matrix_access_policy < matrix_int_2x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x3 > { typedef dimension<2> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 4> matrix_int_2x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x4,0> matrix_int_2x4_row0; } template <> struct geometric_traits<detail::matrix_int_2x4_row0> { typedef detail::matrix_int_2x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x4,1> matrix_int_2x4_row1; } template <> struct geometric_traits<detail::matrix_int_2x4_row1> { typedef detail::matrix_int_2x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x4,0> matrix_int_2x4_column0; }template <> struct geometric_traits<detail::matrix_int_2x4_column0> { typedef detail::matrix_int_2x4_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x4,1> matrix_int_2x4_column1; }template <> struct geometric_traits<detail::matrix_int_2x4_column1> { typedef detail::matrix_int_2x4_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x4,2> matrix_int_2x4_column2; }template <> struct geometric_traits<detail::matrix_int_2x4_column2> { typedef detail::matrix_int_2x4_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x4,3> matrix_int_2x4_column3; }template <> struct geometric_traits<detail::matrix_int_2x4_column3> { typedef detail::matrix_int_2x4_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x4>::type > : index_operator_matrix_access_policy < matrix_int_2x4 > { typedef index_operator_matrix_access_policy < matrix_int_2x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x4 > { typedef dimension<2> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 5> matrix_int_2x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x5,0> matrix_int_2x5_row0; } template <> struct geometric_traits<detail::matrix_int_2x5_row0> { typedef detail::matrix_int_2x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x5,1> matrix_int_2x5_row1; } template <> struct geometric_traits<detail::matrix_int_2x5_row1> { typedef detail::matrix_int_2x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x5,0> matrix_int_2x5_column0; }template <> struct geometric_traits<detail::matrix_int_2x5_column0> { typedef detail::matrix_int_2x5_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x5,1> matrix_int_2x5_column1; }template <> struct geometric_traits<detail::matrix_int_2x5_column1> { typedef detail::matrix_int_2x5_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x5,2> matrix_int_2x5_column2; }template <> struct geometric_traits<detail::matrix_int_2x5_column2> { typedef detail::matrix_int_2x5_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x5,3> matrix_int_2x5_column3; }template <> struct geometric_traits<detail::matrix_int_2x5_column3> { typedef detail::matrix_int_2x5_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x5,4> matrix_int_2x5_column4; }template <> struct geometric_traits<detail::matrix_int_2x5_column4> { typedef detail::matrix_int_2x5_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x5>::type > : index_operator_matrix_access_policy < matrix_int_2x5 > { typedef index_operator_matrix_access_policy < matrix_int_2x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x5 > { typedef dimension<2> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 6> matrix_int_2x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x6,0> matrix_int_2x6_row0; } template <> struct geometric_traits<detail::matrix_int_2x6_row0> { typedef detail::matrix_int_2x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x6,1> matrix_int_2x6_row1; } template <> struct geometric_traits<detail::matrix_int_2x6_row1> { typedef detail::matrix_int_2x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,0> matrix_int_2x6_column0; }template <> struct geometric_traits<detail::matrix_int_2x6_column0> { typedef detail::matrix_int_2x6_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,1> matrix_int_2x6_column1; }template <> struct geometric_traits<detail::matrix_int_2x6_column1> { typedef detail::matrix_int_2x6_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,2> matrix_int_2x6_column2; }template <> struct geometric_traits<detail::matrix_int_2x6_column2> { typedef detail::matrix_int_2x6_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,3> matrix_int_2x6_column3; }template <> struct geometric_traits<detail::matrix_int_2x6_column3> { typedef detail::matrix_int_2x6_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,4> matrix_int_2x6_column4; }template <> struct geometric_traits<detail::matrix_int_2x6_column4> { typedef detail::matrix_int_2x6_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x6,5> matrix_int_2x6_column5; }template <> struct geometric_traits<detail::matrix_int_2x6_column5> { typedef detail::matrix_int_2x6_column5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x6>::type > : index_operator_matrix_access_policy < matrix_int_2x6 > { typedef index_operator_matrix_access_policy < matrix_int_2x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x6 > { typedef dimension<2> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 7> matrix_int_2x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x7,0> matrix_int_2x7_row0; } template <> struct geometric_traits<detail::matrix_int_2x7_row0> { typedef detail::matrix_int_2x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x7,1> matrix_int_2x7_row1; } template <> struct geometric_traits<detail::matrix_int_2x7_row1> { typedef detail::matrix_int_2x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,0> matrix_int_2x7_column0; }template <> struct geometric_traits<detail::matrix_int_2x7_column0> { typedef detail::matrix_int_2x7_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,1> matrix_int_2x7_column1; }template <> struct geometric_traits<detail::matrix_int_2x7_column1> { typedef detail::matrix_int_2x7_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,2> matrix_int_2x7_column2; }template <> struct geometric_traits<detail::matrix_int_2x7_column2> { typedef detail::matrix_int_2x7_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,3> matrix_int_2x7_column3; }template <> struct geometric_traits<detail::matrix_int_2x7_column3> { typedef detail::matrix_int_2x7_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,4> matrix_int_2x7_column4; }template <> struct geometric_traits<detail::matrix_int_2x7_column4> { typedef detail::matrix_int_2x7_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,5> matrix_int_2x7_column5; }template <> struct geometric_traits<detail::matrix_int_2x7_column5> { typedef detail::matrix_int_2x7_column5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x7,6> matrix_int_2x7_column6; }template <> struct geometric_traits<detail::matrix_int_2x7_column6> { typedef detail::matrix_int_2x7_column6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x7>::type > : index_operator_matrix_access_policy < matrix_int_2x7 > { typedef index_operator_matrix_access_policy < matrix_int_2x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x7 > { typedef dimension<2> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 8> matrix_int_2x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x8,0> matrix_int_2x8_row0; } template <> struct geometric_traits<detail::matrix_int_2x8_row0> { typedef detail::matrix_int_2x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x8,1> matrix_int_2x8_row1; } template <> struct geometric_traits<detail::matrix_int_2x8_row1> { typedef detail::matrix_int_2x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,0> matrix_int_2x8_column0; }template <> struct geometric_traits<detail::matrix_int_2x8_column0> { typedef detail::matrix_int_2x8_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,1> matrix_int_2x8_column1; }template <> struct geometric_traits<detail::matrix_int_2x8_column1> { typedef detail::matrix_int_2x8_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,2> matrix_int_2x8_column2; }template <> struct geometric_traits<detail::matrix_int_2x8_column2> { typedef detail::matrix_int_2x8_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,3> matrix_int_2x8_column3; }template <> struct geometric_traits<detail::matrix_int_2x8_column3> { typedef detail::matrix_int_2x8_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,4> matrix_int_2x8_column4; }template <> struct geometric_traits<detail::matrix_int_2x8_column4> { typedef detail::matrix_int_2x8_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,5> matrix_int_2x8_column5; }template <> struct geometric_traits<detail::matrix_int_2x8_column5> { typedef detail::matrix_int_2x8_column5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,6> matrix_int_2x8_column6; }template <> struct geometric_traits<detail::matrix_int_2x8_column6> { typedef detail::matrix_int_2x8_column6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x8,7> matrix_int_2x8_column7; }template <> struct geometric_traits<detail::matrix_int_2x8_column7> { typedef detail::matrix_int_2x8_column7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x8>::type > : index_operator_matrix_access_policy < matrix_int_2x8 > { typedef index_operator_matrix_access_policy < matrix_int_2x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x8 > { typedef dimension<2> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 9> matrix_int_2x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x9,0> matrix_int_2x9_row0; } template <> struct geometric_traits<detail::matrix_int_2x9_row0> { typedef detail::matrix_int_2x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x9,1> matrix_int_2x9_row1; } template <> struct geometric_traits<detail::matrix_int_2x9_row1> { typedef detail::matrix_int_2x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,0> matrix_int_2x9_column0; }template <> struct geometric_traits<detail::matrix_int_2x9_column0> { typedef detail::matrix_int_2x9_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,1> matrix_int_2x9_column1; }template <> struct geometric_traits<detail::matrix_int_2x9_column1> { typedef detail::matrix_int_2x9_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,2> matrix_int_2x9_column2; }template <> struct geometric_traits<detail::matrix_int_2x9_column2> { typedef detail::matrix_int_2x9_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,3> matrix_int_2x9_column3; }template <> struct geometric_traits<detail::matrix_int_2x9_column3> { typedef detail::matrix_int_2x9_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,4> matrix_int_2x9_column4; }template <> struct geometric_traits<detail::matrix_int_2x9_column4> { typedef detail::matrix_int_2x9_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,5> matrix_int_2x9_column5; }template <> struct geometric_traits<detail::matrix_int_2x9_column5> { typedef detail::matrix_int_2x9_column5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,6> matrix_int_2x9_column6; }template <> struct geometric_traits<detail::matrix_int_2x9_column6> { typedef detail::matrix_int_2x9_column6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,7> matrix_int_2x9_column7; }template <> struct geometric_traits<detail::matrix_int_2x9_column7> { typedef detail::matrix_int_2x9_column7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x9,8> matrix_int_2x9_column8; }template <> struct geometric_traits<detail::matrix_int_2x9_column8> { typedef detail::matrix_int_2x9_column8 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x9>::type > : index_operator_matrix_access_policy < matrix_int_2x9 > { typedef index_operator_matrix_access_policy < matrix_int_2x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x9 > { typedef dimension<2> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 2, 10> matrix_int_2x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x10,0> matrix_int_2x10_row0; } template <> struct geometric_traits<detail::matrix_int_2x10_row0> { typedef detail::matrix_int_2x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_2x10,1> matrix_int_2x10_row1; } template <> struct geometric_traits<detail::matrix_int_2x10_row1> { typedef detail::matrix_int_2x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,0> matrix_int_2x10_column0; }template <> struct geometric_traits<detail::matrix_int_2x10_column0> { typedef detail::matrix_int_2x10_column0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,1> matrix_int_2x10_column1; }template <> struct geometric_traits<detail::matrix_int_2x10_column1> { typedef detail::matrix_int_2x10_column1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,2> matrix_int_2x10_column2; }template <> struct geometric_traits<detail::matrix_int_2x10_column2> { typedef detail::matrix_int_2x10_column2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,3> matrix_int_2x10_column3; }template <> struct geometric_traits<detail::matrix_int_2x10_column3> { typedef detail::matrix_int_2x10_column3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,4> matrix_int_2x10_column4; }template <> struct geometric_traits<detail::matrix_int_2x10_column4> { typedef detail::matrix_int_2x10_column4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,5> matrix_int_2x10_column5; }template <> struct geometric_traits<detail::matrix_int_2x10_column5> { typedef detail::matrix_int_2x10_column5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,6> matrix_int_2x10_column6; }template <> struct geometric_traits<detail::matrix_int_2x10_column6> { typedef detail::matrix_int_2x10_column6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,7> matrix_int_2x10_column7; }template <> struct geometric_traits<detail::matrix_int_2x10_column7> { typedef detail::matrix_int_2x10_column7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,8> matrix_int_2x10_column8; }template <> struct geometric_traits<detail::matrix_int_2x10_column8> { typedef detail::matrix_int_2x10_column8 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_2x10,9> matrix_int_2x10_column9; }template <> struct geometric_traits<detail::matrix_int_2x10_column9> { typedef detail::matrix_int_2x10_column9 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_2x10>::type > : index_operator_matrix_access_policy < matrix_int_2x10 > { typedef index_operator_matrix_access_policy < matrix_int_2x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_2x10 > { typedef dimension<2> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 1> matrix_int_3x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x1,0> matrix_int_3x1_row0; } template <> struct geometric_traits<detail::matrix_int_3x1_row0> { typedef detail::matrix_int_3x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x1,1> matrix_int_3x1_row1; } template <> struct geometric_traits<detail::matrix_int_3x1_row1> { typedef detail::matrix_int_3x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x1,2> matrix_int_3x1_row2; } template <> struct geometric_traits<detail::matrix_int_3x1_row2> { typedef detail::matrix_int_3x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x1,0> matrix_int_3x1_column0; }template <> struct geometric_traits<detail::matrix_int_3x1_column0> { typedef detail::matrix_int_3x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x1>::type > : index_operator_matrix_access_policy < matrix_int_3x1 > { typedef index_operator_matrix_access_policy < matrix_int_3x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x1 > { typedef dimension<3> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 2> matrix_int_3x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x2,0> matrix_int_3x2_row0; } template <> struct geometric_traits<detail::matrix_int_3x2_row0> { typedef detail::matrix_int_3x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x2,1> matrix_int_3x2_row1; } template <> struct geometric_traits<detail::matrix_int_3x2_row1> { typedef detail::matrix_int_3x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x2,2> matrix_int_3x2_row2; } template <> struct geometric_traits<detail::matrix_int_3x2_row2> { typedef detail::matrix_int_3x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x2,0> matrix_int_3x2_column0; }template <> struct geometric_traits<detail::matrix_int_3x2_column0> { typedef detail::matrix_int_3x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x2,1> matrix_int_3x2_column1; }template <> struct geometric_traits<detail::matrix_int_3x2_column1> { typedef detail::matrix_int_3x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x2>::type > : index_operator_matrix_access_policy < matrix_int_3x2 > { typedef index_operator_matrix_access_policy < matrix_int_3x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x2 > { typedef dimension<3> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 3> matrix_int_3x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x3,0> matrix_int_3x3_row0; } template <> struct geometric_traits<detail::matrix_int_3x3_row0> { typedef detail::matrix_int_3x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x3,1> matrix_int_3x3_row1; } template <> struct geometric_traits<detail::matrix_int_3x3_row1> { typedef detail::matrix_int_3x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x3,2> matrix_int_3x3_row2; } template <> struct geometric_traits<detail::matrix_int_3x3_row2> { typedef detail::matrix_int_3x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x3,0> matrix_int_3x3_column0; }template <> struct geometric_traits<detail::matrix_int_3x3_column0> { typedef detail::matrix_int_3x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x3,1> matrix_int_3x3_column1; }template <> struct geometric_traits<detail::matrix_int_3x3_column1> { typedef detail::matrix_int_3x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x3,2> matrix_int_3x3_column2; }template <> struct geometric_traits<detail::matrix_int_3x3_column2> { typedef detail::matrix_int_3x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x3>::type > : index_operator_matrix_access_policy < matrix_int_3x3 > { typedef index_operator_matrix_access_policy < matrix_int_3x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x3 > { typedef dimension<3> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 4> matrix_int_3x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x4,0> matrix_int_3x4_row0; } template <> struct geometric_traits<detail::matrix_int_3x4_row0> { typedef detail::matrix_int_3x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x4,1> matrix_int_3x4_row1; } template <> struct geometric_traits<detail::matrix_int_3x4_row1> { typedef detail::matrix_int_3x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x4,2> matrix_int_3x4_row2; } template <> struct geometric_traits<detail::matrix_int_3x4_row2> { typedef detail::matrix_int_3x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x4,0> matrix_int_3x4_column0; }template <> struct geometric_traits<detail::matrix_int_3x4_column0> { typedef detail::matrix_int_3x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x4,1> matrix_int_3x4_column1; }template <> struct geometric_traits<detail::matrix_int_3x4_column1> { typedef detail::matrix_int_3x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x4,2> matrix_int_3x4_column2; }template <> struct geometric_traits<detail::matrix_int_3x4_column2> { typedef detail::matrix_int_3x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x4,3> matrix_int_3x4_column3; }template <> struct geometric_traits<detail::matrix_int_3x4_column3> { typedef detail::matrix_int_3x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x4>::type > : index_operator_matrix_access_policy < matrix_int_3x4 > { typedef index_operator_matrix_access_policy < matrix_int_3x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x4 > { typedef dimension<3> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 5> matrix_int_3x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x5,0> matrix_int_3x5_row0; } template <> struct geometric_traits<detail::matrix_int_3x5_row0> { typedef detail::matrix_int_3x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x5,1> matrix_int_3x5_row1; } template <> struct geometric_traits<detail::matrix_int_3x5_row1> { typedef detail::matrix_int_3x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x5,2> matrix_int_3x5_row2; } template <> struct geometric_traits<detail::matrix_int_3x5_row2> { typedef detail::matrix_int_3x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x5,0> matrix_int_3x5_column0; }template <> struct geometric_traits<detail::matrix_int_3x5_column0> { typedef detail::matrix_int_3x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x5,1> matrix_int_3x5_column1; }template <> struct geometric_traits<detail::matrix_int_3x5_column1> { typedef detail::matrix_int_3x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x5,2> matrix_int_3x5_column2; }template <> struct geometric_traits<detail::matrix_int_3x5_column2> { typedef detail::matrix_int_3x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x5,3> matrix_int_3x5_column3; }template <> struct geometric_traits<detail::matrix_int_3x5_column3> { typedef detail::matrix_int_3x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x5,4> matrix_int_3x5_column4; }template <> struct geometric_traits<detail::matrix_int_3x5_column4> { typedef detail::matrix_int_3x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x5>::type > : index_operator_matrix_access_policy < matrix_int_3x5 > { typedef index_operator_matrix_access_policy < matrix_int_3x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x5 > { typedef dimension<3> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 6> matrix_int_3x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x6,0> matrix_int_3x6_row0; } template <> struct geometric_traits<detail::matrix_int_3x6_row0> { typedef detail::matrix_int_3x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x6,1> matrix_int_3x6_row1; } template <> struct geometric_traits<detail::matrix_int_3x6_row1> { typedef detail::matrix_int_3x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x6,2> matrix_int_3x6_row2; } template <> struct geometric_traits<detail::matrix_int_3x6_row2> { typedef detail::matrix_int_3x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,0> matrix_int_3x6_column0; }template <> struct geometric_traits<detail::matrix_int_3x6_column0> { typedef detail::matrix_int_3x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,1> matrix_int_3x6_column1; }template <> struct geometric_traits<detail::matrix_int_3x6_column1> { typedef detail::matrix_int_3x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,2> matrix_int_3x6_column2; }template <> struct geometric_traits<detail::matrix_int_3x6_column2> { typedef detail::matrix_int_3x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,3> matrix_int_3x6_column3; }template <> struct geometric_traits<detail::matrix_int_3x6_column3> { typedef detail::matrix_int_3x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,4> matrix_int_3x6_column4; }template <> struct geometric_traits<detail::matrix_int_3x6_column4> { typedef detail::matrix_int_3x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x6,5> matrix_int_3x6_column5; }template <> struct geometric_traits<detail::matrix_int_3x6_column5> { typedef detail::matrix_int_3x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x6>::type > : index_operator_matrix_access_policy < matrix_int_3x6 > { typedef index_operator_matrix_access_policy < matrix_int_3x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x6 > { typedef dimension<3> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 7> matrix_int_3x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x7,0> matrix_int_3x7_row0; } template <> struct geometric_traits<detail::matrix_int_3x7_row0> { typedef detail::matrix_int_3x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x7,1> matrix_int_3x7_row1; } template <> struct geometric_traits<detail::matrix_int_3x7_row1> { typedef detail::matrix_int_3x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x7,2> matrix_int_3x7_row2; } template <> struct geometric_traits<detail::matrix_int_3x7_row2> { typedef detail::matrix_int_3x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,0> matrix_int_3x7_column0; }template <> struct geometric_traits<detail::matrix_int_3x7_column0> { typedef detail::matrix_int_3x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,1> matrix_int_3x7_column1; }template <> struct geometric_traits<detail::matrix_int_3x7_column1> { typedef detail::matrix_int_3x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,2> matrix_int_3x7_column2; }template <> struct geometric_traits<detail::matrix_int_3x7_column2> { typedef detail::matrix_int_3x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,3> matrix_int_3x7_column3; }template <> struct geometric_traits<detail::matrix_int_3x7_column3> { typedef detail::matrix_int_3x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,4> matrix_int_3x7_column4; }template <> struct geometric_traits<detail::matrix_int_3x7_column4> { typedef detail::matrix_int_3x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,5> matrix_int_3x7_column5; }template <> struct geometric_traits<detail::matrix_int_3x7_column5> { typedef detail::matrix_int_3x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x7,6> matrix_int_3x7_column6; }template <> struct geometric_traits<detail::matrix_int_3x7_column6> { typedef detail::matrix_int_3x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x7>::type > : index_operator_matrix_access_policy < matrix_int_3x7 > { typedef index_operator_matrix_access_policy < matrix_int_3x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x7 > { typedef dimension<3> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 8> matrix_int_3x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x8,0> matrix_int_3x8_row0; } template <> struct geometric_traits<detail::matrix_int_3x8_row0> { typedef detail::matrix_int_3x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x8,1> matrix_int_3x8_row1; } template <> struct geometric_traits<detail::matrix_int_3x8_row1> { typedef detail::matrix_int_3x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x8,2> matrix_int_3x8_row2; } template <> struct geometric_traits<detail::matrix_int_3x8_row2> { typedef detail::matrix_int_3x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,0> matrix_int_3x8_column0; }template <> struct geometric_traits<detail::matrix_int_3x8_column0> { typedef detail::matrix_int_3x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,1> matrix_int_3x8_column1; }template <> struct geometric_traits<detail::matrix_int_3x8_column1> { typedef detail::matrix_int_3x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,2> matrix_int_3x8_column2; }template <> struct geometric_traits<detail::matrix_int_3x8_column2> { typedef detail::matrix_int_3x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,3> matrix_int_3x8_column3; }template <> struct geometric_traits<detail::matrix_int_3x8_column3> { typedef detail::matrix_int_3x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,4> matrix_int_3x8_column4; }template <> struct geometric_traits<detail::matrix_int_3x8_column4> { typedef detail::matrix_int_3x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,5> matrix_int_3x8_column5; }template <> struct geometric_traits<detail::matrix_int_3x8_column5> { typedef detail::matrix_int_3x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,6> matrix_int_3x8_column6; }template <> struct geometric_traits<detail::matrix_int_3x8_column6> { typedef detail::matrix_int_3x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x8,7> matrix_int_3x8_column7; }template <> struct geometric_traits<detail::matrix_int_3x8_column7> { typedef detail::matrix_int_3x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x8>::type > : index_operator_matrix_access_policy < matrix_int_3x8 > { typedef index_operator_matrix_access_policy < matrix_int_3x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x8 > { typedef dimension<3> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 9> matrix_int_3x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x9,0> matrix_int_3x9_row0; } template <> struct geometric_traits<detail::matrix_int_3x9_row0> { typedef detail::matrix_int_3x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x9,1> matrix_int_3x9_row1; } template <> struct geometric_traits<detail::matrix_int_3x9_row1> { typedef detail::matrix_int_3x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x9,2> matrix_int_3x9_row2; } template <> struct geometric_traits<detail::matrix_int_3x9_row2> { typedef detail::matrix_int_3x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,0> matrix_int_3x9_column0; }template <> struct geometric_traits<detail::matrix_int_3x9_column0> { typedef detail::matrix_int_3x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,1> matrix_int_3x9_column1; }template <> struct geometric_traits<detail::matrix_int_3x9_column1> { typedef detail::matrix_int_3x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,2> matrix_int_3x9_column2; }template <> struct geometric_traits<detail::matrix_int_3x9_column2> { typedef detail::matrix_int_3x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,3> matrix_int_3x9_column3; }template <> struct geometric_traits<detail::matrix_int_3x9_column3> { typedef detail::matrix_int_3x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,4> matrix_int_3x9_column4; }template <> struct geometric_traits<detail::matrix_int_3x9_column4> { typedef detail::matrix_int_3x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,5> matrix_int_3x9_column5; }template <> struct geometric_traits<detail::matrix_int_3x9_column5> { typedef detail::matrix_int_3x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,6> matrix_int_3x9_column6; }template <> struct geometric_traits<detail::matrix_int_3x9_column6> { typedef detail::matrix_int_3x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,7> matrix_int_3x9_column7; }template <> struct geometric_traits<detail::matrix_int_3x9_column7> { typedef detail::matrix_int_3x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x9,8> matrix_int_3x9_column8; }template <> struct geometric_traits<detail::matrix_int_3x9_column8> { typedef detail::matrix_int_3x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x9>::type > : index_operator_matrix_access_policy < matrix_int_3x9 > { typedef index_operator_matrix_access_policy < matrix_int_3x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x9 > { typedef dimension<3> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 3, 10> matrix_int_3x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x10,0> matrix_int_3x10_row0; } template <> struct geometric_traits<detail::matrix_int_3x10_row0> { typedef detail::matrix_int_3x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x10,1> matrix_int_3x10_row1; } template <> struct geometric_traits<detail::matrix_int_3x10_row1> { typedef detail::matrix_int_3x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_3x10,2> matrix_int_3x10_row2; } template <> struct geometric_traits<detail::matrix_int_3x10_row2> { typedef detail::matrix_int_3x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,0> matrix_int_3x10_column0; }template <> struct geometric_traits<detail::matrix_int_3x10_column0> { typedef detail::matrix_int_3x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,1> matrix_int_3x10_column1; }template <> struct geometric_traits<detail::matrix_int_3x10_column1> { typedef detail::matrix_int_3x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,2> matrix_int_3x10_column2; }template <> struct geometric_traits<detail::matrix_int_3x10_column2> { typedef detail::matrix_int_3x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,3> matrix_int_3x10_column3; }template <> struct geometric_traits<detail::matrix_int_3x10_column3> { typedef detail::matrix_int_3x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,4> matrix_int_3x10_column4; }template <> struct geometric_traits<detail::matrix_int_3x10_column4> { typedef detail::matrix_int_3x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,5> matrix_int_3x10_column5; }template <> struct geometric_traits<detail::matrix_int_3x10_column5> { typedef detail::matrix_int_3x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,6> matrix_int_3x10_column6; }template <> struct geometric_traits<detail::matrix_int_3x10_column6> { typedef detail::matrix_int_3x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,7> matrix_int_3x10_column7; }template <> struct geometric_traits<detail::matrix_int_3x10_column7> { typedef detail::matrix_int_3x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,8> matrix_int_3x10_column8; }template <> struct geometric_traits<detail::matrix_int_3x10_column8> { typedef detail::matrix_int_3x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_3x10,9> matrix_int_3x10_column9; }template <> struct geometric_traits<detail::matrix_int_3x10_column9> { typedef detail::matrix_int_3x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_3x10>::type > : index_operator_matrix_access_policy < matrix_int_3x10 > { typedef index_operator_matrix_access_policy < matrix_int_3x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_3x10 > { typedef dimension<3> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 1> matrix_int_4x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x1,0> matrix_int_4x1_row0; } template <> struct geometric_traits<detail::matrix_int_4x1_row0> { typedef detail::matrix_int_4x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x1,1> matrix_int_4x1_row1; } template <> struct geometric_traits<detail::matrix_int_4x1_row1> { typedef detail::matrix_int_4x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x1,2> matrix_int_4x1_row2; } template <> struct geometric_traits<detail::matrix_int_4x1_row2> { typedef detail::matrix_int_4x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x1,3> matrix_int_4x1_row3; } template <> struct geometric_traits<detail::matrix_int_4x1_row3> { typedef detail::matrix_int_4x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x1,0> matrix_int_4x1_column0; }template <> struct geometric_traits<detail::matrix_int_4x1_column0> { typedef detail::matrix_int_4x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x1>::type > : index_operator_matrix_access_policy < matrix_int_4x1 > { typedef index_operator_matrix_access_policy < matrix_int_4x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x1 > { typedef dimension<4> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 2> matrix_int_4x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x2,0> matrix_int_4x2_row0; } template <> struct geometric_traits<detail::matrix_int_4x2_row0> { typedef detail::matrix_int_4x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x2,1> matrix_int_4x2_row1; } template <> struct geometric_traits<detail::matrix_int_4x2_row1> { typedef detail::matrix_int_4x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x2,2> matrix_int_4x2_row2; } template <> struct geometric_traits<detail::matrix_int_4x2_row2> { typedef detail::matrix_int_4x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x2,3> matrix_int_4x2_row3; } template <> struct geometric_traits<detail::matrix_int_4x2_row3> { typedef detail::matrix_int_4x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x2,0> matrix_int_4x2_column0; }template <> struct geometric_traits<detail::matrix_int_4x2_column0> { typedef detail::matrix_int_4x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x2,1> matrix_int_4x2_column1; }template <> struct geometric_traits<detail::matrix_int_4x2_column1> { typedef detail::matrix_int_4x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x2>::type > : index_operator_matrix_access_policy < matrix_int_4x2 > { typedef index_operator_matrix_access_policy < matrix_int_4x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x2 > { typedef dimension<4> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 3> matrix_int_4x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x3,0> matrix_int_4x3_row0; } template <> struct geometric_traits<detail::matrix_int_4x3_row0> { typedef detail::matrix_int_4x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x3,1> matrix_int_4x3_row1; } template <> struct geometric_traits<detail::matrix_int_4x3_row1> { typedef detail::matrix_int_4x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x3,2> matrix_int_4x3_row2; } template <> struct geometric_traits<detail::matrix_int_4x3_row2> { typedef detail::matrix_int_4x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x3,3> matrix_int_4x3_row3; } template <> struct geometric_traits<detail::matrix_int_4x3_row3> { typedef detail::matrix_int_4x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x3,0> matrix_int_4x3_column0; }template <> struct geometric_traits<detail::matrix_int_4x3_column0> { typedef detail::matrix_int_4x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x3,1> matrix_int_4x3_column1; }template <> struct geometric_traits<detail::matrix_int_4x3_column1> { typedef detail::matrix_int_4x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x3,2> matrix_int_4x3_column2; }template <> struct geometric_traits<detail::matrix_int_4x3_column2> { typedef detail::matrix_int_4x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x3>::type > : index_operator_matrix_access_policy < matrix_int_4x3 > { typedef index_operator_matrix_access_policy < matrix_int_4x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x3 > { typedef dimension<4> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 4> matrix_int_4x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x4,0> matrix_int_4x4_row0; } template <> struct geometric_traits<detail::matrix_int_4x4_row0> { typedef detail::matrix_int_4x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x4,1> matrix_int_4x4_row1; } template <> struct geometric_traits<detail::matrix_int_4x4_row1> { typedef detail::matrix_int_4x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x4,2> matrix_int_4x4_row2; } template <> struct geometric_traits<detail::matrix_int_4x4_row2> { typedef detail::matrix_int_4x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x4,3> matrix_int_4x4_row3; } template <> struct geometric_traits<detail::matrix_int_4x4_row3> { typedef detail::matrix_int_4x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x4,0> matrix_int_4x4_column0; }template <> struct geometric_traits<detail::matrix_int_4x4_column0> { typedef detail::matrix_int_4x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x4,1> matrix_int_4x4_column1; }template <> struct geometric_traits<detail::matrix_int_4x4_column1> { typedef detail::matrix_int_4x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x4,2> matrix_int_4x4_column2; }template <> struct geometric_traits<detail::matrix_int_4x4_column2> { typedef detail::matrix_int_4x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x4,3> matrix_int_4x4_column3; }template <> struct geometric_traits<detail::matrix_int_4x4_column3> { typedef detail::matrix_int_4x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x4>::type > : index_operator_matrix_access_policy < matrix_int_4x4 > { typedef index_operator_matrix_access_policy < matrix_int_4x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x4 > { typedef dimension<4> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 5> matrix_int_4x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x5,0> matrix_int_4x5_row0; } template <> struct geometric_traits<detail::matrix_int_4x5_row0> { typedef detail::matrix_int_4x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x5,1> matrix_int_4x5_row1; } template <> struct geometric_traits<detail::matrix_int_4x5_row1> { typedef detail::matrix_int_4x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x5,2> matrix_int_4x5_row2; } template <> struct geometric_traits<detail::matrix_int_4x5_row2> { typedef detail::matrix_int_4x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x5,3> matrix_int_4x5_row3; } template <> struct geometric_traits<detail::matrix_int_4x5_row3> { typedef detail::matrix_int_4x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x5,0> matrix_int_4x5_column0; }template <> struct geometric_traits<detail::matrix_int_4x5_column0> { typedef detail::matrix_int_4x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x5,1> matrix_int_4x5_column1; }template <> struct geometric_traits<detail::matrix_int_4x5_column1> { typedef detail::matrix_int_4x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x5,2> matrix_int_4x5_column2; }template <> struct geometric_traits<detail::matrix_int_4x5_column2> { typedef detail::matrix_int_4x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x5,3> matrix_int_4x5_column3; }template <> struct geometric_traits<detail::matrix_int_4x5_column3> { typedef detail::matrix_int_4x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x5,4> matrix_int_4x5_column4; }template <> struct geometric_traits<detail::matrix_int_4x5_column4> { typedef detail::matrix_int_4x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x5>::type > : index_operator_matrix_access_policy < matrix_int_4x5 > { typedef index_operator_matrix_access_policy < matrix_int_4x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x5 > { typedef dimension<4> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 6> matrix_int_4x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x6,0> matrix_int_4x6_row0; } template <> struct geometric_traits<detail::matrix_int_4x6_row0> { typedef detail::matrix_int_4x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x6,1> matrix_int_4x6_row1; } template <> struct geometric_traits<detail::matrix_int_4x6_row1> { typedef detail::matrix_int_4x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x6,2> matrix_int_4x6_row2; } template <> struct geometric_traits<detail::matrix_int_4x6_row2> { typedef detail::matrix_int_4x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x6,3> matrix_int_4x6_row3; } template <> struct geometric_traits<detail::matrix_int_4x6_row3> { typedef detail::matrix_int_4x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,0> matrix_int_4x6_column0; }template <> struct geometric_traits<detail::matrix_int_4x6_column0> { typedef detail::matrix_int_4x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,1> matrix_int_4x6_column1; }template <> struct geometric_traits<detail::matrix_int_4x6_column1> { typedef detail::matrix_int_4x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,2> matrix_int_4x6_column2; }template <> struct geometric_traits<detail::matrix_int_4x6_column2> { typedef detail::matrix_int_4x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,3> matrix_int_4x6_column3; }template <> struct geometric_traits<detail::matrix_int_4x6_column3> { typedef detail::matrix_int_4x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,4> matrix_int_4x6_column4; }template <> struct geometric_traits<detail::matrix_int_4x6_column4> { typedef detail::matrix_int_4x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x6,5> matrix_int_4x6_column5; }template <> struct geometric_traits<detail::matrix_int_4x6_column5> { typedef detail::matrix_int_4x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x6>::type > : index_operator_matrix_access_policy < matrix_int_4x6 > { typedef index_operator_matrix_access_policy < matrix_int_4x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x6 > { typedef dimension<4> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 7> matrix_int_4x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x7,0> matrix_int_4x7_row0; } template <> struct geometric_traits<detail::matrix_int_4x7_row0> { typedef detail::matrix_int_4x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x7,1> matrix_int_4x7_row1; } template <> struct geometric_traits<detail::matrix_int_4x7_row1> { typedef detail::matrix_int_4x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x7,2> matrix_int_4x7_row2; } template <> struct geometric_traits<detail::matrix_int_4x7_row2> { typedef detail::matrix_int_4x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x7,3> matrix_int_4x7_row3; } template <> struct geometric_traits<detail::matrix_int_4x7_row3> { typedef detail::matrix_int_4x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,0> matrix_int_4x7_column0; }template <> struct geometric_traits<detail::matrix_int_4x7_column0> { typedef detail::matrix_int_4x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,1> matrix_int_4x7_column1; }template <> struct geometric_traits<detail::matrix_int_4x7_column1> { typedef detail::matrix_int_4x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,2> matrix_int_4x7_column2; }template <> struct geometric_traits<detail::matrix_int_4x7_column2> { typedef detail::matrix_int_4x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,3> matrix_int_4x7_column3; }template <> struct geometric_traits<detail::matrix_int_4x7_column3> { typedef detail::matrix_int_4x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,4> matrix_int_4x7_column4; }template <> struct geometric_traits<detail::matrix_int_4x7_column4> { typedef detail::matrix_int_4x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,5> matrix_int_4x7_column5; }template <> struct geometric_traits<detail::matrix_int_4x7_column5> { typedef detail::matrix_int_4x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x7,6> matrix_int_4x7_column6; }template <> struct geometric_traits<detail::matrix_int_4x7_column6> { typedef detail::matrix_int_4x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x7>::type > : index_operator_matrix_access_policy < matrix_int_4x7 > { typedef index_operator_matrix_access_policy < matrix_int_4x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x7 > { typedef dimension<4> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 8> matrix_int_4x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x8,0> matrix_int_4x8_row0; } template <> struct geometric_traits<detail::matrix_int_4x8_row0> { typedef detail::matrix_int_4x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x8,1> matrix_int_4x8_row1; } template <> struct geometric_traits<detail::matrix_int_4x8_row1> { typedef detail::matrix_int_4x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x8,2> matrix_int_4x8_row2; } template <> struct geometric_traits<detail::matrix_int_4x8_row2> { typedef detail::matrix_int_4x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x8,3> matrix_int_4x8_row3; } template <> struct geometric_traits<detail::matrix_int_4x8_row3> { typedef detail::matrix_int_4x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,0> matrix_int_4x8_column0; }template <> struct geometric_traits<detail::matrix_int_4x8_column0> { typedef detail::matrix_int_4x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,1> matrix_int_4x8_column1; }template <> struct geometric_traits<detail::matrix_int_4x8_column1> { typedef detail::matrix_int_4x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,2> matrix_int_4x8_column2; }template <> struct geometric_traits<detail::matrix_int_4x8_column2> { typedef detail::matrix_int_4x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,3> matrix_int_4x8_column3; }template <> struct geometric_traits<detail::matrix_int_4x8_column3> { typedef detail::matrix_int_4x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,4> matrix_int_4x8_column4; }template <> struct geometric_traits<detail::matrix_int_4x8_column4> { typedef detail::matrix_int_4x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,5> matrix_int_4x8_column5; }template <> struct geometric_traits<detail::matrix_int_4x8_column5> { typedef detail::matrix_int_4x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,6> matrix_int_4x8_column6; }template <> struct geometric_traits<detail::matrix_int_4x8_column6> { typedef detail::matrix_int_4x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x8,7> matrix_int_4x8_column7; }template <> struct geometric_traits<detail::matrix_int_4x8_column7> { typedef detail::matrix_int_4x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x8>::type > : index_operator_matrix_access_policy < matrix_int_4x8 > { typedef index_operator_matrix_access_policy < matrix_int_4x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x8 > { typedef dimension<4> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 9> matrix_int_4x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x9,0> matrix_int_4x9_row0; } template <> struct geometric_traits<detail::matrix_int_4x9_row0> { typedef detail::matrix_int_4x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x9,1> matrix_int_4x9_row1; } template <> struct geometric_traits<detail::matrix_int_4x9_row1> { typedef detail::matrix_int_4x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x9,2> matrix_int_4x9_row2; } template <> struct geometric_traits<detail::matrix_int_4x9_row2> { typedef detail::matrix_int_4x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x9,3> matrix_int_4x9_row3; } template <> struct geometric_traits<detail::matrix_int_4x9_row3> { typedef detail::matrix_int_4x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,0> matrix_int_4x9_column0; }template <> struct geometric_traits<detail::matrix_int_4x9_column0> { typedef detail::matrix_int_4x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,1> matrix_int_4x9_column1; }template <> struct geometric_traits<detail::matrix_int_4x9_column1> { typedef detail::matrix_int_4x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,2> matrix_int_4x9_column2; }template <> struct geometric_traits<detail::matrix_int_4x9_column2> { typedef detail::matrix_int_4x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,3> matrix_int_4x9_column3; }template <> struct geometric_traits<detail::matrix_int_4x9_column3> { typedef detail::matrix_int_4x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,4> matrix_int_4x9_column4; }template <> struct geometric_traits<detail::matrix_int_4x9_column4> { typedef detail::matrix_int_4x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,5> matrix_int_4x9_column5; }template <> struct geometric_traits<detail::matrix_int_4x9_column5> { typedef detail::matrix_int_4x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,6> matrix_int_4x9_column6; }template <> struct geometric_traits<detail::matrix_int_4x9_column6> { typedef detail::matrix_int_4x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,7> matrix_int_4x9_column7; }template <> struct geometric_traits<detail::matrix_int_4x9_column7> { typedef detail::matrix_int_4x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x9,8> matrix_int_4x9_column8; }template <> struct geometric_traits<detail::matrix_int_4x9_column8> { typedef detail::matrix_int_4x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x9>::type > : index_operator_matrix_access_policy < matrix_int_4x9 > { typedef index_operator_matrix_access_policy < matrix_int_4x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x9 > { typedef dimension<4> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 4, 10> matrix_int_4x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x10,0> matrix_int_4x10_row0; } template <> struct geometric_traits<detail::matrix_int_4x10_row0> { typedef detail::matrix_int_4x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x10,1> matrix_int_4x10_row1; } template <> struct geometric_traits<detail::matrix_int_4x10_row1> { typedef detail::matrix_int_4x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x10,2> matrix_int_4x10_row2; } template <> struct geometric_traits<detail::matrix_int_4x10_row2> { typedef detail::matrix_int_4x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_4x10,3> matrix_int_4x10_row3; } template <> struct geometric_traits<detail::matrix_int_4x10_row3> { typedef detail::matrix_int_4x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,0> matrix_int_4x10_column0; }template <> struct geometric_traits<detail::matrix_int_4x10_column0> { typedef detail::matrix_int_4x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,1> matrix_int_4x10_column1; }template <> struct geometric_traits<detail::matrix_int_4x10_column1> { typedef detail::matrix_int_4x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,2> matrix_int_4x10_column2; }template <> struct geometric_traits<detail::matrix_int_4x10_column2> { typedef detail::matrix_int_4x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,3> matrix_int_4x10_column3; }template <> struct geometric_traits<detail::matrix_int_4x10_column3> { typedef detail::matrix_int_4x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,4> matrix_int_4x10_column4; }template <> struct geometric_traits<detail::matrix_int_4x10_column4> { typedef detail::matrix_int_4x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,5> matrix_int_4x10_column5; }template <> struct geometric_traits<detail::matrix_int_4x10_column5> { typedef detail::matrix_int_4x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,6> matrix_int_4x10_column6; }template <> struct geometric_traits<detail::matrix_int_4x10_column6> { typedef detail::matrix_int_4x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,7> matrix_int_4x10_column7; }template <> struct geometric_traits<detail::matrix_int_4x10_column7> { typedef detail::matrix_int_4x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,8> matrix_int_4x10_column8; }template <> struct geometric_traits<detail::matrix_int_4x10_column8> { typedef detail::matrix_int_4x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_4x10,9> matrix_int_4x10_column9; }template <> struct geometric_traits<detail::matrix_int_4x10_column9> { typedef detail::matrix_int_4x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_4x10>::type > : index_operator_matrix_access_policy < matrix_int_4x10 > { typedef index_operator_matrix_access_policy < matrix_int_4x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_4x10 > { typedef dimension<4> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 1> matrix_int_5x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x1,0> matrix_int_5x1_row0; } template <> struct geometric_traits<detail::matrix_int_5x1_row0> { typedef detail::matrix_int_5x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x1,1> matrix_int_5x1_row1; } template <> struct geometric_traits<detail::matrix_int_5x1_row1> { typedef detail::matrix_int_5x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x1,2> matrix_int_5x1_row2; } template <> struct geometric_traits<detail::matrix_int_5x1_row2> { typedef detail::matrix_int_5x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x1,3> matrix_int_5x1_row3; } template <> struct geometric_traits<detail::matrix_int_5x1_row3> { typedef detail::matrix_int_5x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x1,4> matrix_int_5x1_row4; } template <> struct geometric_traits<detail::matrix_int_5x1_row4> { typedef detail::matrix_int_5x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x1,0> matrix_int_5x1_column0; }template <> struct geometric_traits<detail::matrix_int_5x1_column0> { typedef detail::matrix_int_5x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x1>::type > : index_operator_matrix_access_policy < matrix_int_5x1 > { typedef index_operator_matrix_access_policy < matrix_int_5x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x1 > { typedef dimension<5> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 2> matrix_int_5x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x2,0> matrix_int_5x2_row0; } template <> struct geometric_traits<detail::matrix_int_5x2_row0> { typedef detail::matrix_int_5x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x2,1> matrix_int_5x2_row1; } template <> struct geometric_traits<detail::matrix_int_5x2_row1> { typedef detail::matrix_int_5x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x2,2> matrix_int_5x2_row2; } template <> struct geometric_traits<detail::matrix_int_5x2_row2> { typedef detail::matrix_int_5x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x2,3> matrix_int_5x2_row3; } template <> struct geometric_traits<detail::matrix_int_5x2_row3> { typedef detail::matrix_int_5x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x2,4> matrix_int_5x2_row4; } template <> struct geometric_traits<detail::matrix_int_5x2_row4> { typedef detail::matrix_int_5x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x2,0> matrix_int_5x2_column0; }template <> struct geometric_traits<detail::matrix_int_5x2_column0> { typedef detail::matrix_int_5x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x2,1> matrix_int_5x2_column1; }template <> struct geometric_traits<detail::matrix_int_5x2_column1> { typedef detail::matrix_int_5x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x2>::type > : index_operator_matrix_access_policy < matrix_int_5x2 > { typedef index_operator_matrix_access_policy < matrix_int_5x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x2 > { typedef dimension<5> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 3> matrix_int_5x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x3,0> matrix_int_5x3_row0; } template <> struct geometric_traits<detail::matrix_int_5x3_row0> { typedef detail::matrix_int_5x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x3,1> matrix_int_5x3_row1; } template <> struct geometric_traits<detail::matrix_int_5x3_row1> { typedef detail::matrix_int_5x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x3,2> matrix_int_5x3_row2; } template <> struct geometric_traits<detail::matrix_int_5x3_row2> { typedef detail::matrix_int_5x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x3,3> matrix_int_5x3_row3; } template <> struct geometric_traits<detail::matrix_int_5x3_row3> { typedef detail::matrix_int_5x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x3,4> matrix_int_5x3_row4; } template <> struct geometric_traits<detail::matrix_int_5x3_row4> { typedef detail::matrix_int_5x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x3,0> matrix_int_5x3_column0; }template <> struct geometric_traits<detail::matrix_int_5x3_column0> { typedef detail::matrix_int_5x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x3,1> matrix_int_5x3_column1; }template <> struct geometric_traits<detail::matrix_int_5x3_column1> { typedef detail::matrix_int_5x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x3,2> matrix_int_5x3_column2; }template <> struct geometric_traits<detail::matrix_int_5x3_column2> { typedef detail::matrix_int_5x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x3>::type > : index_operator_matrix_access_policy < matrix_int_5x3 > { typedef index_operator_matrix_access_policy < matrix_int_5x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x3 > { typedef dimension<5> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 4> matrix_int_5x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x4,0> matrix_int_5x4_row0; } template <> struct geometric_traits<detail::matrix_int_5x4_row0> { typedef detail::matrix_int_5x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x4,1> matrix_int_5x4_row1; } template <> struct geometric_traits<detail::matrix_int_5x4_row1> { typedef detail::matrix_int_5x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x4,2> matrix_int_5x4_row2; } template <> struct geometric_traits<detail::matrix_int_5x4_row2> { typedef detail::matrix_int_5x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x4,3> matrix_int_5x4_row3; } template <> struct geometric_traits<detail::matrix_int_5x4_row3> { typedef detail::matrix_int_5x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x4,4> matrix_int_5x4_row4; } template <> struct geometric_traits<detail::matrix_int_5x4_row4> { typedef detail::matrix_int_5x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x4,0> matrix_int_5x4_column0; }template <> struct geometric_traits<detail::matrix_int_5x4_column0> { typedef detail::matrix_int_5x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x4,1> matrix_int_5x4_column1; }template <> struct geometric_traits<detail::matrix_int_5x4_column1> { typedef detail::matrix_int_5x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x4,2> matrix_int_5x4_column2; }template <> struct geometric_traits<detail::matrix_int_5x4_column2> { typedef detail::matrix_int_5x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x4,3> matrix_int_5x4_column3; }template <> struct geometric_traits<detail::matrix_int_5x4_column3> { typedef detail::matrix_int_5x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x4>::type > : index_operator_matrix_access_policy < matrix_int_5x4 > { typedef index_operator_matrix_access_policy < matrix_int_5x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x4 > { typedef dimension<5> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 5> matrix_int_5x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x5,0> matrix_int_5x5_row0; } template <> struct geometric_traits<detail::matrix_int_5x5_row0> { typedef detail::matrix_int_5x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x5,1> matrix_int_5x5_row1; } template <> struct geometric_traits<detail::matrix_int_5x5_row1> { typedef detail::matrix_int_5x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x5,2> matrix_int_5x5_row2; } template <> struct geometric_traits<detail::matrix_int_5x5_row2> { typedef detail::matrix_int_5x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x5,3> matrix_int_5x5_row3; } template <> struct geometric_traits<detail::matrix_int_5x5_row3> { typedef detail::matrix_int_5x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x5,4> matrix_int_5x5_row4; } template <> struct geometric_traits<detail::matrix_int_5x5_row4> { typedef detail::matrix_int_5x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x5,0> matrix_int_5x5_column0; }template <> struct geometric_traits<detail::matrix_int_5x5_column0> { typedef detail::matrix_int_5x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x5,1> matrix_int_5x5_column1; }template <> struct geometric_traits<detail::matrix_int_5x5_column1> { typedef detail::matrix_int_5x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x5,2> matrix_int_5x5_column2; }template <> struct geometric_traits<detail::matrix_int_5x5_column2> { typedef detail::matrix_int_5x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x5,3> matrix_int_5x5_column3; }template <> struct geometric_traits<detail::matrix_int_5x5_column3> { typedef detail::matrix_int_5x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x5,4> matrix_int_5x5_column4; }template <> struct geometric_traits<detail::matrix_int_5x5_column4> { typedef detail::matrix_int_5x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x5>::type > : index_operator_matrix_access_policy < matrix_int_5x5 > { typedef index_operator_matrix_access_policy < matrix_int_5x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x5 > { typedef dimension<5> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 6> matrix_int_5x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x6,0> matrix_int_5x6_row0; } template <> struct geometric_traits<detail::matrix_int_5x6_row0> { typedef detail::matrix_int_5x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x6,1> matrix_int_5x6_row1; } template <> struct geometric_traits<detail::matrix_int_5x6_row1> { typedef detail::matrix_int_5x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x6,2> matrix_int_5x6_row2; } template <> struct geometric_traits<detail::matrix_int_5x6_row2> { typedef detail::matrix_int_5x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x6,3> matrix_int_5x6_row3; } template <> struct geometric_traits<detail::matrix_int_5x6_row3> { typedef detail::matrix_int_5x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x6,4> matrix_int_5x6_row4; } template <> struct geometric_traits<detail::matrix_int_5x6_row4> { typedef detail::matrix_int_5x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,0> matrix_int_5x6_column0; }template <> struct geometric_traits<detail::matrix_int_5x6_column0> { typedef detail::matrix_int_5x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,1> matrix_int_5x6_column1; }template <> struct geometric_traits<detail::matrix_int_5x6_column1> { typedef detail::matrix_int_5x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,2> matrix_int_5x6_column2; }template <> struct geometric_traits<detail::matrix_int_5x6_column2> { typedef detail::matrix_int_5x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,3> matrix_int_5x6_column3; }template <> struct geometric_traits<detail::matrix_int_5x6_column3> { typedef detail::matrix_int_5x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,4> matrix_int_5x6_column4; }template <> struct geometric_traits<detail::matrix_int_5x6_column4> { typedef detail::matrix_int_5x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x6,5> matrix_int_5x6_column5; }template <> struct geometric_traits<detail::matrix_int_5x6_column5> { typedef detail::matrix_int_5x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x6>::type > : index_operator_matrix_access_policy < matrix_int_5x6 > { typedef index_operator_matrix_access_policy < matrix_int_5x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x6 > { typedef dimension<5> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 7> matrix_int_5x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x7,0> matrix_int_5x7_row0; } template <> struct geometric_traits<detail::matrix_int_5x7_row0> { typedef detail::matrix_int_5x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x7,1> matrix_int_5x7_row1; } template <> struct geometric_traits<detail::matrix_int_5x7_row1> { typedef detail::matrix_int_5x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x7,2> matrix_int_5x7_row2; } template <> struct geometric_traits<detail::matrix_int_5x7_row2> { typedef detail::matrix_int_5x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x7,3> matrix_int_5x7_row3; } template <> struct geometric_traits<detail::matrix_int_5x7_row3> { typedef detail::matrix_int_5x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x7,4> matrix_int_5x7_row4; } template <> struct geometric_traits<detail::matrix_int_5x7_row4> { typedef detail::matrix_int_5x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,0> matrix_int_5x7_column0; }template <> struct geometric_traits<detail::matrix_int_5x7_column0> { typedef detail::matrix_int_5x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,1> matrix_int_5x7_column1; }template <> struct geometric_traits<detail::matrix_int_5x7_column1> { typedef detail::matrix_int_5x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,2> matrix_int_5x7_column2; }template <> struct geometric_traits<detail::matrix_int_5x7_column2> { typedef detail::matrix_int_5x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,3> matrix_int_5x7_column3; }template <> struct geometric_traits<detail::matrix_int_5x7_column3> { typedef detail::matrix_int_5x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,4> matrix_int_5x7_column4; }template <> struct geometric_traits<detail::matrix_int_5x7_column4> { typedef detail::matrix_int_5x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,5> matrix_int_5x7_column5; }template <> struct geometric_traits<detail::matrix_int_5x7_column5> { typedef detail::matrix_int_5x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x7,6> matrix_int_5x7_column6; }template <> struct geometric_traits<detail::matrix_int_5x7_column6> { typedef detail::matrix_int_5x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x7>::type > : index_operator_matrix_access_policy < matrix_int_5x7 > { typedef index_operator_matrix_access_policy < matrix_int_5x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x7 > { typedef dimension<5> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 8> matrix_int_5x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x8,0> matrix_int_5x8_row0; } template <> struct geometric_traits<detail::matrix_int_5x8_row0> { typedef detail::matrix_int_5x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x8,1> matrix_int_5x8_row1; } template <> struct geometric_traits<detail::matrix_int_5x8_row1> { typedef detail::matrix_int_5x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x8,2> matrix_int_5x8_row2; } template <> struct geometric_traits<detail::matrix_int_5x8_row2> { typedef detail::matrix_int_5x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x8,3> matrix_int_5x8_row3; } template <> struct geometric_traits<detail::matrix_int_5x8_row3> { typedef detail::matrix_int_5x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x8,4> matrix_int_5x8_row4; } template <> struct geometric_traits<detail::matrix_int_5x8_row4> { typedef detail::matrix_int_5x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,0> matrix_int_5x8_column0; }template <> struct geometric_traits<detail::matrix_int_5x8_column0> { typedef detail::matrix_int_5x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,1> matrix_int_5x8_column1; }template <> struct geometric_traits<detail::matrix_int_5x8_column1> { typedef detail::matrix_int_5x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,2> matrix_int_5x8_column2; }template <> struct geometric_traits<detail::matrix_int_5x8_column2> { typedef detail::matrix_int_5x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,3> matrix_int_5x8_column3; }template <> struct geometric_traits<detail::matrix_int_5x8_column3> { typedef detail::matrix_int_5x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,4> matrix_int_5x8_column4; }template <> struct geometric_traits<detail::matrix_int_5x8_column4> { typedef detail::matrix_int_5x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,5> matrix_int_5x8_column5; }template <> struct geometric_traits<detail::matrix_int_5x8_column5> { typedef detail::matrix_int_5x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,6> matrix_int_5x8_column6; }template <> struct geometric_traits<detail::matrix_int_5x8_column6> { typedef detail::matrix_int_5x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x8,7> matrix_int_5x8_column7; }template <> struct geometric_traits<detail::matrix_int_5x8_column7> { typedef detail::matrix_int_5x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x8>::type > : index_operator_matrix_access_policy < matrix_int_5x8 > { typedef index_operator_matrix_access_policy < matrix_int_5x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x8 > { typedef dimension<5> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 9> matrix_int_5x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x9,0> matrix_int_5x9_row0; } template <> struct geometric_traits<detail::matrix_int_5x9_row0> { typedef detail::matrix_int_5x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x9,1> matrix_int_5x9_row1; } template <> struct geometric_traits<detail::matrix_int_5x9_row1> { typedef detail::matrix_int_5x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x9,2> matrix_int_5x9_row2; } template <> struct geometric_traits<detail::matrix_int_5x9_row2> { typedef detail::matrix_int_5x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x9,3> matrix_int_5x9_row3; } template <> struct geometric_traits<detail::matrix_int_5x9_row3> { typedef detail::matrix_int_5x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x9,4> matrix_int_5x9_row4; } template <> struct geometric_traits<detail::matrix_int_5x9_row4> { typedef detail::matrix_int_5x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,0> matrix_int_5x9_column0; }template <> struct geometric_traits<detail::matrix_int_5x9_column0> { typedef detail::matrix_int_5x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,1> matrix_int_5x9_column1; }template <> struct geometric_traits<detail::matrix_int_5x9_column1> { typedef detail::matrix_int_5x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,2> matrix_int_5x9_column2; }template <> struct geometric_traits<detail::matrix_int_5x9_column2> { typedef detail::matrix_int_5x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,3> matrix_int_5x9_column3; }template <> struct geometric_traits<detail::matrix_int_5x9_column3> { typedef detail::matrix_int_5x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,4> matrix_int_5x9_column4; }template <> struct geometric_traits<detail::matrix_int_5x9_column4> { typedef detail::matrix_int_5x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,5> matrix_int_5x9_column5; }template <> struct geometric_traits<detail::matrix_int_5x9_column5> { typedef detail::matrix_int_5x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,6> matrix_int_5x9_column6; }template <> struct geometric_traits<detail::matrix_int_5x9_column6> { typedef detail::matrix_int_5x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,7> matrix_int_5x9_column7; }template <> struct geometric_traits<detail::matrix_int_5x9_column7> { typedef detail::matrix_int_5x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x9,8> matrix_int_5x9_column8; }template <> struct geometric_traits<detail::matrix_int_5x9_column8> { typedef detail::matrix_int_5x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x9>::type > : index_operator_matrix_access_policy < matrix_int_5x9 > { typedef index_operator_matrix_access_policy < matrix_int_5x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x9 > { typedef dimension<5> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 5, 10> matrix_int_5x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x10,0> matrix_int_5x10_row0; } template <> struct geometric_traits<detail::matrix_int_5x10_row0> { typedef detail::matrix_int_5x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x10,1> matrix_int_5x10_row1; } template <> struct geometric_traits<detail::matrix_int_5x10_row1> { typedef detail::matrix_int_5x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x10,2> matrix_int_5x10_row2; } template <> struct geometric_traits<detail::matrix_int_5x10_row2> { typedef detail::matrix_int_5x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x10,3> matrix_int_5x10_row3; } template <> struct geometric_traits<detail::matrix_int_5x10_row3> { typedef detail::matrix_int_5x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_5x10,4> matrix_int_5x10_row4; } template <> struct geometric_traits<detail::matrix_int_5x10_row4> { typedef detail::matrix_int_5x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,0> matrix_int_5x10_column0; }template <> struct geometric_traits<detail::matrix_int_5x10_column0> { typedef detail::matrix_int_5x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,1> matrix_int_5x10_column1; }template <> struct geometric_traits<detail::matrix_int_5x10_column1> { typedef detail::matrix_int_5x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,2> matrix_int_5x10_column2; }template <> struct geometric_traits<detail::matrix_int_5x10_column2> { typedef detail::matrix_int_5x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,3> matrix_int_5x10_column3; }template <> struct geometric_traits<detail::matrix_int_5x10_column3> { typedef detail::matrix_int_5x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,4> matrix_int_5x10_column4; }template <> struct geometric_traits<detail::matrix_int_5x10_column4> { typedef detail::matrix_int_5x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,5> matrix_int_5x10_column5; }template <> struct geometric_traits<detail::matrix_int_5x10_column5> { typedef detail::matrix_int_5x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,6> matrix_int_5x10_column6; }template <> struct geometric_traits<detail::matrix_int_5x10_column6> { typedef detail::matrix_int_5x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,7> matrix_int_5x10_column7; }template <> struct geometric_traits<detail::matrix_int_5x10_column7> { typedef detail::matrix_int_5x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,8> matrix_int_5x10_column8; }template <> struct geometric_traits<detail::matrix_int_5x10_column8> { typedef detail::matrix_int_5x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_5x10,9> matrix_int_5x10_column9; }template <> struct geometric_traits<detail::matrix_int_5x10_column9> { typedef detail::matrix_int_5x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_5x10>::type > : index_operator_matrix_access_policy < matrix_int_5x10 > { typedef index_operator_matrix_access_policy < matrix_int_5x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_5x10 > { typedef dimension<5> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 1> matrix_int_6x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,0> matrix_int_6x1_row0; } template <> struct geometric_traits<detail::matrix_int_6x1_row0> { typedef detail::matrix_int_6x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,1> matrix_int_6x1_row1; } template <> struct geometric_traits<detail::matrix_int_6x1_row1> { typedef detail::matrix_int_6x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,2> matrix_int_6x1_row2; } template <> struct geometric_traits<detail::matrix_int_6x1_row2> { typedef detail::matrix_int_6x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,3> matrix_int_6x1_row3; } template <> struct geometric_traits<detail::matrix_int_6x1_row3> { typedef detail::matrix_int_6x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,4> matrix_int_6x1_row4; } template <> struct geometric_traits<detail::matrix_int_6x1_row4> { typedef detail::matrix_int_6x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x1,5> matrix_int_6x1_row5; } template <> struct geometric_traits<detail::matrix_int_6x1_row5> { typedef detail::matrix_int_6x1_row5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x1,0> matrix_int_6x1_column0; }template <> struct geometric_traits<detail::matrix_int_6x1_column0> { typedef detail::matrix_int_6x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x1>::type > : index_operator_matrix_access_policy < matrix_int_6x1 > { typedef index_operator_matrix_access_policy < matrix_int_6x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x1 > { typedef dimension<6> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 2> matrix_int_6x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,0> matrix_int_6x2_row0; } template <> struct geometric_traits<detail::matrix_int_6x2_row0> { typedef detail::matrix_int_6x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,1> matrix_int_6x2_row1; } template <> struct geometric_traits<detail::matrix_int_6x2_row1> { typedef detail::matrix_int_6x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,2> matrix_int_6x2_row2; } template <> struct geometric_traits<detail::matrix_int_6x2_row2> { typedef detail::matrix_int_6x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,3> matrix_int_6x2_row3; } template <> struct geometric_traits<detail::matrix_int_6x2_row3> { typedef detail::matrix_int_6x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,4> matrix_int_6x2_row4; } template <> struct geometric_traits<detail::matrix_int_6x2_row4> { typedef detail::matrix_int_6x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x2,5> matrix_int_6x2_row5; } template <> struct geometric_traits<detail::matrix_int_6x2_row5> { typedef detail::matrix_int_6x2_row5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x2,0> matrix_int_6x2_column0; }template <> struct geometric_traits<detail::matrix_int_6x2_column0> { typedef detail::matrix_int_6x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x2,1> matrix_int_6x2_column1; }template <> struct geometric_traits<detail::matrix_int_6x2_column1> { typedef detail::matrix_int_6x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x2>::type > : index_operator_matrix_access_policy < matrix_int_6x2 > { typedef index_operator_matrix_access_policy < matrix_int_6x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x2 > { typedef dimension<6> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 3> matrix_int_6x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,0> matrix_int_6x3_row0; } template <> struct geometric_traits<detail::matrix_int_6x3_row0> { typedef detail::matrix_int_6x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,1> matrix_int_6x3_row1; } template <> struct geometric_traits<detail::matrix_int_6x3_row1> { typedef detail::matrix_int_6x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,2> matrix_int_6x3_row2; } template <> struct geometric_traits<detail::matrix_int_6x3_row2> { typedef detail::matrix_int_6x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,3> matrix_int_6x3_row3; } template <> struct geometric_traits<detail::matrix_int_6x3_row3> { typedef detail::matrix_int_6x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,4> matrix_int_6x3_row4; } template <> struct geometric_traits<detail::matrix_int_6x3_row4> { typedef detail::matrix_int_6x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x3,5> matrix_int_6x3_row5; } template <> struct geometric_traits<detail::matrix_int_6x3_row5> { typedef detail::matrix_int_6x3_row5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x3,0> matrix_int_6x3_column0; }template <> struct geometric_traits<detail::matrix_int_6x3_column0> { typedef detail::matrix_int_6x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x3,1> matrix_int_6x3_column1; }template <> struct geometric_traits<detail::matrix_int_6x3_column1> { typedef detail::matrix_int_6x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x3,2> matrix_int_6x3_column2; }template <> struct geometric_traits<detail::matrix_int_6x3_column2> { typedef detail::matrix_int_6x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x3>::type > : index_operator_matrix_access_policy < matrix_int_6x3 > { typedef index_operator_matrix_access_policy < matrix_int_6x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x3 > { typedef dimension<6> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 4> matrix_int_6x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,0> matrix_int_6x4_row0; } template <> struct geometric_traits<detail::matrix_int_6x4_row0> { typedef detail::matrix_int_6x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,1> matrix_int_6x4_row1; } template <> struct geometric_traits<detail::matrix_int_6x4_row1> { typedef detail::matrix_int_6x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,2> matrix_int_6x4_row2; } template <> struct geometric_traits<detail::matrix_int_6x4_row2> { typedef detail::matrix_int_6x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,3> matrix_int_6x4_row3; } template <> struct geometric_traits<detail::matrix_int_6x4_row3> { typedef detail::matrix_int_6x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,4> matrix_int_6x4_row4; } template <> struct geometric_traits<detail::matrix_int_6x4_row4> { typedef detail::matrix_int_6x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x4,5> matrix_int_6x4_row5; } template <> struct geometric_traits<detail::matrix_int_6x4_row5> { typedef detail::matrix_int_6x4_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x4,0> matrix_int_6x4_column0; }template <> struct geometric_traits<detail::matrix_int_6x4_column0> { typedef detail::matrix_int_6x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x4,1> matrix_int_6x4_column1; }template <> struct geometric_traits<detail::matrix_int_6x4_column1> { typedef detail::matrix_int_6x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x4,2> matrix_int_6x4_column2; }template <> struct geometric_traits<detail::matrix_int_6x4_column2> { typedef detail::matrix_int_6x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x4,3> matrix_int_6x4_column3; }template <> struct geometric_traits<detail::matrix_int_6x4_column3> { typedef detail::matrix_int_6x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x4>::type > : index_operator_matrix_access_policy < matrix_int_6x4 > { typedef index_operator_matrix_access_policy < matrix_int_6x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x4 > { typedef dimension<6> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 5> matrix_int_6x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,0> matrix_int_6x5_row0; } template <> struct geometric_traits<detail::matrix_int_6x5_row0> { typedef detail::matrix_int_6x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,1> matrix_int_6x5_row1; } template <> struct geometric_traits<detail::matrix_int_6x5_row1> { typedef detail::matrix_int_6x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,2> matrix_int_6x5_row2; } template <> struct geometric_traits<detail::matrix_int_6x5_row2> { typedef detail::matrix_int_6x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,3> matrix_int_6x5_row3; } template <> struct geometric_traits<detail::matrix_int_6x5_row3> { typedef detail::matrix_int_6x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,4> matrix_int_6x5_row4; } template <> struct geometric_traits<detail::matrix_int_6x5_row4> { typedef detail::matrix_int_6x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x5,5> matrix_int_6x5_row5; } template <> struct geometric_traits<detail::matrix_int_6x5_row5> { typedef detail::matrix_int_6x5_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x5,0> matrix_int_6x5_column0; }template <> struct geometric_traits<detail::matrix_int_6x5_column0> { typedef detail::matrix_int_6x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x5,1> matrix_int_6x5_column1; }template <> struct geometric_traits<detail::matrix_int_6x5_column1> { typedef detail::matrix_int_6x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x5,2> matrix_int_6x5_column2; }template <> struct geometric_traits<detail::matrix_int_6x5_column2> { typedef detail::matrix_int_6x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x5,3> matrix_int_6x5_column3; }template <> struct geometric_traits<detail::matrix_int_6x5_column3> { typedef detail::matrix_int_6x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x5,4> matrix_int_6x5_column4; }template <> struct geometric_traits<detail::matrix_int_6x5_column4> { typedef detail::matrix_int_6x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x5>::type > : index_operator_matrix_access_policy < matrix_int_6x5 > { typedef index_operator_matrix_access_policy < matrix_int_6x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x5 > { typedef dimension<6> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 6> matrix_int_6x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,0> matrix_int_6x6_row0; } template <> struct geometric_traits<detail::matrix_int_6x6_row0> { typedef detail::matrix_int_6x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,1> matrix_int_6x6_row1; } template <> struct geometric_traits<detail::matrix_int_6x6_row1> { typedef detail::matrix_int_6x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,2> matrix_int_6x6_row2; } template <> struct geometric_traits<detail::matrix_int_6x6_row2> { typedef detail::matrix_int_6x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,3> matrix_int_6x6_row3; } template <> struct geometric_traits<detail::matrix_int_6x6_row3> { typedef detail::matrix_int_6x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,4> matrix_int_6x6_row4; } template <> struct geometric_traits<detail::matrix_int_6x6_row4> { typedef detail::matrix_int_6x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x6,5> matrix_int_6x6_row5; } template <> struct geometric_traits<detail::matrix_int_6x6_row5> { typedef detail::matrix_int_6x6_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,0> matrix_int_6x6_column0; }template <> struct geometric_traits<detail::matrix_int_6x6_column0> { typedef detail::matrix_int_6x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,1> matrix_int_6x6_column1; }template <> struct geometric_traits<detail::matrix_int_6x6_column1> { typedef detail::matrix_int_6x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,2> matrix_int_6x6_column2; }template <> struct geometric_traits<detail::matrix_int_6x6_column2> { typedef detail::matrix_int_6x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,3> matrix_int_6x6_column3; }template <> struct geometric_traits<detail::matrix_int_6x6_column3> { typedef detail::matrix_int_6x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,4> matrix_int_6x6_column4; }template <> struct geometric_traits<detail::matrix_int_6x6_column4> { typedef detail::matrix_int_6x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x6,5> matrix_int_6x6_column5; }template <> struct geometric_traits<detail::matrix_int_6x6_column5> { typedef detail::matrix_int_6x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x6>::type > : index_operator_matrix_access_policy < matrix_int_6x6 > { typedef index_operator_matrix_access_policy < matrix_int_6x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x6 > { typedef dimension<6> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 7> matrix_int_6x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,0> matrix_int_6x7_row0; } template <> struct geometric_traits<detail::matrix_int_6x7_row0> { typedef detail::matrix_int_6x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,1> matrix_int_6x7_row1; } template <> struct geometric_traits<detail::matrix_int_6x7_row1> { typedef detail::matrix_int_6x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,2> matrix_int_6x7_row2; } template <> struct geometric_traits<detail::matrix_int_6x7_row2> { typedef detail::matrix_int_6x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,3> matrix_int_6x7_row3; } template <> struct geometric_traits<detail::matrix_int_6x7_row3> { typedef detail::matrix_int_6x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,4> matrix_int_6x7_row4; } template <> struct geometric_traits<detail::matrix_int_6x7_row4> { typedef detail::matrix_int_6x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x7,5> matrix_int_6x7_row5; } template <> struct geometric_traits<detail::matrix_int_6x7_row5> { typedef detail::matrix_int_6x7_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,0> matrix_int_6x7_column0; }template <> struct geometric_traits<detail::matrix_int_6x7_column0> { typedef detail::matrix_int_6x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,1> matrix_int_6x7_column1; }template <> struct geometric_traits<detail::matrix_int_6x7_column1> { typedef detail::matrix_int_6x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,2> matrix_int_6x7_column2; }template <> struct geometric_traits<detail::matrix_int_6x7_column2> { typedef detail::matrix_int_6x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,3> matrix_int_6x7_column3; }template <> struct geometric_traits<detail::matrix_int_6x7_column3> { typedef detail::matrix_int_6x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,4> matrix_int_6x7_column4; }template <> struct geometric_traits<detail::matrix_int_6x7_column4> { typedef detail::matrix_int_6x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,5> matrix_int_6x7_column5; }template <> struct geometric_traits<detail::matrix_int_6x7_column5> { typedef detail::matrix_int_6x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x7,6> matrix_int_6x7_column6; }template <> struct geometric_traits<detail::matrix_int_6x7_column6> { typedef detail::matrix_int_6x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x7>::type > : index_operator_matrix_access_policy < matrix_int_6x7 > { typedef index_operator_matrix_access_policy < matrix_int_6x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x7 > { typedef dimension<6> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 8> matrix_int_6x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,0> matrix_int_6x8_row0; } template <> struct geometric_traits<detail::matrix_int_6x8_row0> { typedef detail::matrix_int_6x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,1> matrix_int_6x8_row1; } template <> struct geometric_traits<detail::matrix_int_6x8_row1> { typedef detail::matrix_int_6x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,2> matrix_int_6x8_row2; } template <> struct geometric_traits<detail::matrix_int_6x8_row2> { typedef detail::matrix_int_6x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,3> matrix_int_6x8_row3; } template <> struct geometric_traits<detail::matrix_int_6x8_row3> { typedef detail::matrix_int_6x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,4> matrix_int_6x8_row4; } template <> struct geometric_traits<detail::matrix_int_6x8_row4> { typedef detail::matrix_int_6x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x8,5> matrix_int_6x8_row5; } template <> struct geometric_traits<detail::matrix_int_6x8_row5> { typedef detail::matrix_int_6x8_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,0> matrix_int_6x8_column0; }template <> struct geometric_traits<detail::matrix_int_6x8_column0> { typedef detail::matrix_int_6x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,1> matrix_int_6x8_column1; }template <> struct geometric_traits<detail::matrix_int_6x8_column1> { typedef detail::matrix_int_6x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,2> matrix_int_6x8_column2; }template <> struct geometric_traits<detail::matrix_int_6x8_column2> { typedef detail::matrix_int_6x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,3> matrix_int_6x8_column3; }template <> struct geometric_traits<detail::matrix_int_6x8_column3> { typedef detail::matrix_int_6x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,4> matrix_int_6x8_column4; }template <> struct geometric_traits<detail::matrix_int_6x8_column4> { typedef detail::matrix_int_6x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,5> matrix_int_6x8_column5; }template <> struct geometric_traits<detail::matrix_int_6x8_column5> { typedef detail::matrix_int_6x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,6> matrix_int_6x8_column6; }template <> struct geometric_traits<detail::matrix_int_6x8_column6> { typedef detail::matrix_int_6x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x8,7> matrix_int_6x8_column7; }template <> struct geometric_traits<detail::matrix_int_6x8_column7> { typedef detail::matrix_int_6x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x8>::type > : index_operator_matrix_access_policy < matrix_int_6x8 > { typedef index_operator_matrix_access_policy < matrix_int_6x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x8 > { typedef dimension<6> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 9> matrix_int_6x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,0> matrix_int_6x9_row0; } template <> struct geometric_traits<detail::matrix_int_6x9_row0> { typedef detail::matrix_int_6x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,1> matrix_int_6x9_row1; } template <> struct geometric_traits<detail::matrix_int_6x9_row1> { typedef detail::matrix_int_6x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,2> matrix_int_6x9_row2; } template <> struct geometric_traits<detail::matrix_int_6x9_row2> { typedef detail::matrix_int_6x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,3> matrix_int_6x9_row3; } template <> struct geometric_traits<detail::matrix_int_6x9_row3> { typedef detail::matrix_int_6x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,4> matrix_int_6x9_row4; } template <> struct geometric_traits<detail::matrix_int_6x9_row4> { typedef detail::matrix_int_6x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x9,5> matrix_int_6x9_row5; } template <> struct geometric_traits<detail::matrix_int_6x9_row5> { typedef detail::matrix_int_6x9_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,0> matrix_int_6x9_column0; }template <> struct geometric_traits<detail::matrix_int_6x9_column0> { typedef detail::matrix_int_6x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,1> matrix_int_6x9_column1; }template <> struct geometric_traits<detail::matrix_int_6x9_column1> { typedef detail::matrix_int_6x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,2> matrix_int_6x9_column2; }template <> struct geometric_traits<detail::matrix_int_6x9_column2> { typedef detail::matrix_int_6x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,3> matrix_int_6x9_column3; }template <> struct geometric_traits<detail::matrix_int_6x9_column3> { typedef detail::matrix_int_6x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,4> matrix_int_6x9_column4; }template <> struct geometric_traits<detail::matrix_int_6x9_column4> { typedef detail::matrix_int_6x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,5> matrix_int_6x9_column5; }template <> struct geometric_traits<detail::matrix_int_6x9_column5> { typedef detail::matrix_int_6x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,6> matrix_int_6x9_column6; }template <> struct geometric_traits<detail::matrix_int_6x9_column6> { typedef detail::matrix_int_6x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,7> matrix_int_6x9_column7; }template <> struct geometric_traits<detail::matrix_int_6x9_column7> { typedef detail::matrix_int_6x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x9,8> matrix_int_6x9_column8; }template <> struct geometric_traits<detail::matrix_int_6x9_column8> { typedef detail::matrix_int_6x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x9>::type > : index_operator_matrix_access_policy < matrix_int_6x9 > { typedef index_operator_matrix_access_policy < matrix_int_6x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x9 > { typedef dimension<6> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 6, 10> matrix_int_6x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,0> matrix_int_6x10_row0; } template <> struct geometric_traits<detail::matrix_int_6x10_row0> { typedef detail::matrix_int_6x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,1> matrix_int_6x10_row1; } template <> struct geometric_traits<detail::matrix_int_6x10_row1> { typedef detail::matrix_int_6x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,2> matrix_int_6x10_row2; } template <> struct geometric_traits<detail::matrix_int_6x10_row2> { typedef detail::matrix_int_6x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,3> matrix_int_6x10_row3; } template <> struct geometric_traits<detail::matrix_int_6x10_row3> { typedef detail::matrix_int_6x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,4> matrix_int_6x10_row4; } template <> struct geometric_traits<detail::matrix_int_6x10_row4> { typedef detail::matrix_int_6x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_6x10,5> matrix_int_6x10_row5; } template <> struct geometric_traits<detail::matrix_int_6x10_row5> { typedef detail::matrix_int_6x10_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,0> matrix_int_6x10_column0; }template <> struct geometric_traits<detail::matrix_int_6x10_column0> { typedef detail::matrix_int_6x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,1> matrix_int_6x10_column1; }template <> struct geometric_traits<detail::matrix_int_6x10_column1> { typedef detail::matrix_int_6x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,2> matrix_int_6x10_column2; }template <> struct geometric_traits<detail::matrix_int_6x10_column2> { typedef detail::matrix_int_6x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,3> matrix_int_6x10_column3; }template <> struct geometric_traits<detail::matrix_int_6x10_column3> { typedef detail::matrix_int_6x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,4> matrix_int_6x10_column4; }template <> struct geometric_traits<detail::matrix_int_6x10_column4> { typedef detail::matrix_int_6x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,5> matrix_int_6x10_column5; }template <> struct geometric_traits<detail::matrix_int_6x10_column5> { typedef detail::matrix_int_6x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,6> matrix_int_6x10_column6; }template <> struct geometric_traits<detail::matrix_int_6x10_column6> { typedef detail::matrix_int_6x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,7> matrix_int_6x10_column7; }template <> struct geometric_traits<detail::matrix_int_6x10_column7> { typedef detail::matrix_int_6x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,8> matrix_int_6x10_column8; }template <> struct geometric_traits<detail::matrix_int_6x10_column8> { typedef detail::matrix_int_6x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_6x10,9> matrix_int_6x10_column9; }template <> struct geometric_traits<detail::matrix_int_6x10_column9> { typedef detail::matrix_int_6x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_6x10>::type > : index_operator_matrix_access_policy < matrix_int_6x10 > { typedef index_operator_matrix_access_policy < matrix_int_6x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_6x10 > { typedef dimension<6> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 1> matrix_int_7x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,0> matrix_int_7x1_row0; } template <> struct geometric_traits<detail::matrix_int_7x1_row0> { typedef detail::matrix_int_7x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,1> matrix_int_7x1_row1; } template <> struct geometric_traits<detail::matrix_int_7x1_row1> { typedef detail::matrix_int_7x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,2> matrix_int_7x1_row2; } template <> struct geometric_traits<detail::matrix_int_7x1_row2> { typedef detail::matrix_int_7x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,3> matrix_int_7x1_row3; } template <> struct geometric_traits<detail::matrix_int_7x1_row3> { typedef detail::matrix_int_7x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,4> matrix_int_7x1_row4; } template <> struct geometric_traits<detail::matrix_int_7x1_row4> { typedef detail::matrix_int_7x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,5> matrix_int_7x1_row5; } template <> struct geometric_traits<detail::matrix_int_7x1_row5> { typedef detail::matrix_int_7x1_row5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x1,6> matrix_int_7x1_row6; } template <> struct geometric_traits<detail::matrix_int_7x1_row6> { typedef detail::matrix_int_7x1_row6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x1,0> matrix_int_7x1_column0; }template <> struct geometric_traits<detail::matrix_int_7x1_column0> { typedef detail::matrix_int_7x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x1>::type > : index_operator_matrix_access_policy < matrix_int_7x1 > { typedef index_operator_matrix_access_policy < matrix_int_7x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x1 > { typedef dimension<7> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 2> matrix_int_7x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,0> matrix_int_7x2_row0; } template <> struct geometric_traits<detail::matrix_int_7x2_row0> { typedef detail::matrix_int_7x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,1> matrix_int_7x2_row1; } template <> struct geometric_traits<detail::matrix_int_7x2_row1> { typedef detail::matrix_int_7x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,2> matrix_int_7x2_row2; } template <> struct geometric_traits<detail::matrix_int_7x2_row2> { typedef detail::matrix_int_7x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,3> matrix_int_7x2_row3; } template <> struct geometric_traits<detail::matrix_int_7x2_row3> { typedef detail::matrix_int_7x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,4> matrix_int_7x2_row4; } template <> struct geometric_traits<detail::matrix_int_7x2_row4> { typedef detail::matrix_int_7x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,5> matrix_int_7x2_row5; } template <> struct geometric_traits<detail::matrix_int_7x2_row5> { typedef detail::matrix_int_7x2_row5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x2,6> matrix_int_7x2_row6; } template <> struct geometric_traits<detail::matrix_int_7x2_row6> { typedef detail::matrix_int_7x2_row6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x2,0> matrix_int_7x2_column0; }template <> struct geometric_traits<detail::matrix_int_7x2_column0> { typedef detail::matrix_int_7x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x2,1> matrix_int_7x2_column1; }template <> struct geometric_traits<detail::matrix_int_7x2_column1> { typedef detail::matrix_int_7x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x2>::type > : index_operator_matrix_access_policy < matrix_int_7x2 > { typedef index_operator_matrix_access_policy < matrix_int_7x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x2 > { typedef dimension<7> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 3> matrix_int_7x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,0> matrix_int_7x3_row0; } template <> struct geometric_traits<detail::matrix_int_7x3_row0> { typedef detail::matrix_int_7x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,1> matrix_int_7x3_row1; } template <> struct geometric_traits<detail::matrix_int_7x3_row1> { typedef detail::matrix_int_7x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,2> matrix_int_7x3_row2; } template <> struct geometric_traits<detail::matrix_int_7x3_row2> { typedef detail::matrix_int_7x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,3> matrix_int_7x3_row3; } template <> struct geometric_traits<detail::matrix_int_7x3_row3> { typedef detail::matrix_int_7x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,4> matrix_int_7x3_row4; } template <> struct geometric_traits<detail::matrix_int_7x3_row4> { typedef detail::matrix_int_7x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,5> matrix_int_7x3_row5; } template <> struct geometric_traits<detail::matrix_int_7x3_row5> { typedef detail::matrix_int_7x3_row5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x3,6> matrix_int_7x3_row6; } template <> struct geometric_traits<detail::matrix_int_7x3_row6> { typedef detail::matrix_int_7x3_row6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x3,0> matrix_int_7x3_column0; }template <> struct geometric_traits<detail::matrix_int_7x3_column0> { typedef detail::matrix_int_7x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x3,1> matrix_int_7x3_column1; }template <> struct geometric_traits<detail::matrix_int_7x3_column1> { typedef detail::matrix_int_7x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x3,2> matrix_int_7x3_column2; }template <> struct geometric_traits<detail::matrix_int_7x3_column2> { typedef detail::matrix_int_7x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x3>::type > : index_operator_matrix_access_policy < matrix_int_7x3 > { typedef index_operator_matrix_access_policy < matrix_int_7x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x3 > { typedef dimension<7> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 4> matrix_int_7x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,0> matrix_int_7x4_row0; } template <> struct geometric_traits<detail::matrix_int_7x4_row0> { typedef detail::matrix_int_7x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,1> matrix_int_7x4_row1; } template <> struct geometric_traits<detail::matrix_int_7x4_row1> { typedef detail::matrix_int_7x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,2> matrix_int_7x4_row2; } template <> struct geometric_traits<detail::matrix_int_7x4_row2> { typedef detail::matrix_int_7x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,3> matrix_int_7x4_row3; } template <> struct geometric_traits<detail::matrix_int_7x4_row3> { typedef detail::matrix_int_7x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,4> matrix_int_7x4_row4; } template <> struct geometric_traits<detail::matrix_int_7x4_row4> { typedef detail::matrix_int_7x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,5> matrix_int_7x4_row5; } template <> struct geometric_traits<detail::matrix_int_7x4_row5> { typedef detail::matrix_int_7x4_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x4,6> matrix_int_7x4_row6; } template <> struct geometric_traits<detail::matrix_int_7x4_row6> { typedef detail::matrix_int_7x4_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x4,0> matrix_int_7x4_column0; }template <> struct geometric_traits<detail::matrix_int_7x4_column0> { typedef detail::matrix_int_7x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x4,1> matrix_int_7x4_column1; }template <> struct geometric_traits<detail::matrix_int_7x4_column1> { typedef detail::matrix_int_7x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x4,2> matrix_int_7x4_column2; }template <> struct geometric_traits<detail::matrix_int_7x4_column2> { typedef detail::matrix_int_7x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x4,3> matrix_int_7x4_column3; }template <> struct geometric_traits<detail::matrix_int_7x4_column3> { typedef detail::matrix_int_7x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x4>::type > : index_operator_matrix_access_policy < matrix_int_7x4 > { typedef index_operator_matrix_access_policy < matrix_int_7x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x4 > { typedef dimension<7> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 5> matrix_int_7x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,0> matrix_int_7x5_row0; } template <> struct geometric_traits<detail::matrix_int_7x5_row0> { typedef detail::matrix_int_7x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,1> matrix_int_7x5_row1; } template <> struct geometric_traits<detail::matrix_int_7x5_row1> { typedef detail::matrix_int_7x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,2> matrix_int_7x5_row2; } template <> struct geometric_traits<detail::matrix_int_7x5_row2> { typedef detail::matrix_int_7x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,3> matrix_int_7x5_row3; } template <> struct geometric_traits<detail::matrix_int_7x5_row3> { typedef detail::matrix_int_7x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,4> matrix_int_7x5_row4; } template <> struct geometric_traits<detail::matrix_int_7x5_row4> { typedef detail::matrix_int_7x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,5> matrix_int_7x5_row5; } template <> struct geometric_traits<detail::matrix_int_7x5_row5> { typedef detail::matrix_int_7x5_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x5,6> matrix_int_7x5_row6; } template <> struct geometric_traits<detail::matrix_int_7x5_row6> { typedef detail::matrix_int_7x5_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x5,0> matrix_int_7x5_column0; }template <> struct geometric_traits<detail::matrix_int_7x5_column0> { typedef detail::matrix_int_7x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x5,1> matrix_int_7x5_column1; }template <> struct geometric_traits<detail::matrix_int_7x5_column1> { typedef detail::matrix_int_7x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x5,2> matrix_int_7x5_column2; }template <> struct geometric_traits<detail::matrix_int_7x5_column2> { typedef detail::matrix_int_7x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x5,3> matrix_int_7x5_column3; }template <> struct geometric_traits<detail::matrix_int_7x5_column3> { typedef detail::matrix_int_7x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x5,4> matrix_int_7x5_column4; }template <> struct geometric_traits<detail::matrix_int_7x5_column4> { typedef detail::matrix_int_7x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x5>::type > : index_operator_matrix_access_policy < matrix_int_7x5 > { typedef index_operator_matrix_access_policy < matrix_int_7x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x5 > { typedef dimension<7> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 6> matrix_int_7x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,0> matrix_int_7x6_row0; } template <> struct geometric_traits<detail::matrix_int_7x6_row0> { typedef detail::matrix_int_7x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,1> matrix_int_7x6_row1; } template <> struct geometric_traits<detail::matrix_int_7x6_row1> { typedef detail::matrix_int_7x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,2> matrix_int_7x6_row2; } template <> struct geometric_traits<detail::matrix_int_7x6_row2> { typedef detail::matrix_int_7x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,3> matrix_int_7x6_row3; } template <> struct geometric_traits<detail::matrix_int_7x6_row3> { typedef detail::matrix_int_7x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,4> matrix_int_7x6_row4; } template <> struct geometric_traits<detail::matrix_int_7x6_row4> { typedef detail::matrix_int_7x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,5> matrix_int_7x6_row5; } template <> struct geometric_traits<detail::matrix_int_7x6_row5> { typedef detail::matrix_int_7x6_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x6,6> matrix_int_7x6_row6; } template <> struct geometric_traits<detail::matrix_int_7x6_row6> { typedef detail::matrix_int_7x6_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,0> matrix_int_7x6_column0; }template <> struct geometric_traits<detail::matrix_int_7x6_column0> { typedef detail::matrix_int_7x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,1> matrix_int_7x6_column1; }template <> struct geometric_traits<detail::matrix_int_7x6_column1> { typedef detail::matrix_int_7x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,2> matrix_int_7x6_column2; }template <> struct geometric_traits<detail::matrix_int_7x6_column2> { typedef detail::matrix_int_7x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,3> matrix_int_7x6_column3; }template <> struct geometric_traits<detail::matrix_int_7x6_column3> { typedef detail::matrix_int_7x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,4> matrix_int_7x6_column4; }template <> struct geometric_traits<detail::matrix_int_7x6_column4> { typedef detail::matrix_int_7x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x6,5> matrix_int_7x6_column5; }template <> struct geometric_traits<detail::matrix_int_7x6_column5> { typedef detail::matrix_int_7x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x6>::type > : index_operator_matrix_access_policy < matrix_int_7x6 > { typedef index_operator_matrix_access_policy < matrix_int_7x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x6 > { typedef dimension<7> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 7> matrix_int_7x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,0> matrix_int_7x7_row0; } template <> struct geometric_traits<detail::matrix_int_7x7_row0> { typedef detail::matrix_int_7x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,1> matrix_int_7x7_row1; } template <> struct geometric_traits<detail::matrix_int_7x7_row1> { typedef detail::matrix_int_7x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,2> matrix_int_7x7_row2; } template <> struct geometric_traits<detail::matrix_int_7x7_row2> { typedef detail::matrix_int_7x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,3> matrix_int_7x7_row3; } template <> struct geometric_traits<detail::matrix_int_7x7_row3> { typedef detail::matrix_int_7x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,4> matrix_int_7x7_row4; } template <> struct geometric_traits<detail::matrix_int_7x7_row4> { typedef detail::matrix_int_7x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,5> matrix_int_7x7_row5; } template <> struct geometric_traits<detail::matrix_int_7x7_row5> { typedef detail::matrix_int_7x7_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x7,6> matrix_int_7x7_row6; } template <> struct geometric_traits<detail::matrix_int_7x7_row6> { typedef detail::matrix_int_7x7_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,0> matrix_int_7x7_column0; }template <> struct geometric_traits<detail::matrix_int_7x7_column0> { typedef detail::matrix_int_7x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,1> matrix_int_7x7_column1; }template <> struct geometric_traits<detail::matrix_int_7x7_column1> { typedef detail::matrix_int_7x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,2> matrix_int_7x7_column2; }template <> struct geometric_traits<detail::matrix_int_7x7_column2> { typedef detail::matrix_int_7x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,3> matrix_int_7x7_column3; }template <> struct geometric_traits<detail::matrix_int_7x7_column3> { typedef detail::matrix_int_7x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,4> matrix_int_7x7_column4; }template <> struct geometric_traits<detail::matrix_int_7x7_column4> { typedef detail::matrix_int_7x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,5> matrix_int_7x7_column5; }template <> struct geometric_traits<detail::matrix_int_7x7_column5> { typedef detail::matrix_int_7x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x7,6> matrix_int_7x7_column6; }template <> struct geometric_traits<detail::matrix_int_7x7_column6> { typedef detail::matrix_int_7x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x7>::type > : index_operator_matrix_access_policy < matrix_int_7x7 > { typedef index_operator_matrix_access_policy < matrix_int_7x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x7 > { typedef dimension<7> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 8> matrix_int_7x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,0> matrix_int_7x8_row0; } template <> struct geometric_traits<detail::matrix_int_7x8_row0> { typedef detail::matrix_int_7x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,1> matrix_int_7x8_row1; } template <> struct geometric_traits<detail::matrix_int_7x8_row1> { typedef detail::matrix_int_7x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,2> matrix_int_7x8_row2; } template <> struct geometric_traits<detail::matrix_int_7x8_row2> { typedef detail::matrix_int_7x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,3> matrix_int_7x8_row3; } template <> struct geometric_traits<detail::matrix_int_7x8_row3> { typedef detail::matrix_int_7x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,4> matrix_int_7x8_row4; } template <> struct geometric_traits<detail::matrix_int_7x8_row4> { typedef detail::matrix_int_7x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,5> matrix_int_7x8_row5; } template <> struct geometric_traits<detail::matrix_int_7x8_row5> { typedef detail::matrix_int_7x8_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x8,6> matrix_int_7x8_row6; } template <> struct geometric_traits<detail::matrix_int_7x8_row6> { typedef detail::matrix_int_7x8_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,0> matrix_int_7x8_column0; }template <> struct geometric_traits<detail::matrix_int_7x8_column0> { typedef detail::matrix_int_7x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,1> matrix_int_7x8_column1; }template <> struct geometric_traits<detail::matrix_int_7x8_column1> { typedef detail::matrix_int_7x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,2> matrix_int_7x8_column2; }template <> struct geometric_traits<detail::matrix_int_7x8_column2> { typedef detail::matrix_int_7x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,3> matrix_int_7x8_column3; }template <> struct geometric_traits<detail::matrix_int_7x8_column3> { typedef detail::matrix_int_7x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,4> matrix_int_7x8_column4; }template <> struct geometric_traits<detail::matrix_int_7x8_column4> { typedef detail::matrix_int_7x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,5> matrix_int_7x8_column5; }template <> struct geometric_traits<detail::matrix_int_7x8_column5> { typedef detail::matrix_int_7x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,6> matrix_int_7x8_column6; }template <> struct geometric_traits<detail::matrix_int_7x8_column6> { typedef detail::matrix_int_7x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x8,7> matrix_int_7x8_column7; }template <> struct geometric_traits<detail::matrix_int_7x8_column7> { typedef detail::matrix_int_7x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x8>::type > : index_operator_matrix_access_policy < matrix_int_7x8 > { typedef index_operator_matrix_access_policy < matrix_int_7x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x8 > { typedef dimension<7> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 9> matrix_int_7x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,0> matrix_int_7x9_row0; } template <> struct geometric_traits<detail::matrix_int_7x9_row0> { typedef detail::matrix_int_7x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,1> matrix_int_7x9_row1; } template <> struct geometric_traits<detail::matrix_int_7x9_row1> { typedef detail::matrix_int_7x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,2> matrix_int_7x9_row2; } template <> struct geometric_traits<detail::matrix_int_7x9_row2> { typedef detail::matrix_int_7x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,3> matrix_int_7x9_row3; } template <> struct geometric_traits<detail::matrix_int_7x9_row3> { typedef detail::matrix_int_7x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,4> matrix_int_7x9_row4; } template <> struct geometric_traits<detail::matrix_int_7x9_row4> { typedef detail::matrix_int_7x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,5> matrix_int_7x9_row5; } template <> struct geometric_traits<detail::matrix_int_7x9_row5> { typedef detail::matrix_int_7x9_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x9,6> matrix_int_7x9_row6; } template <> struct geometric_traits<detail::matrix_int_7x9_row6> { typedef detail::matrix_int_7x9_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,0> matrix_int_7x9_column0; }template <> struct geometric_traits<detail::matrix_int_7x9_column0> { typedef detail::matrix_int_7x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,1> matrix_int_7x9_column1; }template <> struct geometric_traits<detail::matrix_int_7x9_column1> { typedef detail::matrix_int_7x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,2> matrix_int_7x9_column2; }template <> struct geometric_traits<detail::matrix_int_7x9_column2> { typedef detail::matrix_int_7x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,3> matrix_int_7x9_column3; }template <> struct geometric_traits<detail::matrix_int_7x9_column3> { typedef detail::matrix_int_7x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,4> matrix_int_7x9_column4; }template <> struct geometric_traits<detail::matrix_int_7x9_column4> { typedef detail::matrix_int_7x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,5> matrix_int_7x9_column5; }template <> struct geometric_traits<detail::matrix_int_7x9_column5> { typedef detail::matrix_int_7x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,6> matrix_int_7x9_column6; }template <> struct geometric_traits<detail::matrix_int_7x9_column6> { typedef detail::matrix_int_7x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,7> matrix_int_7x9_column7; }template <> struct geometric_traits<detail::matrix_int_7x9_column7> { typedef detail::matrix_int_7x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x9,8> matrix_int_7x9_column8; }template <> struct geometric_traits<detail::matrix_int_7x9_column8> { typedef detail::matrix_int_7x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x9>::type > : index_operator_matrix_access_policy < matrix_int_7x9 > { typedef index_operator_matrix_access_policy < matrix_int_7x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x9 > { typedef dimension<7> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 7, 10> matrix_int_7x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,0> matrix_int_7x10_row0; } template <> struct geometric_traits<detail::matrix_int_7x10_row0> { typedef detail::matrix_int_7x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,1> matrix_int_7x10_row1; } template <> struct geometric_traits<detail::matrix_int_7x10_row1> { typedef detail::matrix_int_7x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,2> matrix_int_7x10_row2; } template <> struct geometric_traits<detail::matrix_int_7x10_row2> { typedef detail::matrix_int_7x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,3> matrix_int_7x10_row3; } template <> struct geometric_traits<detail::matrix_int_7x10_row3> { typedef detail::matrix_int_7x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,4> matrix_int_7x10_row4; } template <> struct geometric_traits<detail::matrix_int_7x10_row4> { typedef detail::matrix_int_7x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,5> matrix_int_7x10_row5; } template <> struct geometric_traits<detail::matrix_int_7x10_row5> { typedef detail::matrix_int_7x10_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_7x10,6> matrix_int_7x10_row6; } template <> struct geometric_traits<detail::matrix_int_7x10_row6> { typedef detail::matrix_int_7x10_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,0> matrix_int_7x10_column0; }template <> struct geometric_traits<detail::matrix_int_7x10_column0> { typedef detail::matrix_int_7x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,1> matrix_int_7x10_column1; }template <> struct geometric_traits<detail::matrix_int_7x10_column1> { typedef detail::matrix_int_7x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,2> matrix_int_7x10_column2; }template <> struct geometric_traits<detail::matrix_int_7x10_column2> { typedef detail::matrix_int_7x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,3> matrix_int_7x10_column3; }template <> struct geometric_traits<detail::matrix_int_7x10_column3> { typedef detail::matrix_int_7x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,4> matrix_int_7x10_column4; }template <> struct geometric_traits<detail::matrix_int_7x10_column4> { typedef detail::matrix_int_7x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,5> matrix_int_7x10_column5; }template <> struct geometric_traits<detail::matrix_int_7x10_column5> { typedef detail::matrix_int_7x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,6> matrix_int_7x10_column6; }template <> struct geometric_traits<detail::matrix_int_7x10_column6> { typedef detail::matrix_int_7x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,7> matrix_int_7x10_column7; }template <> struct geometric_traits<detail::matrix_int_7x10_column7> { typedef detail::matrix_int_7x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,8> matrix_int_7x10_column8; }template <> struct geometric_traits<detail::matrix_int_7x10_column8> { typedef detail::matrix_int_7x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_7x10,9> matrix_int_7x10_column9; }template <> struct geometric_traits<detail::matrix_int_7x10_column9> { typedef detail::matrix_int_7x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_7x10>::type > : index_operator_matrix_access_policy < matrix_int_7x10 > { typedef index_operator_matrix_access_policy < matrix_int_7x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_7x10 > { typedef dimension<7> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 1> matrix_int_8x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,0> matrix_int_8x1_row0; } template <> struct geometric_traits<detail::matrix_int_8x1_row0> { typedef detail::matrix_int_8x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,1> matrix_int_8x1_row1; } template <> struct geometric_traits<detail::matrix_int_8x1_row1> { typedef detail::matrix_int_8x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,2> matrix_int_8x1_row2; } template <> struct geometric_traits<detail::matrix_int_8x1_row2> { typedef detail::matrix_int_8x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,3> matrix_int_8x1_row3; } template <> struct geometric_traits<detail::matrix_int_8x1_row3> { typedef detail::matrix_int_8x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,4> matrix_int_8x1_row4; } template <> struct geometric_traits<detail::matrix_int_8x1_row4> { typedef detail::matrix_int_8x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,5> matrix_int_8x1_row5; } template <> struct geometric_traits<detail::matrix_int_8x1_row5> { typedef detail::matrix_int_8x1_row5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,6> matrix_int_8x1_row6; } template <> struct geometric_traits<detail::matrix_int_8x1_row6> { typedef detail::matrix_int_8x1_row6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x1,7> matrix_int_8x1_row7; } template <> struct geometric_traits<detail::matrix_int_8x1_row7> { typedef detail::matrix_int_8x1_row7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x1,0> matrix_int_8x1_column0; }template <> struct geometric_traits<detail::matrix_int_8x1_column0> { typedef detail::matrix_int_8x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x1>::type > : index_operator_matrix_access_policy < matrix_int_8x1 > { typedef index_operator_matrix_access_policy < matrix_int_8x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x1 > { typedef dimension<8> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 2> matrix_int_8x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,0> matrix_int_8x2_row0; } template <> struct geometric_traits<detail::matrix_int_8x2_row0> { typedef detail::matrix_int_8x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,1> matrix_int_8x2_row1; } template <> struct geometric_traits<detail::matrix_int_8x2_row1> { typedef detail::matrix_int_8x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,2> matrix_int_8x2_row2; } template <> struct geometric_traits<detail::matrix_int_8x2_row2> { typedef detail::matrix_int_8x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,3> matrix_int_8x2_row3; } template <> struct geometric_traits<detail::matrix_int_8x2_row3> { typedef detail::matrix_int_8x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,4> matrix_int_8x2_row4; } template <> struct geometric_traits<detail::matrix_int_8x2_row4> { typedef detail::matrix_int_8x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,5> matrix_int_8x2_row5; } template <> struct geometric_traits<detail::matrix_int_8x2_row5> { typedef detail::matrix_int_8x2_row5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,6> matrix_int_8x2_row6; } template <> struct geometric_traits<detail::matrix_int_8x2_row6> { typedef detail::matrix_int_8x2_row6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x2,7> matrix_int_8x2_row7; } template <> struct geometric_traits<detail::matrix_int_8x2_row7> { typedef detail::matrix_int_8x2_row7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x2,0> matrix_int_8x2_column0; }template <> struct geometric_traits<detail::matrix_int_8x2_column0> { typedef detail::matrix_int_8x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x2,1> matrix_int_8x2_column1; }template <> struct geometric_traits<detail::matrix_int_8x2_column1> { typedef detail::matrix_int_8x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x2>::type > : index_operator_matrix_access_policy < matrix_int_8x2 > { typedef index_operator_matrix_access_policy < matrix_int_8x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x2 > { typedef dimension<8> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 3> matrix_int_8x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,0> matrix_int_8x3_row0; } template <> struct geometric_traits<detail::matrix_int_8x3_row0> { typedef detail::matrix_int_8x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,1> matrix_int_8x3_row1; } template <> struct geometric_traits<detail::matrix_int_8x3_row1> { typedef detail::matrix_int_8x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,2> matrix_int_8x3_row2; } template <> struct geometric_traits<detail::matrix_int_8x3_row2> { typedef detail::matrix_int_8x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,3> matrix_int_8x3_row3; } template <> struct geometric_traits<detail::matrix_int_8x3_row3> { typedef detail::matrix_int_8x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,4> matrix_int_8x3_row4; } template <> struct geometric_traits<detail::matrix_int_8x3_row4> { typedef detail::matrix_int_8x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,5> matrix_int_8x3_row5; } template <> struct geometric_traits<detail::matrix_int_8x3_row5> { typedef detail::matrix_int_8x3_row5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,6> matrix_int_8x3_row6; } template <> struct geometric_traits<detail::matrix_int_8x3_row6> { typedef detail::matrix_int_8x3_row6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x3,7> matrix_int_8x3_row7; } template <> struct geometric_traits<detail::matrix_int_8x3_row7> { typedef detail::matrix_int_8x3_row7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x3,0> matrix_int_8x3_column0; }template <> struct geometric_traits<detail::matrix_int_8x3_column0> { typedef detail::matrix_int_8x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x3,1> matrix_int_8x3_column1; }template <> struct geometric_traits<detail::matrix_int_8x3_column1> { typedef detail::matrix_int_8x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x3,2> matrix_int_8x3_column2; }template <> struct geometric_traits<detail::matrix_int_8x3_column2> { typedef detail::matrix_int_8x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x3>::type > : index_operator_matrix_access_policy < matrix_int_8x3 > { typedef index_operator_matrix_access_policy < matrix_int_8x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x3 > { typedef dimension<8> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 4> matrix_int_8x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,0> matrix_int_8x4_row0; } template <> struct geometric_traits<detail::matrix_int_8x4_row0> { typedef detail::matrix_int_8x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,1> matrix_int_8x4_row1; } template <> struct geometric_traits<detail::matrix_int_8x4_row1> { typedef detail::matrix_int_8x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,2> matrix_int_8x4_row2; } template <> struct geometric_traits<detail::matrix_int_8x4_row2> { typedef detail::matrix_int_8x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,3> matrix_int_8x4_row3; } template <> struct geometric_traits<detail::matrix_int_8x4_row3> { typedef detail::matrix_int_8x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,4> matrix_int_8x4_row4; } template <> struct geometric_traits<detail::matrix_int_8x4_row4> { typedef detail::matrix_int_8x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,5> matrix_int_8x4_row5; } template <> struct geometric_traits<detail::matrix_int_8x4_row5> { typedef detail::matrix_int_8x4_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,6> matrix_int_8x4_row6; } template <> struct geometric_traits<detail::matrix_int_8x4_row6> { typedef detail::matrix_int_8x4_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x4,7> matrix_int_8x4_row7; } template <> struct geometric_traits<detail::matrix_int_8x4_row7> { typedef detail::matrix_int_8x4_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x4,0> matrix_int_8x4_column0; }template <> struct geometric_traits<detail::matrix_int_8x4_column0> { typedef detail::matrix_int_8x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x4,1> matrix_int_8x4_column1; }template <> struct geometric_traits<detail::matrix_int_8x4_column1> { typedef detail::matrix_int_8x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x4,2> matrix_int_8x4_column2; }template <> struct geometric_traits<detail::matrix_int_8x4_column2> { typedef detail::matrix_int_8x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x4,3> matrix_int_8x4_column3; }template <> struct geometric_traits<detail::matrix_int_8x4_column3> { typedef detail::matrix_int_8x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x4>::type > : index_operator_matrix_access_policy < matrix_int_8x4 > { typedef index_operator_matrix_access_policy < matrix_int_8x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x4 > { typedef dimension<8> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 5> matrix_int_8x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,0> matrix_int_8x5_row0; } template <> struct geometric_traits<detail::matrix_int_8x5_row0> { typedef detail::matrix_int_8x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,1> matrix_int_8x5_row1; } template <> struct geometric_traits<detail::matrix_int_8x5_row1> { typedef detail::matrix_int_8x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,2> matrix_int_8x5_row2; } template <> struct geometric_traits<detail::matrix_int_8x5_row2> { typedef detail::matrix_int_8x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,3> matrix_int_8x5_row3; } template <> struct geometric_traits<detail::matrix_int_8x5_row3> { typedef detail::matrix_int_8x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,4> matrix_int_8x5_row4; } template <> struct geometric_traits<detail::matrix_int_8x5_row4> { typedef detail::matrix_int_8x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,5> matrix_int_8x5_row5; } template <> struct geometric_traits<detail::matrix_int_8x5_row5> { typedef detail::matrix_int_8x5_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,6> matrix_int_8x5_row6; } template <> struct geometric_traits<detail::matrix_int_8x5_row6> { typedef detail::matrix_int_8x5_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x5,7> matrix_int_8x5_row7; } template <> struct geometric_traits<detail::matrix_int_8x5_row7> { typedef detail::matrix_int_8x5_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x5,0> matrix_int_8x5_column0; }template <> struct geometric_traits<detail::matrix_int_8x5_column0> { typedef detail::matrix_int_8x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x5,1> matrix_int_8x5_column1; }template <> struct geometric_traits<detail::matrix_int_8x5_column1> { typedef detail::matrix_int_8x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x5,2> matrix_int_8x5_column2; }template <> struct geometric_traits<detail::matrix_int_8x5_column2> { typedef detail::matrix_int_8x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x5,3> matrix_int_8x5_column3; }template <> struct geometric_traits<detail::matrix_int_8x5_column3> { typedef detail::matrix_int_8x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x5,4> matrix_int_8x5_column4; }template <> struct geometric_traits<detail::matrix_int_8x5_column4> { typedef detail::matrix_int_8x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x5>::type > : index_operator_matrix_access_policy < matrix_int_8x5 > { typedef index_operator_matrix_access_policy < matrix_int_8x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x5 > { typedef dimension<8> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 6> matrix_int_8x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,0> matrix_int_8x6_row0; } template <> struct geometric_traits<detail::matrix_int_8x6_row0> { typedef detail::matrix_int_8x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,1> matrix_int_8x6_row1; } template <> struct geometric_traits<detail::matrix_int_8x6_row1> { typedef detail::matrix_int_8x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,2> matrix_int_8x6_row2; } template <> struct geometric_traits<detail::matrix_int_8x6_row2> { typedef detail::matrix_int_8x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,3> matrix_int_8x6_row3; } template <> struct geometric_traits<detail::matrix_int_8x6_row3> { typedef detail::matrix_int_8x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,4> matrix_int_8x6_row4; } template <> struct geometric_traits<detail::matrix_int_8x6_row4> { typedef detail::matrix_int_8x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,5> matrix_int_8x6_row5; } template <> struct geometric_traits<detail::matrix_int_8x6_row5> { typedef detail::matrix_int_8x6_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,6> matrix_int_8x6_row6; } template <> struct geometric_traits<detail::matrix_int_8x6_row6> { typedef detail::matrix_int_8x6_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x6,7> matrix_int_8x6_row7; } template <> struct geometric_traits<detail::matrix_int_8x6_row7> { typedef detail::matrix_int_8x6_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,0> matrix_int_8x6_column0; }template <> struct geometric_traits<detail::matrix_int_8x6_column0> { typedef detail::matrix_int_8x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,1> matrix_int_8x6_column1; }template <> struct geometric_traits<detail::matrix_int_8x6_column1> { typedef detail::matrix_int_8x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,2> matrix_int_8x6_column2; }template <> struct geometric_traits<detail::matrix_int_8x6_column2> { typedef detail::matrix_int_8x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,3> matrix_int_8x6_column3; }template <> struct geometric_traits<detail::matrix_int_8x6_column3> { typedef detail::matrix_int_8x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,4> matrix_int_8x6_column4; }template <> struct geometric_traits<detail::matrix_int_8x6_column4> { typedef detail::matrix_int_8x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x6,5> matrix_int_8x6_column5; }template <> struct geometric_traits<detail::matrix_int_8x6_column5> { typedef detail::matrix_int_8x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x6>::type > : index_operator_matrix_access_policy < matrix_int_8x6 > { typedef index_operator_matrix_access_policy < matrix_int_8x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x6 > { typedef dimension<8> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 7> matrix_int_8x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,0> matrix_int_8x7_row0; } template <> struct geometric_traits<detail::matrix_int_8x7_row0> { typedef detail::matrix_int_8x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,1> matrix_int_8x7_row1; } template <> struct geometric_traits<detail::matrix_int_8x7_row1> { typedef detail::matrix_int_8x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,2> matrix_int_8x7_row2; } template <> struct geometric_traits<detail::matrix_int_8x7_row2> { typedef detail::matrix_int_8x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,3> matrix_int_8x7_row3; } template <> struct geometric_traits<detail::matrix_int_8x7_row3> { typedef detail::matrix_int_8x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,4> matrix_int_8x7_row4; } template <> struct geometric_traits<detail::matrix_int_8x7_row4> { typedef detail::matrix_int_8x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,5> matrix_int_8x7_row5; } template <> struct geometric_traits<detail::matrix_int_8x7_row5> { typedef detail::matrix_int_8x7_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,6> matrix_int_8x7_row6; } template <> struct geometric_traits<detail::matrix_int_8x7_row6> { typedef detail::matrix_int_8x7_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x7,7> matrix_int_8x7_row7; } template <> struct geometric_traits<detail::matrix_int_8x7_row7> { typedef detail::matrix_int_8x7_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,0> matrix_int_8x7_column0; }template <> struct geometric_traits<detail::matrix_int_8x7_column0> { typedef detail::matrix_int_8x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,1> matrix_int_8x7_column1; }template <> struct geometric_traits<detail::matrix_int_8x7_column1> { typedef detail::matrix_int_8x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,2> matrix_int_8x7_column2; }template <> struct geometric_traits<detail::matrix_int_8x7_column2> { typedef detail::matrix_int_8x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,3> matrix_int_8x7_column3; }template <> struct geometric_traits<detail::matrix_int_8x7_column3> { typedef detail::matrix_int_8x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,4> matrix_int_8x7_column4; }template <> struct geometric_traits<detail::matrix_int_8x7_column4> { typedef detail::matrix_int_8x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,5> matrix_int_8x7_column5; }template <> struct geometric_traits<detail::matrix_int_8x7_column5> { typedef detail::matrix_int_8x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x7,6> matrix_int_8x7_column6; }template <> struct geometric_traits<detail::matrix_int_8x7_column6> { typedef detail::matrix_int_8x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x7>::type > : index_operator_matrix_access_policy < matrix_int_8x7 > { typedef index_operator_matrix_access_policy < matrix_int_8x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x7 > { typedef dimension<8> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 8> matrix_int_8x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,0> matrix_int_8x8_row0; } template <> struct geometric_traits<detail::matrix_int_8x8_row0> { typedef detail::matrix_int_8x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,1> matrix_int_8x8_row1; } template <> struct geometric_traits<detail::matrix_int_8x8_row1> { typedef detail::matrix_int_8x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,2> matrix_int_8x8_row2; } template <> struct geometric_traits<detail::matrix_int_8x8_row2> { typedef detail::matrix_int_8x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,3> matrix_int_8x8_row3; } template <> struct geometric_traits<detail::matrix_int_8x8_row3> { typedef detail::matrix_int_8x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,4> matrix_int_8x8_row4; } template <> struct geometric_traits<detail::matrix_int_8x8_row4> { typedef detail::matrix_int_8x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,5> matrix_int_8x8_row5; } template <> struct geometric_traits<detail::matrix_int_8x8_row5> { typedef detail::matrix_int_8x8_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,6> matrix_int_8x8_row6; } template <> struct geometric_traits<detail::matrix_int_8x8_row6> { typedef detail::matrix_int_8x8_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x8,7> matrix_int_8x8_row7; } template <> struct geometric_traits<detail::matrix_int_8x8_row7> { typedef detail::matrix_int_8x8_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,0> matrix_int_8x8_column0; }template <> struct geometric_traits<detail::matrix_int_8x8_column0> { typedef detail::matrix_int_8x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,1> matrix_int_8x8_column1; }template <> struct geometric_traits<detail::matrix_int_8x8_column1> { typedef detail::matrix_int_8x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,2> matrix_int_8x8_column2; }template <> struct geometric_traits<detail::matrix_int_8x8_column2> { typedef detail::matrix_int_8x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,3> matrix_int_8x8_column3; }template <> struct geometric_traits<detail::matrix_int_8x8_column3> { typedef detail::matrix_int_8x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,4> matrix_int_8x8_column4; }template <> struct geometric_traits<detail::matrix_int_8x8_column4> { typedef detail::matrix_int_8x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,5> matrix_int_8x8_column5; }template <> struct geometric_traits<detail::matrix_int_8x8_column5> { typedef detail::matrix_int_8x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,6> matrix_int_8x8_column6; }template <> struct geometric_traits<detail::matrix_int_8x8_column6> { typedef detail::matrix_int_8x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x8,7> matrix_int_8x8_column7; }template <> struct geometric_traits<detail::matrix_int_8x8_column7> { typedef detail::matrix_int_8x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x8>::type > : index_operator_matrix_access_policy < matrix_int_8x8 > { typedef index_operator_matrix_access_policy < matrix_int_8x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x8 > { typedef dimension<8> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 9> matrix_int_8x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,0> matrix_int_8x9_row0; } template <> struct geometric_traits<detail::matrix_int_8x9_row0> { typedef detail::matrix_int_8x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,1> matrix_int_8x9_row1; } template <> struct geometric_traits<detail::matrix_int_8x9_row1> { typedef detail::matrix_int_8x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,2> matrix_int_8x9_row2; } template <> struct geometric_traits<detail::matrix_int_8x9_row2> { typedef detail::matrix_int_8x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,3> matrix_int_8x9_row3; } template <> struct geometric_traits<detail::matrix_int_8x9_row3> { typedef detail::matrix_int_8x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,4> matrix_int_8x9_row4; } template <> struct geometric_traits<detail::matrix_int_8x9_row4> { typedef detail::matrix_int_8x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,5> matrix_int_8x9_row5; } template <> struct geometric_traits<detail::matrix_int_8x9_row5> { typedef detail::matrix_int_8x9_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,6> matrix_int_8x9_row6; } template <> struct geometric_traits<detail::matrix_int_8x9_row6> { typedef detail::matrix_int_8x9_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x9,7> matrix_int_8x9_row7; } template <> struct geometric_traits<detail::matrix_int_8x9_row7> { typedef detail::matrix_int_8x9_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,0> matrix_int_8x9_column0; }template <> struct geometric_traits<detail::matrix_int_8x9_column0> { typedef detail::matrix_int_8x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,1> matrix_int_8x9_column1; }template <> struct geometric_traits<detail::matrix_int_8x9_column1> { typedef detail::matrix_int_8x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,2> matrix_int_8x9_column2; }template <> struct geometric_traits<detail::matrix_int_8x9_column2> { typedef detail::matrix_int_8x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,3> matrix_int_8x9_column3; }template <> struct geometric_traits<detail::matrix_int_8x9_column3> { typedef detail::matrix_int_8x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,4> matrix_int_8x9_column4; }template <> struct geometric_traits<detail::matrix_int_8x9_column4> { typedef detail::matrix_int_8x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,5> matrix_int_8x9_column5; }template <> struct geometric_traits<detail::matrix_int_8x9_column5> { typedef detail::matrix_int_8x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,6> matrix_int_8x9_column6; }template <> struct geometric_traits<detail::matrix_int_8x9_column6> { typedef detail::matrix_int_8x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,7> matrix_int_8x9_column7; }template <> struct geometric_traits<detail::matrix_int_8x9_column7> { typedef detail::matrix_int_8x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x9,8> matrix_int_8x9_column8; }template <> struct geometric_traits<detail::matrix_int_8x9_column8> { typedef detail::matrix_int_8x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x9>::type > : index_operator_matrix_access_policy < matrix_int_8x9 > { typedef index_operator_matrix_access_policy < matrix_int_8x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x9 > { typedef dimension<8> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 8, 10> matrix_int_8x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,0> matrix_int_8x10_row0; } template <> struct geometric_traits<detail::matrix_int_8x10_row0> { typedef detail::matrix_int_8x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,1> matrix_int_8x10_row1; } template <> struct geometric_traits<detail::matrix_int_8x10_row1> { typedef detail::matrix_int_8x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,2> matrix_int_8x10_row2; } template <> struct geometric_traits<detail::matrix_int_8x10_row2> { typedef detail::matrix_int_8x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,3> matrix_int_8x10_row3; } template <> struct geometric_traits<detail::matrix_int_8x10_row3> { typedef detail::matrix_int_8x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,4> matrix_int_8x10_row4; } template <> struct geometric_traits<detail::matrix_int_8x10_row4> { typedef detail::matrix_int_8x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,5> matrix_int_8x10_row5; } template <> struct geometric_traits<detail::matrix_int_8x10_row5> { typedef detail::matrix_int_8x10_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,6> matrix_int_8x10_row6; } template <> struct geometric_traits<detail::matrix_int_8x10_row6> { typedef detail::matrix_int_8x10_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_8x10,7> matrix_int_8x10_row7; } template <> struct geometric_traits<detail::matrix_int_8x10_row7> { typedef detail::matrix_int_8x10_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,0> matrix_int_8x10_column0; }template <> struct geometric_traits<detail::matrix_int_8x10_column0> { typedef detail::matrix_int_8x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,1> matrix_int_8x10_column1; }template <> struct geometric_traits<detail::matrix_int_8x10_column1> { typedef detail::matrix_int_8x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,2> matrix_int_8x10_column2; }template <> struct geometric_traits<detail::matrix_int_8x10_column2> { typedef detail::matrix_int_8x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,3> matrix_int_8x10_column3; }template <> struct geometric_traits<detail::matrix_int_8x10_column3> { typedef detail::matrix_int_8x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,4> matrix_int_8x10_column4; }template <> struct geometric_traits<detail::matrix_int_8x10_column4> { typedef detail::matrix_int_8x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,5> matrix_int_8x10_column5; }template <> struct geometric_traits<detail::matrix_int_8x10_column5> { typedef detail::matrix_int_8x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,6> matrix_int_8x10_column6; }template <> struct geometric_traits<detail::matrix_int_8x10_column6> { typedef detail::matrix_int_8x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,7> matrix_int_8x10_column7; }template <> struct geometric_traits<detail::matrix_int_8x10_column7> { typedef detail::matrix_int_8x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,8> matrix_int_8x10_column8; }template <> struct geometric_traits<detail::matrix_int_8x10_column8> { typedef detail::matrix_int_8x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_8x10,9> matrix_int_8x10_column9; }template <> struct geometric_traits<detail::matrix_int_8x10_column9> { typedef detail::matrix_int_8x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_8x10>::type > : index_operator_matrix_access_policy < matrix_int_8x10 > { typedef index_operator_matrix_access_policy < matrix_int_8x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_8x10 > { typedef dimension<8> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 1> matrix_int_9x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,0> matrix_int_9x1_row0; } template <> struct geometric_traits<detail::matrix_int_9x1_row0> { typedef detail::matrix_int_9x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,1> matrix_int_9x1_row1; } template <> struct geometric_traits<detail::matrix_int_9x1_row1> { typedef detail::matrix_int_9x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,2> matrix_int_9x1_row2; } template <> struct geometric_traits<detail::matrix_int_9x1_row2> { typedef detail::matrix_int_9x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,3> matrix_int_9x1_row3; } template <> struct geometric_traits<detail::matrix_int_9x1_row3> { typedef detail::matrix_int_9x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,4> matrix_int_9x1_row4; } template <> struct geometric_traits<detail::matrix_int_9x1_row4> { typedef detail::matrix_int_9x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,5> matrix_int_9x1_row5; } template <> struct geometric_traits<detail::matrix_int_9x1_row5> { typedef detail::matrix_int_9x1_row5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,6> matrix_int_9x1_row6; } template <> struct geometric_traits<detail::matrix_int_9x1_row6> { typedef detail::matrix_int_9x1_row6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,7> matrix_int_9x1_row7; } template <> struct geometric_traits<detail::matrix_int_9x1_row7> { typedef detail::matrix_int_9x1_row7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x1,8> matrix_int_9x1_row8; } template <> struct geometric_traits<detail::matrix_int_9x1_row8> { typedef detail::matrix_int_9x1_row8 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x1,0> matrix_int_9x1_column0; }template <> struct geometric_traits<detail::matrix_int_9x1_column0> { typedef detail::matrix_int_9x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x1>::type > : index_operator_matrix_access_policy < matrix_int_9x1 > { typedef index_operator_matrix_access_policy < matrix_int_9x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x1 > { typedef dimension<9> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 2> matrix_int_9x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,0> matrix_int_9x2_row0; } template <> struct geometric_traits<detail::matrix_int_9x2_row0> { typedef detail::matrix_int_9x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,1> matrix_int_9x2_row1; } template <> struct geometric_traits<detail::matrix_int_9x2_row1> { typedef detail::matrix_int_9x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,2> matrix_int_9x2_row2; } template <> struct geometric_traits<detail::matrix_int_9x2_row2> { typedef detail::matrix_int_9x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,3> matrix_int_9x2_row3; } template <> struct geometric_traits<detail::matrix_int_9x2_row3> { typedef detail::matrix_int_9x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,4> matrix_int_9x2_row4; } template <> struct geometric_traits<detail::matrix_int_9x2_row4> { typedef detail::matrix_int_9x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,5> matrix_int_9x2_row5; } template <> struct geometric_traits<detail::matrix_int_9x2_row5> { typedef detail::matrix_int_9x2_row5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,6> matrix_int_9x2_row6; } template <> struct geometric_traits<detail::matrix_int_9x2_row6> { typedef detail::matrix_int_9x2_row6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,7> matrix_int_9x2_row7; } template <> struct geometric_traits<detail::matrix_int_9x2_row7> { typedef detail::matrix_int_9x2_row7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x2,8> matrix_int_9x2_row8; } template <> struct geometric_traits<detail::matrix_int_9x2_row8> { typedef detail::matrix_int_9x2_row8 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x2,0> matrix_int_9x2_column0; }template <> struct geometric_traits<detail::matrix_int_9x2_column0> { typedef detail::matrix_int_9x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x2,1> matrix_int_9x2_column1; }template <> struct geometric_traits<detail::matrix_int_9x2_column1> { typedef detail::matrix_int_9x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x2>::type > : index_operator_matrix_access_policy < matrix_int_9x2 > { typedef index_operator_matrix_access_policy < matrix_int_9x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x2 > { typedef dimension<9> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 3> matrix_int_9x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,0> matrix_int_9x3_row0; } template <> struct geometric_traits<detail::matrix_int_9x3_row0> { typedef detail::matrix_int_9x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,1> matrix_int_9x3_row1; } template <> struct geometric_traits<detail::matrix_int_9x3_row1> { typedef detail::matrix_int_9x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,2> matrix_int_9x3_row2; } template <> struct geometric_traits<detail::matrix_int_9x3_row2> { typedef detail::matrix_int_9x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,3> matrix_int_9x3_row3; } template <> struct geometric_traits<detail::matrix_int_9x3_row3> { typedef detail::matrix_int_9x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,4> matrix_int_9x3_row4; } template <> struct geometric_traits<detail::matrix_int_9x3_row4> { typedef detail::matrix_int_9x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,5> matrix_int_9x3_row5; } template <> struct geometric_traits<detail::matrix_int_9x3_row5> { typedef detail::matrix_int_9x3_row5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,6> matrix_int_9x3_row6; } template <> struct geometric_traits<detail::matrix_int_9x3_row6> { typedef detail::matrix_int_9x3_row6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,7> matrix_int_9x3_row7; } template <> struct geometric_traits<detail::matrix_int_9x3_row7> { typedef detail::matrix_int_9x3_row7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x3,8> matrix_int_9x3_row8; } template <> struct geometric_traits<detail::matrix_int_9x3_row8> { typedef detail::matrix_int_9x3_row8 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x3,0> matrix_int_9x3_column0; }template <> struct geometric_traits<detail::matrix_int_9x3_column0> { typedef detail::matrix_int_9x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x3,1> matrix_int_9x3_column1; }template <> struct geometric_traits<detail::matrix_int_9x3_column1> { typedef detail::matrix_int_9x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x3,2> matrix_int_9x3_column2; }template <> struct geometric_traits<detail::matrix_int_9x3_column2> { typedef detail::matrix_int_9x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x3>::type > : index_operator_matrix_access_policy < matrix_int_9x3 > { typedef index_operator_matrix_access_policy < matrix_int_9x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x3 > { typedef dimension<9> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 4> matrix_int_9x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,0> matrix_int_9x4_row0; } template <> struct geometric_traits<detail::matrix_int_9x4_row0> { typedef detail::matrix_int_9x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,1> matrix_int_9x4_row1; } template <> struct geometric_traits<detail::matrix_int_9x4_row1> { typedef detail::matrix_int_9x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,2> matrix_int_9x4_row2; } template <> struct geometric_traits<detail::matrix_int_9x4_row2> { typedef detail::matrix_int_9x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,3> matrix_int_9x4_row3; } template <> struct geometric_traits<detail::matrix_int_9x4_row3> { typedef detail::matrix_int_9x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,4> matrix_int_9x4_row4; } template <> struct geometric_traits<detail::matrix_int_9x4_row4> { typedef detail::matrix_int_9x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,5> matrix_int_9x4_row5; } template <> struct geometric_traits<detail::matrix_int_9x4_row5> { typedef detail::matrix_int_9x4_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,6> matrix_int_9x4_row6; } template <> struct geometric_traits<detail::matrix_int_9x4_row6> { typedef detail::matrix_int_9x4_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,7> matrix_int_9x4_row7; } template <> struct geometric_traits<detail::matrix_int_9x4_row7> { typedef detail::matrix_int_9x4_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x4,8> matrix_int_9x4_row8; } template <> struct geometric_traits<detail::matrix_int_9x4_row8> { typedef detail::matrix_int_9x4_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x4,0> matrix_int_9x4_column0; }template <> struct geometric_traits<detail::matrix_int_9x4_column0> { typedef detail::matrix_int_9x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x4,1> matrix_int_9x4_column1; }template <> struct geometric_traits<detail::matrix_int_9x4_column1> { typedef detail::matrix_int_9x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x4,2> matrix_int_9x4_column2; }template <> struct geometric_traits<detail::matrix_int_9x4_column2> { typedef detail::matrix_int_9x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x4,3> matrix_int_9x4_column3; }template <> struct geometric_traits<detail::matrix_int_9x4_column3> { typedef detail::matrix_int_9x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x4>::type > : index_operator_matrix_access_policy < matrix_int_9x4 > { typedef index_operator_matrix_access_policy < matrix_int_9x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x4 > { typedef dimension<9> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 5> matrix_int_9x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,0> matrix_int_9x5_row0; } template <> struct geometric_traits<detail::matrix_int_9x5_row0> { typedef detail::matrix_int_9x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,1> matrix_int_9x5_row1; } template <> struct geometric_traits<detail::matrix_int_9x5_row1> { typedef detail::matrix_int_9x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,2> matrix_int_9x5_row2; } template <> struct geometric_traits<detail::matrix_int_9x5_row2> { typedef detail::matrix_int_9x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,3> matrix_int_9x5_row3; } template <> struct geometric_traits<detail::matrix_int_9x5_row3> { typedef detail::matrix_int_9x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,4> matrix_int_9x5_row4; } template <> struct geometric_traits<detail::matrix_int_9x5_row4> { typedef detail::matrix_int_9x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,5> matrix_int_9x5_row5; } template <> struct geometric_traits<detail::matrix_int_9x5_row5> { typedef detail::matrix_int_9x5_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,6> matrix_int_9x5_row6; } template <> struct geometric_traits<detail::matrix_int_9x5_row6> { typedef detail::matrix_int_9x5_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,7> matrix_int_9x5_row7; } template <> struct geometric_traits<detail::matrix_int_9x5_row7> { typedef detail::matrix_int_9x5_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x5,8> matrix_int_9x5_row8; } template <> struct geometric_traits<detail::matrix_int_9x5_row8> { typedef detail::matrix_int_9x5_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x5,0> matrix_int_9x5_column0; }template <> struct geometric_traits<detail::matrix_int_9x5_column0> { typedef detail::matrix_int_9x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x5,1> matrix_int_9x5_column1; }template <> struct geometric_traits<detail::matrix_int_9x5_column1> { typedef detail::matrix_int_9x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x5,2> matrix_int_9x5_column2; }template <> struct geometric_traits<detail::matrix_int_9x5_column2> { typedef detail::matrix_int_9x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x5,3> matrix_int_9x5_column3; }template <> struct geometric_traits<detail::matrix_int_9x5_column3> { typedef detail::matrix_int_9x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x5,4> matrix_int_9x5_column4; }template <> struct geometric_traits<detail::matrix_int_9x5_column4> { typedef detail::matrix_int_9x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x5>::type > : index_operator_matrix_access_policy < matrix_int_9x5 > { typedef index_operator_matrix_access_policy < matrix_int_9x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x5 > { typedef dimension<9> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 6> matrix_int_9x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,0> matrix_int_9x6_row0; } template <> struct geometric_traits<detail::matrix_int_9x6_row0> { typedef detail::matrix_int_9x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,1> matrix_int_9x6_row1; } template <> struct geometric_traits<detail::matrix_int_9x6_row1> { typedef detail::matrix_int_9x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,2> matrix_int_9x6_row2; } template <> struct geometric_traits<detail::matrix_int_9x6_row2> { typedef detail::matrix_int_9x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,3> matrix_int_9x6_row3; } template <> struct geometric_traits<detail::matrix_int_9x6_row3> { typedef detail::matrix_int_9x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,4> matrix_int_9x6_row4; } template <> struct geometric_traits<detail::matrix_int_9x6_row4> { typedef detail::matrix_int_9x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,5> matrix_int_9x6_row5; } template <> struct geometric_traits<detail::matrix_int_9x6_row5> { typedef detail::matrix_int_9x6_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,6> matrix_int_9x6_row6; } template <> struct geometric_traits<detail::matrix_int_9x6_row6> { typedef detail::matrix_int_9x6_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,7> matrix_int_9x6_row7; } template <> struct geometric_traits<detail::matrix_int_9x6_row7> { typedef detail::matrix_int_9x6_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x6,8> matrix_int_9x6_row8; } template <> struct geometric_traits<detail::matrix_int_9x6_row8> { typedef detail::matrix_int_9x6_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,0> matrix_int_9x6_column0; }template <> struct geometric_traits<detail::matrix_int_9x6_column0> { typedef detail::matrix_int_9x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,1> matrix_int_9x6_column1; }template <> struct geometric_traits<detail::matrix_int_9x6_column1> { typedef detail::matrix_int_9x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,2> matrix_int_9x6_column2; }template <> struct geometric_traits<detail::matrix_int_9x6_column2> { typedef detail::matrix_int_9x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,3> matrix_int_9x6_column3; }template <> struct geometric_traits<detail::matrix_int_9x6_column3> { typedef detail::matrix_int_9x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,4> matrix_int_9x6_column4; }template <> struct geometric_traits<detail::matrix_int_9x6_column4> { typedef detail::matrix_int_9x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x6,5> matrix_int_9x6_column5; }template <> struct geometric_traits<detail::matrix_int_9x6_column5> { typedef detail::matrix_int_9x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x6>::type > : index_operator_matrix_access_policy < matrix_int_9x6 > { typedef index_operator_matrix_access_policy < matrix_int_9x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x6 > { typedef dimension<9> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 7> matrix_int_9x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,0> matrix_int_9x7_row0; } template <> struct geometric_traits<detail::matrix_int_9x7_row0> { typedef detail::matrix_int_9x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,1> matrix_int_9x7_row1; } template <> struct geometric_traits<detail::matrix_int_9x7_row1> { typedef detail::matrix_int_9x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,2> matrix_int_9x7_row2; } template <> struct geometric_traits<detail::matrix_int_9x7_row2> { typedef detail::matrix_int_9x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,3> matrix_int_9x7_row3; } template <> struct geometric_traits<detail::matrix_int_9x7_row3> { typedef detail::matrix_int_9x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,4> matrix_int_9x7_row4; } template <> struct geometric_traits<detail::matrix_int_9x7_row4> { typedef detail::matrix_int_9x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,5> matrix_int_9x7_row5; } template <> struct geometric_traits<detail::matrix_int_9x7_row5> { typedef detail::matrix_int_9x7_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,6> matrix_int_9x7_row6; } template <> struct geometric_traits<detail::matrix_int_9x7_row6> { typedef detail::matrix_int_9x7_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,7> matrix_int_9x7_row7; } template <> struct geometric_traits<detail::matrix_int_9x7_row7> { typedef detail::matrix_int_9x7_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x7,8> matrix_int_9x7_row8; } template <> struct geometric_traits<detail::matrix_int_9x7_row8> { typedef detail::matrix_int_9x7_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,0> matrix_int_9x7_column0; }template <> struct geometric_traits<detail::matrix_int_9x7_column0> { typedef detail::matrix_int_9x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,1> matrix_int_9x7_column1; }template <> struct geometric_traits<detail::matrix_int_9x7_column1> { typedef detail::matrix_int_9x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,2> matrix_int_9x7_column2; }template <> struct geometric_traits<detail::matrix_int_9x7_column2> { typedef detail::matrix_int_9x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,3> matrix_int_9x7_column3; }template <> struct geometric_traits<detail::matrix_int_9x7_column3> { typedef detail::matrix_int_9x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,4> matrix_int_9x7_column4; }template <> struct geometric_traits<detail::matrix_int_9x7_column4> { typedef detail::matrix_int_9x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,5> matrix_int_9x7_column5; }template <> struct geometric_traits<detail::matrix_int_9x7_column5> { typedef detail::matrix_int_9x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x7,6> matrix_int_9x7_column6; }template <> struct geometric_traits<detail::matrix_int_9x7_column6> { typedef detail::matrix_int_9x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x7>::type > : index_operator_matrix_access_policy < matrix_int_9x7 > { typedef index_operator_matrix_access_policy < matrix_int_9x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x7 > { typedef dimension<9> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 8> matrix_int_9x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,0> matrix_int_9x8_row0; } template <> struct geometric_traits<detail::matrix_int_9x8_row0> { typedef detail::matrix_int_9x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,1> matrix_int_9x8_row1; } template <> struct geometric_traits<detail::matrix_int_9x8_row1> { typedef detail::matrix_int_9x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,2> matrix_int_9x8_row2; } template <> struct geometric_traits<detail::matrix_int_9x8_row2> { typedef detail::matrix_int_9x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,3> matrix_int_9x8_row3; } template <> struct geometric_traits<detail::matrix_int_9x8_row3> { typedef detail::matrix_int_9x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,4> matrix_int_9x8_row4; } template <> struct geometric_traits<detail::matrix_int_9x8_row4> { typedef detail::matrix_int_9x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,5> matrix_int_9x8_row5; } template <> struct geometric_traits<detail::matrix_int_9x8_row5> { typedef detail::matrix_int_9x8_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,6> matrix_int_9x8_row6; } template <> struct geometric_traits<detail::matrix_int_9x8_row6> { typedef detail::matrix_int_9x8_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,7> matrix_int_9x8_row7; } template <> struct geometric_traits<detail::matrix_int_9x8_row7> { typedef detail::matrix_int_9x8_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x8,8> matrix_int_9x8_row8; } template <> struct geometric_traits<detail::matrix_int_9x8_row8> { typedef detail::matrix_int_9x8_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,0> matrix_int_9x8_column0; }template <> struct geometric_traits<detail::matrix_int_9x8_column0> { typedef detail::matrix_int_9x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,1> matrix_int_9x8_column1; }template <> struct geometric_traits<detail::matrix_int_9x8_column1> { typedef detail::matrix_int_9x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,2> matrix_int_9x8_column2; }template <> struct geometric_traits<detail::matrix_int_9x8_column2> { typedef detail::matrix_int_9x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,3> matrix_int_9x8_column3; }template <> struct geometric_traits<detail::matrix_int_9x8_column3> { typedef detail::matrix_int_9x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,4> matrix_int_9x8_column4; }template <> struct geometric_traits<detail::matrix_int_9x8_column4> { typedef detail::matrix_int_9x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,5> matrix_int_9x8_column5; }template <> struct geometric_traits<detail::matrix_int_9x8_column5> { typedef detail::matrix_int_9x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,6> matrix_int_9x8_column6; }template <> struct geometric_traits<detail::matrix_int_9x8_column6> { typedef detail::matrix_int_9x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x8,7> matrix_int_9x8_column7; }template <> struct geometric_traits<detail::matrix_int_9x8_column7> { typedef detail::matrix_int_9x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x8>::type > : index_operator_matrix_access_policy < matrix_int_9x8 > { typedef index_operator_matrix_access_policy < matrix_int_9x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x8 > { typedef dimension<9> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 9> matrix_int_9x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,0> matrix_int_9x9_row0; } template <> struct geometric_traits<detail::matrix_int_9x9_row0> { typedef detail::matrix_int_9x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,1> matrix_int_9x9_row1; } template <> struct geometric_traits<detail::matrix_int_9x9_row1> { typedef detail::matrix_int_9x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,2> matrix_int_9x9_row2; } template <> struct geometric_traits<detail::matrix_int_9x9_row2> { typedef detail::matrix_int_9x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,3> matrix_int_9x9_row3; } template <> struct geometric_traits<detail::matrix_int_9x9_row3> { typedef detail::matrix_int_9x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,4> matrix_int_9x9_row4; } template <> struct geometric_traits<detail::matrix_int_9x9_row4> { typedef detail::matrix_int_9x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,5> matrix_int_9x9_row5; } template <> struct geometric_traits<detail::matrix_int_9x9_row5> { typedef detail::matrix_int_9x9_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,6> matrix_int_9x9_row6; } template <> struct geometric_traits<detail::matrix_int_9x9_row6> { typedef detail::matrix_int_9x9_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,7> matrix_int_9x9_row7; } template <> struct geometric_traits<detail::matrix_int_9x9_row7> { typedef detail::matrix_int_9x9_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x9,8> matrix_int_9x9_row8; } template <> struct geometric_traits<detail::matrix_int_9x9_row8> { typedef detail::matrix_int_9x9_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,0> matrix_int_9x9_column0; }template <> struct geometric_traits<detail::matrix_int_9x9_column0> { typedef detail::matrix_int_9x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,1> matrix_int_9x9_column1; }template <> struct geometric_traits<detail::matrix_int_9x9_column1> { typedef detail::matrix_int_9x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,2> matrix_int_9x9_column2; }template <> struct geometric_traits<detail::matrix_int_9x9_column2> { typedef detail::matrix_int_9x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,3> matrix_int_9x9_column3; }template <> struct geometric_traits<detail::matrix_int_9x9_column3> { typedef detail::matrix_int_9x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,4> matrix_int_9x9_column4; }template <> struct geometric_traits<detail::matrix_int_9x9_column4> { typedef detail::matrix_int_9x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,5> matrix_int_9x9_column5; }template <> struct geometric_traits<detail::matrix_int_9x9_column5> { typedef detail::matrix_int_9x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,6> matrix_int_9x9_column6; }template <> struct geometric_traits<detail::matrix_int_9x9_column6> { typedef detail::matrix_int_9x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,7> matrix_int_9x9_column7; }template <> struct geometric_traits<detail::matrix_int_9x9_column7> { typedef detail::matrix_int_9x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x9,8> matrix_int_9x9_column8; }template <> struct geometric_traits<detail::matrix_int_9x9_column8> { typedef detail::matrix_int_9x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x9>::type > : index_operator_matrix_access_policy < matrix_int_9x9 > { typedef index_operator_matrix_access_policy < matrix_int_9x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x9 > { typedef dimension<9> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 9, 10> matrix_int_9x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,0> matrix_int_9x10_row0; } template <> struct geometric_traits<detail::matrix_int_9x10_row0> { typedef detail::matrix_int_9x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,1> matrix_int_9x10_row1; } template <> struct geometric_traits<detail::matrix_int_9x10_row1> { typedef detail::matrix_int_9x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,2> matrix_int_9x10_row2; } template <> struct geometric_traits<detail::matrix_int_9x10_row2> { typedef detail::matrix_int_9x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,3> matrix_int_9x10_row3; } template <> struct geometric_traits<detail::matrix_int_9x10_row3> { typedef detail::matrix_int_9x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,4> matrix_int_9x10_row4; } template <> struct geometric_traits<detail::matrix_int_9x10_row4> { typedef detail::matrix_int_9x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,5> matrix_int_9x10_row5; } template <> struct geometric_traits<detail::matrix_int_9x10_row5> { typedef detail::matrix_int_9x10_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,6> matrix_int_9x10_row6; } template <> struct geometric_traits<detail::matrix_int_9x10_row6> { typedef detail::matrix_int_9x10_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,7> matrix_int_9x10_row7; } template <> struct geometric_traits<detail::matrix_int_9x10_row7> { typedef detail::matrix_int_9x10_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_9x10,8> matrix_int_9x10_row8; } template <> struct geometric_traits<detail::matrix_int_9x10_row8> { typedef detail::matrix_int_9x10_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,0> matrix_int_9x10_column0; }template <> struct geometric_traits<detail::matrix_int_9x10_column0> { typedef detail::matrix_int_9x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,1> matrix_int_9x10_column1; }template <> struct geometric_traits<detail::matrix_int_9x10_column1> { typedef detail::matrix_int_9x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,2> matrix_int_9x10_column2; }template <> struct geometric_traits<detail::matrix_int_9x10_column2> { typedef detail::matrix_int_9x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,3> matrix_int_9x10_column3; }template <> struct geometric_traits<detail::matrix_int_9x10_column3> { typedef detail::matrix_int_9x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,4> matrix_int_9x10_column4; }template <> struct geometric_traits<detail::matrix_int_9x10_column4> { typedef detail::matrix_int_9x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,5> matrix_int_9x10_column5; }template <> struct geometric_traits<detail::matrix_int_9x10_column5> { typedef detail::matrix_int_9x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,6> matrix_int_9x10_column6; }template <> struct geometric_traits<detail::matrix_int_9x10_column6> { typedef detail::matrix_int_9x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,7> matrix_int_9x10_column7; }template <> struct geometric_traits<detail::matrix_int_9x10_column7> { typedef detail::matrix_int_9x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,8> matrix_int_9x10_column8; }template <> struct geometric_traits<detail::matrix_int_9x10_column8> { typedef detail::matrix_int_9x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_9x10,9> matrix_int_9x10_column9; }template <> struct geometric_traits<detail::matrix_int_9x10_column9> { typedef detail::matrix_int_9x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_9x10>::type > : index_operator_matrix_access_policy < matrix_int_9x10 > { typedef index_operator_matrix_access_policy < matrix_int_9x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_9x10 > { typedef dimension<9> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 1> matrix_int_10x1; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,0> matrix_int_10x1_row0; } template <> struct geometric_traits<detail::matrix_int_10x1_row0> { typedef detail::matrix_int_10x1_row0 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,1> matrix_int_10x1_row1; } template <> struct geometric_traits<detail::matrix_int_10x1_row1> { typedef detail::matrix_int_10x1_row1 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,2> matrix_int_10x1_row2; } template <> struct geometric_traits<detail::matrix_int_10x1_row2> { typedef detail::matrix_int_10x1_row2 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,3> matrix_int_10x1_row3; } template <> struct geometric_traits<detail::matrix_int_10x1_row3> { typedef detail::matrix_int_10x1_row3 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,4> matrix_int_10x1_row4; } template <> struct geometric_traits<detail::matrix_int_10x1_row4> { typedef detail::matrix_int_10x1_row4 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,5> matrix_int_10x1_row5; } template <> struct geometric_traits<detail::matrix_int_10x1_row5> { typedef detail::matrix_int_10x1_row5 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,6> matrix_int_10x1_row6; } template <> struct geometric_traits<detail::matrix_int_10x1_row6> { typedef detail::matrix_int_10x1_row6 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,7> matrix_int_10x1_row7; } template <> struct geometric_traits<detail::matrix_int_10x1_row7> { typedef detail::matrix_int_10x1_row7 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,8> matrix_int_10x1_row8; } template <> struct geometric_traits<detail::matrix_int_10x1_row8> { typedef detail::matrix_int_10x1_row8 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x1,9> matrix_int_10x1_row9; } template <> struct geometric_traits<detail::matrix_int_10x1_row9> { typedef detail::matrix_int_10x1_row9 sequence_type; typedef boost::mpl::vector<int> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x1,0> matrix_int_10x1_column0; }template <> struct geometric_traits<detail::matrix_int_10x1_column0> { typedef detail::matrix_int_10x1_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x1>::type > : index_operator_matrix_access_policy < matrix_int_10x1 > { typedef index_operator_matrix_access_policy < matrix_int_10x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x1 > { typedef dimension<10> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 2> matrix_int_10x2; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,0> matrix_int_10x2_row0; } template <> struct geometric_traits<detail::matrix_int_10x2_row0> { typedef detail::matrix_int_10x2_row0 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,1> matrix_int_10x2_row1; } template <> struct geometric_traits<detail::matrix_int_10x2_row1> { typedef detail::matrix_int_10x2_row1 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,2> matrix_int_10x2_row2; } template <> struct geometric_traits<detail::matrix_int_10x2_row2> { typedef detail::matrix_int_10x2_row2 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,3> matrix_int_10x2_row3; } template <> struct geometric_traits<detail::matrix_int_10x2_row3> { typedef detail::matrix_int_10x2_row3 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,4> matrix_int_10x2_row4; } template <> struct geometric_traits<detail::matrix_int_10x2_row4> { typedef detail::matrix_int_10x2_row4 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,5> matrix_int_10x2_row5; } template <> struct geometric_traits<detail::matrix_int_10x2_row5> { typedef detail::matrix_int_10x2_row5 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,6> matrix_int_10x2_row6; } template <> struct geometric_traits<detail::matrix_int_10x2_row6> { typedef detail::matrix_int_10x2_row6 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,7> matrix_int_10x2_row7; } template <> struct geometric_traits<detail::matrix_int_10x2_row7> { typedef detail::matrix_int_10x2_row7 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,8> matrix_int_10x2_row8; } template <> struct geometric_traits<detail::matrix_int_10x2_row8> { typedef detail::matrix_int_10x2_row8 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x2,9> matrix_int_10x2_row9; } template <> struct geometric_traits<detail::matrix_int_10x2_row9> { typedef detail::matrix_int_10x2_row9 sequence_type; typedef boost::mpl::vector<int, int> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x2,0> matrix_int_10x2_column0; }template <> struct geometric_traits<detail::matrix_int_10x2_column0> { typedef detail::matrix_int_10x2_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x2,1> matrix_int_10x2_column1; }template <> struct geometric_traits<detail::matrix_int_10x2_column1> { typedef detail::matrix_int_10x2_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x2>::type > : index_operator_matrix_access_policy < matrix_int_10x2 > { typedef index_operator_matrix_access_policy < matrix_int_10x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x2 > { typedef dimension<10> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 3> matrix_int_10x3; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,0> matrix_int_10x3_row0; } template <> struct geometric_traits<detail::matrix_int_10x3_row0> { typedef detail::matrix_int_10x3_row0 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,1> matrix_int_10x3_row1; } template <> struct geometric_traits<detail::matrix_int_10x3_row1> { typedef detail::matrix_int_10x3_row1 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,2> matrix_int_10x3_row2; } template <> struct geometric_traits<detail::matrix_int_10x3_row2> { typedef detail::matrix_int_10x3_row2 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,3> matrix_int_10x3_row3; } template <> struct geometric_traits<detail::matrix_int_10x3_row3> { typedef detail::matrix_int_10x3_row3 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,4> matrix_int_10x3_row4; } template <> struct geometric_traits<detail::matrix_int_10x3_row4> { typedef detail::matrix_int_10x3_row4 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,5> matrix_int_10x3_row5; } template <> struct geometric_traits<detail::matrix_int_10x3_row5> { typedef detail::matrix_int_10x3_row5 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,6> matrix_int_10x3_row6; } template <> struct geometric_traits<detail::matrix_int_10x3_row6> { typedef detail::matrix_int_10x3_row6 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,7> matrix_int_10x3_row7; } template <> struct geometric_traits<detail::matrix_int_10x3_row7> { typedef detail::matrix_int_10x3_row7 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,8> matrix_int_10x3_row8; } template <> struct geometric_traits<detail::matrix_int_10x3_row8> { typedef detail::matrix_int_10x3_row8 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x3,9> matrix_int_10x3_row9; } template <> struct geometric_traits<detail::matrix_int_10x3_row9> { typedef detail::matrix_int_10x3_row9 sequence_type; typedef boost::mpl::vector<int, int, int> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x3,0> matrix_int_10x3_column0; }template <> struct geometric_traits<detail::matrix_int_10x3_column0> { typedef detail::matrix_int_10x3_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x3,1> matrix_int_10x3_column1; }template <> struct geometric_traits<detail::matrix_int_10x3_column1> { typedef detail::matrix_int_10x3_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x3,2> matrix_int_10x3_column2; }template <> struct geometric_traits<detail::matrix_int_10x3_column2> { typedef detail::matrix_int_10x3_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x3>::type > : index_operator_matrix_access_policy < matrix_int_10x3 > { typedef index_operator_matrix_access_policy < matrix_int_10x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x3 > { typedef dimension<10> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 4> matrix_int_10x4; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,0> matrix_int_10x4_row0; } template <> struct geometric_traits<detail::matrix_int_10x4_row0> { typedef detail::matrix_int_10x4_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,1> matrix_int_10x4_row1; } template <> struct geometric_traits<detail::matrix_int_10x4_row1> { typedef detail::matrix_int_10x4_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,2> matrix_int_10x4_row2; } template <> struct geometric_traits<detail::matrix_int_10x4_row2> { typedef detail::matrix_int_10x4_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,3> matrix_int_10x4_row3; } template <> struct geometric_traits<detail::matrix_int_10x4_row3> { typedef detail::matrix_int_10x4_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,4> matrix_int_10x4_row4; } template <> struct geometric_traits<detail::matrix_int_10x4_row4> { typedef detail::matrix_int_10x4_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,5> matrix_int_10x4_row5; } template <> struct geometric_traits<detail::matrix_int_10x4_row5> { typedef detail::matrix_int_10x4_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,6> matrix_int_10x4_row6; } template <> struct geometric_traits<detail::matrix_int_10x4_row6> { typedef detail::matrix_int_10x4_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,7> matrix_int_10x4_row7; } template <> struct geometric_traits<detail::matrix_int_10x4_row7> { typedef detail::matrix_int_10x4_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,8> matrix_int_10x4_row8; } template <> struct geometric_traits<detail::matrix_int_10x4_row8> { typedef detail::matrix_int_10x4_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x4,9> matrix_int_10x4_row9; } template <> struct geometric_traits<detail::matrix_int_10x4_row9> { typedef detail::matrix_int_10x4_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x4,0> matrix_int_10x4_column0; }template <> struct geometric_traits<detail::matrix_int_10x4_column0> { typedef detail::matrix_int_10x4_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x4,1> matrix_int_10x4_column1; }template <> struct geometric_traits<detail::matrix_int_10x4_column1> { typedef detail::matrix_int_10x4_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x4,2> matrix_int_10x4_column2; }template <> struct geometric_traits<detail::matrix_int_10x4_column2> { typedef detail::matrix_int_10x4_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x4,3> matrix_int_10x4_column3; }template <> struct geometric_traits<detail::matrix_int_10x4_column3> { typedef detail::matrix_int_10x4_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x4>::type > : index_operator_matrix_access_policy < matrix_int_10x4 > { typedef index_operator_matrix_access_policy < matrix_int_10x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x4 > { typedef dimension<10> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 5> matrix_int_10x5; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,0> matrix_int_10x5_row0; } template <> struct geometric_traits<detail::matrix_int_10x5_row0> { typedef detail::matrix_int_10x5_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,1> matrix_int_10x5_row1; } template <> struct geometric_traits<detail::matrix_int_10x5_row1> { typedef detail::matrix_int_10x5_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,2> matrix_int_10x5_row2; } template <> struct geometric_traits<detail::matrix_int_10x5_row2> { typedef detail::matrix_int_10x5_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,3> matrix_int_10x5_row3; } template <> struct geometric_traits<detail::matrix_int_10x5_row3> { typedef detail::matrix_int_10x5_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,4> matrix_int_10x5_row4; } template <> struct geometric_traits<detail::matrix_int_10x5_row4> { typedef detail::matrix_int_10x5_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,5> matrix_int_10x5_row5; } template <> struct geometric_traits<detail::matrix_int_10x5_row5> { typedef detail::matrix_int_10x5_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,6> matrix_int_10x5_row6; } template <> struct geometric_traits<detail::matrix_int_10x5_row6> { typedef detail::matrix_int_10x5_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,7> matrix_int_10x5_row7; } template <> struct geometric_traits<detail::matrix_int_10x5_row7> { typedef detail::matrix_int_10x5_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,8> matrix_int_10x5_row8; } template <> struct geometric_traits<detail::matrix_int_10x5_row8> { typedef detail::matrix_int_10x5_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x5,9> matrix_int_10x5_row9; } template <> struct geometric_traits<detail::matrix_int_10x5_row9> { typedef detail::matrix_int_10x5_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x5,0> matrix_int_10x5_column0; }template <> struct geometric_traits<detail::matrix_int_10x5_column0> { typedef detail::matrix_int_10x5_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x5,1> matrix_int_10x5_column1; }template <> struct geometric_traits<detail::matrix_int_10x5_column1> { typedef detail::matrix_int_10x5_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x5,2> matrix_int_10x5_column2; }template <> struct geometric_traits<detail::matrix_int_10x5_column2> { typedef detail::matrix_int_10x5_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x5,3> matrix_int_10x5_column3; }template <> struct geometric_traits<detail::matrix_int_10x5_column3> { typedef detail::matrix_int_10x5_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x5,4> matrix_int_10x5_column4; }template <> struct geometric_traits<detail::matrix_int_10x5_column4> { typedef detail::matrix_int_10x5_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x5>::type > : index_operator_matrix_access_policy < matrix_int_10x5 > { typedef index_operator_matrix_access_policy < matrix_int_10x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x5 > { typedef dimension<10> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 6> matrix_int_10x6; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,0> matrix_int_10x6_row0; } template <> struct geometric_traits<detail::matrix_int_10x6_row0> { typedef detail::matrix_int_10x6_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,1> matrix_int_10x6_row1; } template <> struct geometric_traits<detail::matrix_int_10x6_row1> { typedef detail::matrix_int_10x6_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,2> matrix_int_10x6_row2; } template <> struct geometric_traits<detail::matrix_int_10x6_row2> { typedef detail::matrix_int_10x6_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,3> matrix_int_10x6_row3; } template <> struct geometric_traits<detail::matrix_int_10x6_row3> { typedef detail::matrix_int_10x6_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,4> matrix_int_10x6_row4; } template <> struct geometric_traits<detail::matrix_int_10x6_row4> { typedef detail::matrix_int_10x6_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,5> matrix_int_10x6_row5; } template <> struct geometric_traits<detail::matrix_int_10x6_row5> { typedef detail::matrix_int_10x6_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,6> matrix_int_10x6_row6; } template <> struct geometric_traits<detail::matrix_int_10x6_row6> { typedef detail::matrix_int_10x6_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,7> matrix_int_10x6_row7; } template <> struct geometric_traits<detail::matrix_int_10x6_row7> { typedef detail::matrix_int_10x6_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,8> matrix_int_10x6_row8; } template <> struct geometric_traits<detail::matrix_int_10x6_row8> { typedef detail::matrix_int_10x6_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x6,9> matrix_int_10x6_row9; } template <> struct geometric_traits<detail::matrix_int_10x6_row9> { typedef detail::matrix_int_10x6_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,0> matrix_int_10x6_column0; }template <> struct geometric_traits<detail::matrix_int_10x6_column0> { typedef detail::matrix_int_10x6_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,1> matrix_int_10x6_column1; }template <> struct geometric_traits<detail::matrix_int_10x6_column1> { typedef detail::matrix_int_10x6_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,2> matrix_int_10x6_column2; }template <> struct geometric_traits<detail::matrix_int_10x6_column2> { typedef detail::matrix_int_10x6_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,3> matrix_int_10x6_column3; }template <> struct geometric_traits<detail::matrix_int_10x6_column3> { typedef detail::matrix_int_10x6_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,4> matrix_int_10x6_column4; }template <> struct geometric_traits<detail::matrix_int_10x6_column4> { typedef detail::matrix_int_10x6_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x6,5> matrix_int_10x6_column5; }template <> struct geometric_traits<detail::matrix_int_10x6_column5> { typedef detail::matrix_int_10x6_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x6>::type > : index_operator_matrix_access_policy < matrix_int_10x6 > { typedef index_operator_matrix_access_policy < matrix_int_10x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x6 > { typedef dimension<10> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 7> matrix_int_10x7; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,0> matrix_int_10x7_row0; } template <> struct geometric_traits<detail::matrix_int_10x7_row0> { typedef detail::matrix_int_10x7_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,1> matrix_int_10x7_row1; } template <> struct geometric_traits<detail::matrix_int_10x7_row1> { typedef detail::matrix_int_10x7_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,2> matrix_int_10x7_row2; } template <> struct geometric_traits<detail::matrix_int_10x7_row2> { typedef detail::matrix_int_10x7_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,3> matrix_int_10x7_row3; } template <> struct geometric_traits<detail::matrix_int_10x7_row3> { typedef detail::matrix_int_10x7_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,4> matrix_int_10x7_row4; } template <> struct geometric_traits<detail::matrix_int_10x7_row4> { typedef detail::matrix_int_10x7_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,5> matrix_int_10x7_row5; } template <> struct geometric_traits<detail::matrix_int_10x7_row5> { typedef detail::matrix_int_10x7_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,6> matrix_int_10x7_row6; } template <> struct geometric_traits<detail::matrix_int_10x7_row6> { typedef detail::matrix_int_10x7_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,7> matrix_int_10x7_row7; } template <> struct geometric_traits<detail::matrix_int_10x7_row7> { typedef detail::matrix_int_10x7_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,8> matrix_int_10x7_row8; } template <> struct geometric_traits<detail::matrix_int_10x7_row8> { typedef detail::matrix_int_10x7_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x7,9> matrix_int_10x7_row9; } template <> struct geometric_traits<detail::matrix_int_10x7_row9> { typedef detail::matrix_int_10x7_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,0> matrix_int_10x7_column0; }template <> struct geometric_traits<detail::matrix_int_10x7_column0> { typedef detail::matrix_int_10x7_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,1> matrix_int_10x7_column1; }template <> struct geometric_traits<detail::matrix_int_10x7_column1> { typedef detail::matrix_int_10x7_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,2> matrix_int_10x7_column2; }template <> struct geometric_traits<detail::matrix_int_10x7_column2> { typedef detail::matrix_int_10x7_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,3> matrix_int_10x7_column3; }template <> struct geometric_traits<detail::matrix_int_10x7_column3> { typedef detail::matrix_int_10x7_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,4> matrix_int_10x7_column4; }template <> struct geometric_traits<detail::matrix_int_10x7_column4> { typedef detail::matrix_int_10x7_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,5> matrix_int_10x7_column5; }template <> struct geometric_traits<detail::matrix_int_10x7_column5> { typedef detail::matrix_int_10x7_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x7,6> matrix_int_10x7_column6; }template <> struct geometric_traits<detail::matrix_int_10x7_column6> { typedef detail::matrix_int_10x7_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x7>::type > : index_operator_matrix_access_policy < matrix_int_10x7 > { typedef index_operator_matrix_access_policy < matrix_int_10x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x7 > { typedef dimension<10> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 8> matrix_int_10x8; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,0> matrix_int_10x8_row0; } template <> struct geometric_traits<detail::matrix_int_10x8_row0> { typedef detail::matrix_int_10x8_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,1> matrix_int_10x8_row1; } template <> struct geometric_traits<detail::matrix_int_10x8_row1> { typedef detail::matrix_int_10x8_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,2> matrix_int_10x8_row2; } template <> struct geometric_traits<detail::matrix_int_10x8_row2> { typedef detail::matrix_int_10x8_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,3> matrix_int_10x8_row3; } template <> struct geometric_traits<detail::matrix_int_10x8_row3> { typedef detail::matrix_int_10x8_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,4> matrix_int_10x8_row4; } template <> struct geometric_traits<detail::matrix_int_10x8_row4> { typedef detail::matrix_int_10x8_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,5> matrix_int_10x8_row5; } template <> struct geometric_traits<detail::matrix_int_10x8_row5> { typedef detail::matrix_int_10x8_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,6> matrix_int_10x8_row6; } template <> struct geometric_traits<detail::matrix_int_10x8_row6> { typedef detail::matrix_int_10x8_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,7> matrix_int_10x8_row7; } template <> struct geometric_traits<detail::matrix_int_10x8_row7> { typedef detail::matrix_int_10x8_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,8> matrix_int_10x8_row8; } template <> struct geometric_traits<detail::matrix_int_10x8_row8> { typedef detail::matrix_int_10x8_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x8,9> matrix_int_10x8_row9; } template <> struct geometric_traits<detail::matrix_int_10x8_row9> { typedef detail::matrix_int_10x8_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,0> matrix_int_10x8_column0; }template <> struct geometric_traits<detail::matrix_int_10x8_column0> { typedef detail::matrix_int_10x8_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,1> matrix_int_10x8_column1; }template <> struct geometric_traits<detail::matrix_int_10x8_column1> { typedef detail::matrix_int_10x8_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,2> matrix_int_10x8_column2; }template <> struct geometric_traits<detail::matrix_int_10x8_column2> { typedef detail::matrix_int_10x8_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,3> matrix_int_10x8_column3; }template <> struct geometric_traits<detail::matrix_int_10x8_column3> { typedef detail::matrix_int_10x8_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,4> matrix_int_10x8_column4; }template <> struct geometric_traits<detail::matrix_int_10x8_column4> { typedef detail::matrix_int_10x8_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,5> matrix_int_10x8_column5; }template <> struct geometric_traits<detail::matrix_int_10x8_column5> { typedef detail::matrix_int_10x8_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,6> matrix_int_10x8_column6; }template <> struct geometric_traits<detail::matrix_int_10x8_column6> { typedef detail::matrix_int_10x8_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x8,7> matrix_int_10x8_column7; }template <> struct geometric_traits<detail::matrix_int_10x8_column7> { typedef detail::matrix_int_10x8_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x8>::type > : index_operator_matrix_access_policy < matrix_int_10x8 > { typedef index_operator_matrix_access_policy < matrix_int_10x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x8 > { typedef dimension<10> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 9> matrix_int_10x9; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,0> matrix_int_10x9_row0; } template <> struct geometric_traits<detail::matrix_int_10x9_row0> { typedef detail::matrix_int_10x9_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,1> matrix_int_10x9_row1; } template <> struct geometric_traits<detail::matrix_int_10x9_row1> { typedef detail::matrix_int_10x9_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,2> matrix_int_10x9_row2; } template <> struct geometric_traits<detail::matrix_int_10x9_row2> { typedef detail::matrix_int_10x9_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,3> matrix_int_10x9_row3; } template <> struct geometric_traits<detail::matrix_int_10x9_row3> { typedef detail::matrix_int_10x9_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,4> matrix_int_10x9_row4; } template <> struct geometric_traits<detail::matrix_int_10x9_row4> { typedef detail::matrix_int_10x9_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,5> matrix_int_10x9_row5; } template <> struct geometric_traits<detail::matrix_int_10x9_row5> { typedef detail::matrix_int_10x9_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,6> matrix_int_10x9_row6; } template <> struct geometric_traits<detail::matrix_int_10x9_row6> { typedef detail::matrix_int_10x9_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,7> matrix_int_10x9_row7; } template <> struct geometric_traits<detail::matrix_int_10x9_row7> { typedef detail::matrix_int_10x9_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,8> matrix_int_10x9_row8; } template <> struct geometric_traits<detail::matrix_int_10x9_row8> { typedef detail::matrix_int_10x9_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x9,9> matrix_int_10x9_row9; } template <> struct geometric_traits<detail::matrix_int_10x9_row9> { typedef detail::matrix_int_10x9_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,0> matrix_int_10x9_column0; }template <> struct geometric_traits<detail::matrix_int_10x9_column0> { typedef detail::matrix_int_10x9_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,1> matrix_int_10x9_column1; }template <> struct geometric_traits<detail::matrix_int_10x9_column1> { typedef detail::matrix_int_10x9_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,2> matrix_int_10x9_column2; }template <> struct geometric_traits<detail::matrix_int_10x9_column2> { typedef detail::matrix_int_10x9_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,3> matrix_int_10x9_column3; }template <> struct geometric_traits<detail::matrix_int_10x9_column3> { typedef detail::matrix_int_10x9_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,4> matrix_int_10x9_column4; }template <> struct geometric_traits<detail::matrix_int_10x9_column4> { typedef detail::matrix_int_10x9_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,5> matrix_int_10x9_column5; }template <> struct geometric_traits<detail::matrix_int_10x9_column5> { typedef detail::matrix_int_10x9_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,6> matrix_int_10x9_column6; }template <> struct geometric_traits<detail::matrix_int_10x9_column6> { typedef detail::matrix_int_10x9_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,7> matrix_int_10x9_column7; }template <> struct geometric_traits<detail::matrix_int_10x9_column7> { typedef detail::matrix_int_10x9_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x9,8> matrix_int_10x9_column8; }template <> struct geometric_traits<detail::matrix_int_10x9_column8> { typedef detail::matrix_int_10x9_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x9>::type > : index_operator_matrix_access_policy < matrix_int_10x9 > { typedef index_operator_matrix_access_policy < matrix_int_10x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x9 > { typedef dimension<10> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<int, 10, 10> matrix_int_10x10; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,0> matrix_int_10x10_row0; } template <> struct geometric_traits<detail::matrix_int_10x10_row0> { typedef detail::matrix_int_10x10_row0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,1> matrix_int_10x10_row1; } template <> struct geometric_traits<detail::matrix_int_10x10_row1> { typedef detail::matrix_int_10x10_row1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,2> matrix_int_10x10_row2; } template <> struct geometric_traits<detail::matrix_int_10x10_row2> { typedef detail::matrix_int_10x10_row2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,3> matrix_int_10x10_row3; } template <> struct geometric_traits<detail::matrix_int_10x10_row3> { typedef detail::matrix_int_10x10_row3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,4> matrix_int_10x10_row4; } template <> struct geometric_traits<detail::matrix_int_10x10_row4> { typedef detail::matrix_int_10x10_row4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,5> matrix_int_10x10_row5; } template <> struct geometric_traits<detail::matrix_int_10x10_row5> { typedef detail::matrix_int_10x10_row5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,6> matrix_int_10x10_row6; } template <> struct geometric_traits<detail::matrix_int_10x10_row6> { typedef detail::matrix_int_10x10_row6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,7> matrix_int_10x10_row7; } template <> struct geometric_traits<detail::matrix_int_10x10_row7> { typedef detail::matrix_int_10x10_row7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,8> matrix_int_10x10_row8; } template <> struct geometric_traits<detail::matrix_int_10x10_row8> { typedef detail::matrix_int_10x10_row8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_int_10x10,9> matrix_int_10x10_row9; } template <> struct geometric_traits<detail::matrix_int_10x10_row9> { typedef detail::matrix_int_10x10_row9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,0> matrix_int_10x10_column0; }template <> struct geometric_traits<detail::matrix_int_10x10_column0> { typedef detail::matrix_int_10x10_column0 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,1> matrix_int_10x10_column1; }template <> struct geometric_traits<detail::matrix_int_10x10_column1> { typedef detail::matrix_int_10x10_column1 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,2> matrix_int_10x10_column2; }template <> struct geometric_traits<detail::matrix_int_10x10_column2> { typedef detail::matrix_int_10x10_column2 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,3> matrix_int_10x10_column3; }template <> struct geometric_traits<detail::matrix_int_10x10_column3> { typedef detail::matrix_int_10x10_column3 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,4> matrix_int_10x10_column4; }template <> struct geometric_traits<detail::matrix_int_10x10_column4> { typedef detail::matrix_int_10x10_column4 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,5> matrix_int_10x10_column5; }template <> struct geometric_traits<detail::matrix_int_10x10_column5> { typedef detail::matrix_int_10x10_column5 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,6> matrix_int_10x10_column6; }template <> struct geometric_traits<detail::matrix_int_10x10_column6> { typedef detail::matrix_int_10x10_column6 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,7> matrix_int_10x10_column7; }template <> struct geometric_traits<detail::matrix_int_10x10_column7> { typedef detail::matrix_int_10x10_column7 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,8> matrix_int_10x10_column8; }template <> struct geometric_traits<detail::matrix_int_10x10_column8> { typedef detail::matrix_int_10x10_column8 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_int_10x10,9> matrix_int_10x10_column9; }template <> struct geometric_traits<detail::matrix_int_10x10_column9> { typedef detail::matrix_int_10x10_column9 sequence_type; typedef boost::mpl::vector<int, int, int, int, int, int, int, int, int, int> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_int_10x10>::type > : index_operator_matrix_access_policy < matrix_int_10x10 > { typedef index_operator_matrix_access_policy < matrix_int_10x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_int_10x10 > { typedef dimension<10> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; }
    namespace geometrix { typedef matrix<short, 1, 1> matrix_short_1x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x1,0> matrix_short_1x1_row0; } template <> struct geometric_traits<detail::matrix_short_1x1_row0> { typedef detail::matrix_short_1x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x1,0> matrix_short_1x1_column0; }template <> struct geometric_traits<detail::matrix_short_1x1_column0> { typedef detail::matrix_short_1x1_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x1>::type > : index_operator_matrix_access_policy < matrix_short_1x1 > { typedef index_operator_matrix_access_policy < matrix_short_1x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x1 > { typedef dimension<1> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 2> matrix_short_1x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x2,0> matrix_short_1x2_row0; } template <> struct geometric_traits<detail::matrix_short_1x2_row0> { typedef detail::matrix_short_1x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x2,0> matrix_short_1x2_column0; }template <> struct geometric_traits<detail::matrix_short_1x2_column0> { typedef detail::matrix_short_1x2_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x2,1> matrix_short_1x2_column1; }template <> struct geometric_traits<detail::matrix_short_1x2_column1> { typedef detail::matrix_short_1x2_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x2>::type > : index_operator_matrix_access_policy < matrix_short_1x2 > { typedef index_operator_matrix_access_policy < matrix_short_1x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x2 > { typedef dimension<1> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 3> matrix_short_1x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x3,0> matrix_short_1x3_row0; } template <> struct geometric_traits<detail::matrix_short_1x3_row0> { typedef detail::matrix_short_1x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x3,0> matrix_short_1x3_column0; }template <> struct geometric_traits<detail::matrix_short_1x3_column0> { typedef detail::matrix_short_1x3_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x3,1> matrix_short_1x3_column1; }template <> struct geometric_traits<detail::matrix_short_1x3_column1> { typedef detail::matrix_short_1x3_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x3,2> matrix_short_1x3_column2; }template <> struct geometric_traits<detail::matrix_short_1x3_column2> { typedef detail::matrix_short_1x3_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x3>::type > : index_operator_matrix_access_policy < matrix_short_1x3 > { typedef index_operator_matrix_access_policy < matrix_short_1x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x3 > { typedef dimension<1> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 4> matrix_short_1x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x4,0> matrix_short_1x4_row0; } template <> struct geometric_traits<detail::matrix_short_1x4_row0> { typedef detail::matrix_short_1x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x4,0> matrix_short_1x4_column0; }template <> struct geometric_traits<detail::matrix_short_1x4_column0> { typedef detail::matrix_short_1x4_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x4,1> matrix_short_1x4_column1; }template <> struct geometric_traits<detail::matrix_short_1x4_column1> { typedef detail::matrix_short_1x4_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x4,2> matrix_short_1x4_column2; }template <> struct geometric_traits<detail::matrix_short_1x4_column2> { typedef detail::matrix_short_1x4_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x4,3> matrix_short_1x4_column3; }template <> struct geometric_traits<detail::matrix_short_1x4_column3> { typedef detail::matrix_short_1x4_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x4>::type > : index_operator_matrix_access_policy < matrix_short_1x4 > { typedef index_operator_matrix_access_policy < matrix_short_1x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x4 > { typedef dimension<1> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 5> matrix_short_1x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x5,0> matrix_short_1x5_row0; } template <> struct geometric_traits<detail::matrix_short_1x5_row0> { typedef detail::matrix_short_1x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x5,0> matrix_short_1x5_column0; }template <> struct geometric_traits<detail::matrix_short_1x5_column0> { typedef detail::matrix_short_1x5_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x5,1> matrix_short_1x5_column1; }template <> struct geometric_traits<detail::matrix_short_1x5_column1> { typedef detail::matrix_short_1x5_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x5,2> matrix_short_1x5_column2; }template <> struct geometric_traits<detail::matrix_short_1x5_column2> { typedef detail::matrix_short_1x5_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x5,3> matrix_short_1x5_column3; }template <> struct geometric_traits<detail::matrix_short_1x5_column3> { typedef detail::matrix_short_1x5_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x5,4> matrix_short_1x5_column4; }template <> struct geometric_traits<detail::matrix_short_1x5_column4> { typedef detail::matrix_short_1x5_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x5>::type > : index_operator_matrix_access_policy < matrix_short_1x5 > { typedef index_operator_matrix_access_policy < matrix_short_1x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x5 > { typedef dimension<1> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 6> matrix_short_1x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x6,0> matrix_short_1x6_row0; } template <> struct geometric_traits<detail::matrix_short_1x6_row0> { typedef detail::matrix_short_1x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,0> matrix_short_1x6_column0; }template <> struct geometric_traits<detail::matrix_short_1x6_column0> { typedef detail::matrix_short_1x6_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,1> matrix_short_1x6_column1; }template <> struct geometric_traits<detail::matrix_short_1x6_column1> { typedef detail::matrix_short_1x6_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,2> matrix_short_1x6_column2; }template <> struct geometric_traits<detail::matrix_short_1x6_column2> { typedef detail::matrix_short_1x6_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,3> matrix_short_1x6_column3; }template <> struct geometric_traits<detail::matrix_short_1x6_column3> { typedef detail::matrix_short_1x6_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,4> matrix_short_1x6_column4; }template <> struct geometric_traits<detail::matrix_short_1x6_column4> { typedef detail::matrix_short_1x6_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x6,5> matrix_short_1x6_column5; }template <> struct geometric_traits<detail::matrix_short_1x6_column5> { typedef detail::matrix_short_1x6_column5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x6>::type > : index_operator_matrix_access_policy < matrix_short_1x6 > { typedef index_operator_matrix_access_policy < matrix_short_1x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x6 > { typedef dimension<1> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 7> matrix_short_1x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x7,0> matrix_short_1x7_row0; } template <> struct geometric_traits<detail::matrix_short_1x7_row0> { typedef detail::matrix_short_1x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,0> matrix_short_1x7_column0; }template <> struct geometric_traits<detail::matrix_short_1x7_column0> { typedef detail::matrix_short_1x7_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,1> matrix_short_1x7_column1; }template <> struct geometric_traits<detail::matrix_short_1x7_column1> { typedef detail::matrix_short_1x7_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,2> matrix_short_1x7_column2; }template <> struct geometric_traits<detail::matrix_short_1x7_column2> { typedef detail::matrix_short_1x7_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,3> matrix_short_1x7_column3; }template <> struct geometric_traits<detail::matrix_short_1x7_column3> { typedef detail::matrix_short_1x7_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,4> matrix_short_1x7_column4; }template <> struct geometric_traits<detail::matrix_short_1x7_column4> { typedef detail::matrix_short_1x7_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,5> matrix_short_1x7_column5; }template <> struct geometric_traits<detail::matrix_short_1x7_column5> { typedef detail::matrix_short_1x7_column5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x7,6> matrix_short_1x7_column6; }template <> struct geometric_traits<detail::matrix_short_1x7_column6> { typedef detail::matrix_short_1x7_column6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x7>::type > : index_operator_matrix_access_policy < matrix_short_1x7 > { typedef index_operator_matrix_access_policy < matrix_short_1x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x7 > { typedef dimension<1> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 8> matrix_short_1x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x8,0> matrix_short_1x8_row0; } template <> struct geometric_traits<detail::matrix_short_1x8_row0> { typedef detail::matrix_short_1x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,0> matrix_short_1x8_column0; }template <> struct geometric_traits<detail::matrix_short_1x8_column0> { typedef detail::matrix_short_1x8_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,1> matrix_short_1x8_column1; }template <> struct geometric_traits<detail::matrix_short_1x8_column1> { typedef detail::matrix_short_1x8_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,2> matrix_short_1x8_column2; }template <> struct geometric_traits<detail::matrix_short_1x8_column2> { typedef detail::matrix_short_1x8_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,3> matrix_short_1x8_column3; }template <> struct geometric_traits<detail::matrix_short_1x8_column3> { typedef detail::matrix_short_1x8_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,4> matrix_short_1x8_column4; }template <> struct geometric_traits<detail::matrix_short_1x8_column4> { typedef detail::matrix_short_1x8_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,5> matrix_short_1x8_column5; }template <> struct geometric_traits<detail::matrix_short_1x8_column5> { typedef detail::matrix_short_1x8_column5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,6> matrix_short_1x8_column6; }template <> struct geometric_traits<detail::matrix_short_1x8_column6> { typedef detail::matrix_short_1x8_column6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x8,7> matrix_short_1x8_column7; }template <> struct geometric_traits<detail::matrix_short_1x8_column7> { typedef detail::matrix_short_1x8_column7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x8>::type > : index_operator_matrix_access_policy < matrix_short_1x8 > { typedef index_operator_matrix_access_policy < matrix_short_1x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x8 > { typedef dimension<1> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 9> matrix_short_1x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x9,0> matrix_short_1x9_row0; } template <> struct geometric_traits<detail::matrix_short_1x9_row0> { typedef detail::matrix_short_1x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,0> matrix_short_1x9_column0; }template <> struct geometric_traits<detail::matrix_short_1x9_column0> { typedef detail::matrix_short_1x9_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,1> matrix_short_1x9_column1; }template <> struct geometric_traits<detail::matrix_short_1x9_column1> { typedef detail::matrix_short_1x9_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,2> matrix_short_1x9_column2; }template <> struct geometric_traits<detail::matrix_short_1x9_column2> { typedef detail::matrix_short_1x9_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,3> matrix_short_1x9_column3; }template <> struct geometric_traits<detail::matrix_short_1x9_column3> { typedef detail::matrix_short_1x9_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,4> matrix_short_1x9_column4; }template <> struct geometric_traits<detail::matrix_short_1x9_column4> { typedef detail::matrix_short_1x9_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,5> matrix_short_1x9_column5; }template <> struct geometric_traits<detail::matrix_short_1x9_column5> { typedef detail::matrix_short_1x9_column5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,6> matrix_short_1x9_column6; }template <> struct geometric_traits<detail::matrix_short_1x9_column6> { typedef detail::matrix_short_1x9_column6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,7> matrix_short_1x9_column7; }template <> struct geometric_traits<detail::matrix_short_1x9_column7> { typedef detail::matrix_short_1x9_column7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x9,8> matrix_short_1x9_column8; }template <> struct geometric_traits<detail::matrix_short_1x9_column8> { typedef detail::matrix_short_1x9_column8 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x9>::type > : index_operator_matrix_access_policy < matrix_short_1x9 > { typedef index_operator_matrix_access_policy < matrix_short_1x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x9 > { typedef dimension<1> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 1, 10> matrix_short_1x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_1x10,0> matrix_short_1x10_row0; } template <> struct geometric_traits<detail::matrix_short_1x10_row0> { typedef detail::matrix_short_1x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,0> matrix_short_1x10_column0; }template <> struct geometric_traits<detail::matrix_short_1x10_column0> { typedef detail::matrix_short_1x10_column0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,1> matrix_short_1x10_column1; }template <> struct geometric_traits<detail::matrix_short_1x10_column1> { typedef detail::matrix_short_1x10_column1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,2> matrix_short_1x10_column2; }template <> struct geometric_traits<detail::matrix_short_1x10_column2> { typedef detail::matrix_short_1x10_column2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,3> matrix_short_1x10_column3; }template <> struct geometric_traits<detail::matrix_short_1x10_column3> { typedef detail::matrix_short_1x10_column3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,4> matrix_short_1x10_column4; }template <> struct geometric_traits<detail::matrix_short_1x10_column4> { typedef detail::matrix_short_1x10_column4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,5> matrix_short_1x10_column5; }template <> struct geometric_traits<detail::matrix_short_1x10_column5> { typedef detail::matrix_short_1x10_column5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,6> matrix_short_1x10_column6; }template <> struct geometric_traits<detail::matrix_short_1x10_column6> { typedef detail::matrix_short_1x10_column6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,7> matrix_short_1x10_column7; }template <> struct geometric_traits<detail::matrix_short_1x10_column7> { typedef detail::matrix_short_1x10_column7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,8> matrix_short_1x10_column8; }template <> struct geometric_traits<detail::matrix_short_1x10_column8> { typedef detail::matrix_short_1x10_column8 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_1x10,9> matrix_short_1x10_column9; }template <> struct geometric_traits<detail::matrix_short_1x10_column9> { typedef detail::matrix_short_1x10_column9 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_1x10>::type > : index_operator_matrix_access_policy < matrix_short_1x10 > { typedef index_operator_matrix_access_policy < matrix_short_1x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_1x10 > { typedef dimension<1> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 1> matrix_short_2x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x1,0> matrix_short_2x1_row0; } template <> struct geometric_traits<detail::matrix_short_2x1_row0> { typedef detail::matrix_short_2x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x1,1> matrix_short_2x1_row1; } template <> struct geometric_traits<detail::matrix_short_2x1_row1> { typedef detail::matrix_short_2x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x1,0> matrix_short_2x1_column0; }template <> struct geometric_traits<detail::matrix_short_2x1_column0> { typedef detail::matrix_short_2x1_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x1>::type > : index_operator_matrix_access_policy < matrix_short_2x1 > { typedef index_operator_matrix_access_policy < matrix_short_2x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x1 > { typedef dimension<2> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 2> matrix_short_2x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x2,0> matrix_short_2x2_row0; } template <> struct geometric_traits<detail::matrix_short_2x2_row0> { typedef detail::matrix_short_2x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x2,1> matrix_short_2x2_row1; } template <> struct geometric_traits<detail::matrix_short_2x2_row1> { typedef detail::matrix_short_2x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x2,0> matrix_short_2x2_column0; }template <> struct geometric_traits<detail::matrix_short_2x2_column0> { typedef detail::matrix_short_2x2_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x2,1> matrix_short_2x2_column1; }template <> struct geometric_traits<detail::matrix_short_2x2_column1> { typedef detail::matrix_short_2x2_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x2>::type > : index_operator_matrix_access_policy < matrix_short_2x2 > { typedef index_operator_matrix_access_policy < matrix_short_2x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x2 > { typedef dimension<2> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 3> matrix_short_2x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x3,0> matrix_short_2x3_row0; } template <> struct geometric_traits<detail::matrix_short_2x3_row0> { typedef detail::matrix_short_2x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x3,1> matrix_short_2x3_row1; } template <> struct geometric_traits<detail::matrix_short_2x3_row1> { typedef detail::matrix_short_2x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x3,0> matrix_short_2x3_column0; }template <> struct geometric_traits<detail::matrix_short_2x3_column0> { typedef detail::matrix_short_2x3_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x3,1> matrix_short_2x3_column1; }template <> struct geometric_traits<detail::matrix_short_2x3_column1> { typedef detail::matrix_short_2x3_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x3,2> matrix_short_2x3_column2; }template <> struct geometric_traits<detail::matrix_short_2x3_column2> { typedef detail::matrix_short_2x3_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x3>::type > : index_operator_matrix_access_policy < matrix_short_2x3 > { typedef index_operator_matrix_access_policy < matrix_short_2x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x3 > { typedef dimension<2> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 4> matrix_short_2x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x4,0> matrix_short_2x4_row0; } template <> struct geometric_traits<detail::matrix_short_2x4_row0> { typedef detail::matrix_short_2x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x4,1> matrix_short_2x4_row1; } template <> struct geometric_traits<detail::matrix_short_2x4_row1> { typedef detail::matrix_short_2x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x4,0> matrix_short_2x4_column0; }template <> struct geometric_traits<detail::matrix_short_2x4_column0> { typedef detail::matrix_short_2x4_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x4,1> matrix_short_2x4_column1; }template <> struct geometric_traits<detail::matrix_short_2x4_column1> { typedef detail::matrix_short_2x4_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x4,2> matrix_short_2x4_column2; }template <> struct geometric_traits<detail::matrix_short_2x4_column2> { typedef detail::matrix_short_2x4_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x4,3> matrix_short_2x4_column3; }template <> struct geometric_traits<detail::matrix_short_2x4_column3> { typedef detail::matrix_short_2x4_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x4>::type > : index_operator_matrix_access_policy < matrix_short_2x4 > { typedef index_operator_matrix_access_policy < matrix_short_2x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x4 > { typedef dimension<2> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 5> matrix_short_2x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x5,0> matrix_short_2x5_row0; } template <> struct geometric_traits<detail::matrix_short_2x5_row0> { typedef detail::matrix_short_2x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x5,1> matrix_short_2x5_row1; } template <> struct geometric_traits<detail::matrix_short_2x5_row1> { typedef detail::matrix_short_2x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x5,0> matrix_short_2x5_column0; }template <> struct geometric_traits<detail::matrix_short_2x5_column0> { typedef detail::matrix_short_2x5_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x5,1> matrix_short_2x5_column1; }template <> struct geometric_traits<detail::matrix_short_2x5_column1> { typedef detail::matrix_short_2x5_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x5,2> matrix_short_2x5_column2; }template <> struct geometric_traits<detail::matrix_short_2x5_column2> { typedef detail::matrix_short_2x5_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x5,3> matrix_short_2x5_column3; }template <> struct geometric_traits<detail::matrix_short_2x5_column3> { typedef detail::matrix_short_2x5_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x5,4> matrix_short_2x5_column4; }template <> struct geometric_traits<detail::matrix_short_2x5_column4> { typedef detail::matrix_short_2x5_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x5>::type > : index_operator_matrix_access_policy < matrix_short_2x5 > { typedef index_operator_matrix_access_policy < matrix_short_2x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x5 > { typedef dimension<2> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 6> matrix_short_2x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x6,0> matrix_short_2x6_row0; } template <> struct geometric_traits<detail::matrix_short_2x6_row0> { typedef detail::matrix_short_2x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x6,1> matrix_short_2x6_row1; } template <> struct geometric_traits<detail::matrix_short_2x6_row1> { typedef detail::matrix_short_2x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,0> matrix_short_2x6_column0; }template <> struct geometric_traits<detail::matrix_short_2x6_column0> { typedef detail::matrix_short_2x6_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,1> matrix_short_2x6_column1; }template <> struct geometric_traits<detail::matrix_short_2x6_column1> { typedef detail::matrix_short_2x6_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,2> matrix_short_2x6_column2; }template <> struct geometric_traits<detail::matrix_short_2x6_column2> { typedef detail::matrix_short_2x6_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,3> matrix_short_2x6_column3; }template <> struct geometric_traits<detail::matrix_short_2x6_column3> { typedef detail::matrix_short_2x6_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,4> matrix_short_2x6_column4; }template <> struct geometric_traits<detail::matrix_short_2x6_column4> { typedef detail::matrix_short_2x6_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x6,5> matrix_short_2x6_column5; }template <> struct geometric_traits<detail::matrix_short_2x6_column5> { typedef detail::matrix_short_2x6_column5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x6>::type > : index_operator_matrix_access_policy < matrix_short_2x6 > { typedef index_operator_matrix_access_policy < matrix_short_2x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x6 > { typedef dimension<2> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 7> matrix_short_2x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x7,0> matrix_short_2x7_row0; } template <> struct geometric_traits<detail::matrix_short_2x7_row0> { typedef detail::matrix_short_2x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x7,1> matrix_short_2x7_row1; } template <> struct geometric_traits<detail::matrix_short_2x7_row1> { typedef detail::matrix_short_2x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,0> matrix_short_2x7_column0; }template <> struct geometric_traits<detail::matrix_short_2x7_column0> { typedef detail::matrix_short_2x7_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,1> matrix_short_2x7_column1; }template <> struct geometric_traits<detail::matrix_short_2x7_column1> { typedef detail::matrix_short_2x7_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,2> matrix_short_2x7_column2; }template <> struct geometric_traits<detail::matrix_short_2x7_column2> { typedef detail::matrix_short_2x7_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,3> matrix_short_2x7_column3; }template <> struct geometric_traits<detail::matrix_short_2x7_column3> { typedef detail::matrix_short_2x7_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,4> matrix_short_2x7_column4; }template <> struct geometric_traits<detail::matrix_short_2x7_column4> { typedef detail::matrix_short_2x7_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,5> matrix_short_2x7_column5; }template <> struct geometric_traits<detail::matrix_short_2x7_column5> { typedef detail::matrix_short_2x7_column5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x7,6> matrix_short_2x7_column6; }template <> struct geometric_traits<detail::matrix_short_2x7_column6> { typedef detail::matrix_short_2x7_column6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x7>::type > : index_operator_matrix_access_policy < matrix_short_2x7 > { typedef index_operator_matrix_access_policy < matrix_short_2x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x7 > { typedef dimension<2> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 8> matrix_short_2x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x8,0> matrix_short_2x8_row0; } template <> struct geometric_traits<detail::matrix_short_2x8_row0> { typedef detail::matrix_short_2x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x8,1> matrix_short_2x8_row1; } template <> struct geometric_traits<detail::matrix_short_2x8_row1> { typedef detail::matrix_short_2x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,0> matrix_short_2x8_column0; }template <> struct geometric_traits<detail::matrix_short_2x8_column0> { typedef detail::matrix_short_2x8_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,1> matrix_short_2x8_column1; }template <> struct geometric_traits<detail::matrix_short_2x8_column1> { typedef detail::matrix_short_2x8_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,2> matrix_short_2x8_column2; }template <> struct geometric_traits<detail::matrix_short_2x8_column2> { typedef detail::matrix_short_2x8_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,3> matrix_short_2x8_column3; }template <> struct geometric_traits<detail::matrix_short_2x8_column3> { typedef detail::matrix_short_2x8_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,4> matrix_short_2x8_column4; }template <> struct geometric_traits<detail::matrix_short_2x8_column4> { typedef detail::matrix_short_2x8_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,5> matrix_short_2x8_column5; }template <> struct geometric_traits<detail::matrix_short_2x8_column5> { typedef detail::matrix_short_2x8_column5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,6> matrix_short_2x8_column6; }template <> struct geometric_traits<detail::matrix_short_2x8_column6> { typedef detail::matrix_short_2x8_column6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x8,7> matrix_short_2x8_column7; }template <> struct geometric_traits<detail::matrix_short_2x8_column7> { typedef detail::matrix_short_2x8_column7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x8>::type > : index_operator_matrix_access_policy < matrix_short_2x8 > { typedef index_operator_matrix_access_policy < matrix_short_2x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x8 > { typedef dimension<2> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 9> matrix_short_2x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x9,0> matrix_short_2x9_row0; } template <> struct geometric_traits<detail::matrix_short_2x9_row0> { typedef detail::matrix_short_2x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x9,1> matrix_short_2x9_row1; } template <> struct geometric_traits<detail::matrix_short_2x9_row1> { typedef detail::matrix_short_2x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,0> matrix_short_2x9_column0; }template <> struct geometric_traits<detail::matrix_short_2x9_column0> { typedef detail::matrix_short_2x9_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,1> matrix_short_2x9_column1; }template <> struct geometric_traits<detail::matrix_short_2x9_column1> { typedef detail::matrix_short_2x9_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,2> matrix_short_2x9_column2; }template <> struct geometric_traits<detail::matrix_short_2x9_column2> { typedef detail::matrix_short_2x9_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,3> matrix_short_2x9_column3; }template <> struct geometric_traits<detail::matrix_short_2x9_column3> { typedef detail::matrix_short_2x9_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,4> matrix_short_2x9_column4; }template <> struct geometric_traits<detail::matrix_short_2x9_column4> { typedef detail::matrix_short_2x9_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,5> matrix_short_2x9_column5; }template <> struct geometric_traits<detail::matrix_short_2x9_column5> { typedef detail::matrix_short_2x9_column5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,6> matrix_short_2x9_column6; }template <> struct geometric_traits<detail::matrix_short_2x9_column6> { typedef detail::matrix_short_2x9_column6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,7> matrix_short_2x9_column7; }template <> struct geometric_traits<detail::matrix_short_2x9_column7> { typedef detail::matrix_short_2x9_column7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x9,8> matrix_short_2x9_column8; }template <> struct geometric_traits<detail::matrix_short_2x9_column8> { typedef detail::matrix_short_2x9_column8 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x9>::type > : index_operator_matrix_access_policy < matrix_short_2x9 > { typedef index_operator_matrix_access_policy < matrix_short_2x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x9 > { typedef dimension<2> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 2, 10> matrix_short_2x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x10,0> matrix_short_2x10_row0; } template <> struct geometric_traits<detail::matrix_short_2x10_row0> { typedef detail::matrix_short_2x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_2x10,1> matrix_short_2x10_row1; } template <> struct geometric_traits<detail::matrix_short_2x10_row1> { typedef detail::matrix_short_2x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,0> matrix_short_2x10_column0; }template <> struct geometric_traits<detail::matrix_short_2x10_column0> { typedef detail::matrix_short_2x10_column0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,1> matrix_short_2x10_column1; }template <> struct geometric_traits<detail::matrix_short_2x10_column1> { typedef detail::matrix_short_2x10_column1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,2> matrix_short_2x10_column2; }template <> struct geometric_traits<detail::matrix_short_2x10_column2> { typedef detail::matrix_short_2x10_column2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,3> matrix_short_2x10_column3; }template <> struct geometric_traits<detail::matrix_short_2x10_column3> { typedef detail::matrix_short_2x10_column3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,4> matrix_short_2x10_column4; }template <> struct geometric_traits<detail::matrix_short_2x10_column4> { typedef detail::matrix_short_2x10_column4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,5> matrix_short_2x10_column5; }template <> struct geometric_traits<detail::matrix_short_2x10_column5> { typedef detail::matrix_short_2x10_column5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,6> matrix_short_2x10_column6; }template <> struct geometric_traits<detail::matrix_short_2x10_column6> { typedef detail::matrix_short_2x10_column6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,7> matrix_short_2x10_column7; }template <> struct geometric_traits<detail::matrix_short_2x10_column7> { typedef detail::matrix_short_2x10_column7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,8> matrix_short_2x10_column8; }template <> struct geometric_traits<detail::matrix_short_2x10_column8> { typedef detail::matrix_short_2x10_column8 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_2x10,9> matrix_short_2x10_column9; }template <> struct geometric_traits<detail::matrix_short_2x10_column9> { typedef detail::matrix_short_2x10_column9 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_2x10>::type > : index_operator_matrix_access_policy < matrix_short_2x10 > { typedef index_operator_matrix_access_policy < matrix_short_2x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_2x10 > { typedef dimension<2> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 1> matrix_short_3x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x1,0> matrix_short_3x1_row0; } template <> struct geometric_traits<detail::matrix_short_3x1_row0> { typedef detail::matrix_short_3x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x1,1> matrix_short_3x1_row1; } template <> struct geometric_traits<detail::matrix_short_3x1_row1> { typedef detail::matrix_short_3x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x1,2> matrix_short_3x1_row2; } template <> struct geometric_traits<detail::matrix_short_3x1_row2> { typedef detail::matrix_short_3x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x1,0> matrix_short_3x1_column0; }template <> struct geometric_traits<detail::matrix_short_3x1_column0> { typedef detail::matrix_short_3x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x1>::type > : index_operator_matrix_access_policy < matrix_short_3x1 > { typedef index_operator_matrix_access_policy < matrix_short_3x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x1 > { typedef dimension<3> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 2> matrix_short_3x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x2,0> matrix_short_3x2_row0; } template <> struct geometric_traits<detail::matrix_short_3x2_row0> { typedef detail::matrix_short_3x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x2,1> matrix_short_3x2_row1; } template <> struct geometric_traits<detail::matrix_short_3x2_row1> { typedef detail::matrix_short_3x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x2,2> matrix_short_3x2_row2; } template <> struct geometric_traits<detail::matrix_short_3x2_row2> { typedef detail::matrix_short_3x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x2,0> matrix_short_3x2_column0; }template <> struct geometric_traits<detail::matrix_short_3x2_column0> { typedef detail::matrix_short_3x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x2,1> matrix_short_3x2_column1; }template <> struct geometric_traits<detail::matrix_short_3x2_column1> { typedef detail::matrix_short_3x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x2>::type > : index_operator_matrix_access_policy < matrix_short_3x2 > { typedef index_operator_matrix_access_policy < matrix_short_3x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x2 > { typedef dimension<3> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 3> matrix_short_3x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x3,0> matrix_short_3x3_row0; } template <> struct geometric_traits<detail::matrix_short_3x3_row0> { typedef detail::matrix_short_3x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x3,1> matrix_short_3x3_row1; } template <> struct geometric_traits<detail::matrix_short_3x3_row1> { typedef detail::matrix_short_3x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x3,2> matrix_short_3x3_row2; } template <> struct geometric_traits<detail::matrix_short_3x3_row2> { typedef detail::matrix_short_3x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x3,0> matrix_short_3x3_column0; }template <> struct geometric_traits<detail::matrix_short_3x3_column0> { typedef detail::matrix_short_3x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x3,1> matrix_short_3x3_column1; }template <> struct geometric_traits<detail::matrix_short_3x3_column1> { typedef detail::matrix_short_3x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x3,2> matrix_short_3x3_column2; }template <> struct geometric_traits<detail::matrix_short_3x3_column2> { typedef detail::matrix_short_3x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x3>::type > : index_operator_matrix_access_policy < matrix_short_3x3 > { typedef index_operator_matrix_access_policy < matrix_short_3x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x3 > { typedef dimension<3> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 4> matrix_short_3x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x4,0> matrix_short_3x4_row0; } template <> struct geometric_traits<detail::matrix_short_3x4_row0> { typedef detail::matrix_short_3x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x4,1> matrix_short_3x4_row1; } template <> struct geometric_traits<detail::matrix_short_3x4_row1> { typedef detail::matrix_short_3x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x4,2> matrix_short_3x4_row2; } template <> struct geometric_traits<detail::matrix_short_3x4_row2> { typedef detail::matrix_short_3x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x4,0> matrix_short_3x4_column0; }template <> struct geometric_traits<detail::matrix_short_3x4_column0> { typedef detail::matrix_short_3x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x4,1> matrix_short_3x4_column1; }template <> struct geometric_traits<detail::matrix_short_3x4_column1> { typedef detail::matrix_short_3x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x4,2> matrix_short_3x4_column2; }template <> struct geometric_traits<detail::matrix_short_3x4_column2> { typedef detail::matrix_short_3x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x4,3> matrix_short_3x4_column3; }template <> struct geometric_traits<detail::matrix_short_3x4_column3> { typedef detail::matrix_short_3x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x4>::type > : index_operator_matrix_access_policy < matrix_short_3x4 > { typedef index_operator_matrix_access_policy < matrix_short_3x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x4 > { typedef dimension<3> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 5> matrix_short_3x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x5,0> matrix_short_3x5_row0; } template <> struct geometric_traits<detail::matrix_short_3x5_row0> { typedef detail::matrix_short_3x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x5,1> matrix_short_3x5_row1; } template <> struct geometric_traits<detail::matrix_short_3x5_row1> { typedef detail::matrix_short_3x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x5,2> matrix_short_3x5_row2; } template <> struct geometric_traits<detail::matrix_short_3x5_row2> { typedef detail::matrix_short_3x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x5,0> matrix_short_3x5_column0; }template <> struct geometric_traits<detail::matrix_short_3x5_column0> { typedef detail::matrix_short_3x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x5,1> matrix_short_3x5_column1; }template <> struct geometric_traits<detail::matrix_short_3x5_column1> { typedef detail::matrix_short_3x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x5,2> matrix_short_3x5_column2; }template <> struct geometric_traits<detail::matrix_short_3x5_column2> { typedef detail::matrix_short_3x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x5,3> matrix_short_3x5_column3; }template <> struct geometric_traits<detail::matrix_short_3x5_column3> { typedef detail::matrix_short_3x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x5,4> matrix_short_3x5_column4; }template <> struct geometric_traits<detail::matrix_short_3x5_column4> { typedef detail::matrix_short_3x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x5>::type > : index_operator_matrix_access_policy < matrix_short_3x5 > { typedef index_operator_matrix_access_policy < matrix_short_3x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x5 > { typedef dimension<3> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 6> matrix_short_3x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x6,0> matrix_short_3x6_row0; } template <> struct geometric_traits<detail::matrix_short_3x6_row0> { typedef detail::matrix_short_3x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x6,1> matrix_short_3x6_row1; } template <> struct geometric_traits<detail::matrix_short_3x6_row1> { typedef detail::matrix_short_3x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x6,2> matrix_short_3x6_row2; } template <> struct geometric_traits<detail::matrix_short_3x6_row2> { typedef detail::matrix_short_3x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,0> matrix_short_3x6_column0; }template <> struct geometric_traits<detail::matrix_short_3x6_column0> { typedef detail::matrix_short_3x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,1> matrix_short_3x6_column1; }template <> struct geometric_traits<detail::matrix_short_3x6_column1> { typedef detail::matrix_short_3x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,2> matrix_short_3x6_column2; }template <> struct geometric_traits<detail::matrix_short_3x6_column2> { typedef detail::matrix_short_3x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,3> matrix_short_3x6_column3; }template <> struct geometric_traits<detail::matrix_short_3x6_column3> { typedef detail::matrix_short_3x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,4> matrix_short_3x6_column4; }template <> struct geometric_traits<detail::matrix_short_3x6_column4> { typedef detail::matrix_short_3x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x6,5> matrix_short_3x6_column5; }template <> struct geometric_traits<detail::matrix_short_3x6_column5> { typedef detail::matrix_short_3x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x6>::type > : index_operator_matrix_access_policy < matrix_short_3x6 > { typedef index_operator_matrix_access_policy < matrix_short_3x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x6 > { typedef dimension<3> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 7> matrix_short_3x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x7,0> matrix_short_3x7_row0; } template <> struct geometric_traits<detail::matrix_short_3x7_row0> { typedef detail::matrix_short_3x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x7,1> matrix_short_3x7_row1; } template <> struct geometric_traits<detail::matrix_short_3x7_row1> { typedef detail::matrix_short_3x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x7,2> matrix_short_3x7_row2; } template <> struct geometric_traits<detail::matrix_short_3x7_row2> { typedef detail::matrix_short_3x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,0> matrix_short_3x7_column0; }template <> struct geometric_traits<detail::matrix_short_3x7_column0> { typedef detail::matrix_short_3x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,1> matrix_short_3x7_column1; }template <> struct geometric_traits<detail::matrix_short_3x7_column1> { typedef detail::matrix_short_3x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,2> matrix_short_3x7_column2; }template <> struct geometric_traits<detail::matrix_short_3x7_column2> { typedef detail::matrix_short_3x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,3> matrix_short_3x7_column3; }template <> struct geometric_traits<detail::matrix_short_3x7_column3> { typedef detail::matrix_short_3x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,4> matrix_short_3x7_column4; }template <> struct geometric_traits<detail::matrix_short_3x7_column4> { typedef detail::matrix_short_3x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,5> matrix_short_3x7_column5; }template <> struct geometric_traits<detail::matrix_short_3x7_column5> { typedef detail::matrix_short_3x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x7,6> matrix_short_3x7_column6; }template <> struct geometric_traits<detail::matrix_short_3x7_column6> { typedef detail::matrix_short_3x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x7>::type > : index_operator_matrix_access_policy < matrix_short_3x7 > { typedef index_operator_matrix_access_policy < matrix_short_3x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x7 > { typedef dimension<3> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 8> matrix_short_3x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x8,0> matrix_short_3x8_row0; } template <> struct geometric_traits<detail::matrix_short_3x8_row0> { typedef detail::matrix_short_3x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x8,1> matrix_short_3x8_row1; } template <> struct geometric_traits<detail::matrix_short_3x8_row1> { typedef detail::matrix_short_3x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x8,2> matrix_short_3x8_row2; } template <> struct geometric_traits<detail::matrix_short_3x8_row2> { typedef detail::matrix_short_3x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,0> matrix_short_3x8_column0; }template <> struct geometric_traits<detail::matrix_short_3x8_column0> { typedef detail::matrix_short_3x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,1> matrix_short_3x8_column1; }template <> struct geometric_traits<detail::matrix_short_3x8_column1> { typedef detail::matrix_short_3x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,2> matrix_short_3x8_column2; }template <> struct geometric_traits<detail::matrix_short_3x8_column2> { typedef detail::matrix_short_3x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,3> matrix_short_3x8_column3; }template <> struct geometric_traits<detail::matrix_short_3x8_column3> { typedef detail::matrix_short_3x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,4> matrix_short_3x8_column4; }template <> struct geometric_traits<detail::matrix_short_3x8_column4> { typedef detail::matrix_short_3x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,5> matrix_short_3x8_column5; }template <> struct geometric_traits<detail::matrix_short_3x8_column5> { typedef detail::matrix_short_3x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,6> matrix_short_3x8_column6; }template <> struct geometric_traits<detail::matrix_short_3x8_column6> { typedef detail::matrix_short_3x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x8,7> matrix_short_3x8_column7; }template <> struct geometric_traits<detail::matrix_short_3x8_column7> { typedef detail::matrix_short_3x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x8>::type > : index_operator_matrix_access_policy < matrix_short_3x8 > { typedef index_operator_matrix_access_policy < matrix_short_3x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x8 > { typedef dimension<3> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 9> matrix_short_3x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x9,0> matrix_short_3x9_row0; } template <> struct geometric_traits<detail::matrix_short_3x9_row0> { typedef detail::matrix_short_3x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x9,1> matrix_short_3x9_row1; } template <> struct geometric_traits<detail::matrix_short_3x9_row1> { typedef detail::matrix_short_3x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x9,2> matrix_short_3x9_row2; } template <> struct geometric_traits<detail::matrix_short_3x9_row2> { typedef detail::matrix_short_3x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,0> matrix_short_3x9_column0; }template <> struct geometric_traits<detail::matrix_short_3x9_column0> { typedef detail::matrix_short_3x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,1> matrix_short_3x9_column1; }template <> struct geometric_traits<detail::matrix_short_3x9_column1> { typedef detail::matrix_short_3x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,2> matrix_short_3x9_column2; }template <> struct geometric_traits<detail::matrix_short_3x9_column2> { typedef detail::matrix_short_3x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,3> matrix_short_3x9_column3; }template <> struct geometric_traits<detail::matrix_short_3x9_column3> { typedef detail::matrix_short_3x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,4> matrix_short_3x9_column4; }template <> struct geometric_traits<detail::matrix_short_3x9_column4> { typedef detail::matrix_short_3x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,5> matrix_short_3x9_column5; }template <> struct geometric_traits<detail::matrix_short_3x9_column5> { typedef detail::matrix_short_3x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,6> matrix_short_3x9_column6; }template <> struct geometric_traits<detail::matrix_short_3x9_column6> { typedef detail::matrix_short_3x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,7> matrix_short_3x9_column7; }template <> struct geometric_traits<detail::matrix_short_3x9_column7> { typedef detail::matrix_short_3x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x9,8> matrix_short_3x9_column8; }template <> struct geometric_traits<detail::matrix_short_3x9_column8> { typedef detail::matrix_short_3x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x9>::type > : index_operator_matrix_access_policy < matrix_short_3x9 > { typedef index_operator_matrix_access_policy < matrix_short_3x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x9 > { typedef dimension<3> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 3, 10> matrix_short_3x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x10,0> matrix_short_3x10_row0; } template <> struct geometric_traits<detail::matrix_short_3x10_row0> { typedef detail::matrix_short_3x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x10,1> matrix_short_3x10_row1; } template <> struct geometric_traits<detail::matrix_short_3x10_row1> { typedef detail::matrix_short_3x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_3x10,2> matrix_short_3x10_row2; } template <> struct geometric_traits<detail::matrix_short_3x10_row2> { typedef detail::matrix_short_3x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,0> matrix_short_3x10_column0; }template <> struct geometric_traits<detail::matrix_short_3x10_column0> { typedef detail::matrix_short_3x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,1> matrix_short_3x10_column1; }template <> struct geometric_traits<detail::matrix_short_3x10_column1> { typedef detail::matrix_short_3x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,2> matrix_short_3x10_column2; }template <> struct geometric_traits<detail::matrix_short_3x10_column2> { typedef detail::matrix_short_3x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,3> matrix_short_3x10_column3; }template <> struct geometric_traits<detail::matrix_short_3x10_column3> { typedef detail::matrix_short_3x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,4> matrix_short_3x10_column4; }template <> struct geometric_traits<detail::matrix_short_3x10_column4> { typedef detail::matrix_short_3x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,5> matrix_short_3x10_column5; }template <> struct geometric_traits<detail::matrix_short_3x10_column5> { typedef detail::matrix_short_3x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,6> matrix_short_3x10_column6; }template <> struct geometric_traits<detail::matrix_short_3x10_column6> { typedef detail::matrix_short_3x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,7> matrix_short_3x10_column7; }template <> struct geometric_traits<detail::matrix_short_3x10_column7> { typedef detail::matrix_short_3x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,8> matrix_short_3x10_column8; }template <> struct geometric_traits<detail::matrix_short_3x10_column8> { typedef detail::matrix_short_3x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_3x10,9> matrix_short_3x10_column9; }template <> struct geometric_traits<detail::matrix_short_3x10_column9> { typedef detail::matrix_short_3x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_3x10>::type > : index_operator_matrix_access_policy < matrix_short_3x10 > { typedef index_operator_matrix_access_policy < matrix_short_3x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_3x10 > { typedef dimension<3> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 1> matrix_short_4x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x1,0> matrix_short_4x1_row0; } template <> struct geometric_traits<detail::matrix_short_4x1_row0> { typedef detail::matrix_short_4x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x1,1> matrix_short_4x1_row1; } template <> struct geometric_traits<detail::matrix_short_4x1_row1> { typedef detail::matrix_short_4x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x1,2> matrix_short_4x1_row2; } template <> struct geometric_traits<detail::matrix_short_4x1_row2> { typedef detail::matrix_short_4x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x1,3> matrix_short_4x1_row3; } template <> struct geometric_traits<detail::matrix_short_4x1_row3> { typedef detail::matrix_short_4x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x1,0> matrix_short_4x1_column0; }template <> struct geometric_traits<detail::matrix_short_4x1_column0> { typedef detail::matrix_short_4x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x1>::type > : index_operator_matrix_access_policy < matrix_short_4x1 > { typedef index_operator_matrix_access_policy < matrix_short_4x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x1 > { typedef dimension<4> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 2> matrix_short_4x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x2,0> matrix_short_4x2_row0; } template <> struct geometric_traits<detail::matrix_short_4x2_row0> { typedef detail::matrix_short_4x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x2,1> matrix_short_4x2_row1; } template <> struct geometric_traits<detail::matrix_short_4x2_row1> { typedef detail::matrix_short_4x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x2,2> matrix_short_4x2_row2; } template <> struct geometric_traits<detail::matrix_short_4x2_row2> { typedef detail::matrix_short_4x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x2,3> matrix_short_4x2_row3; } template <> struct geometric_traits<detail::matrix_short_4x2_row3> { typedef detail::matrix_short_4x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x2,0> matrix_short_4x2_column0; }template <> struct geometric_traits<detail::matrix_short_4x2_column0> { typedef detail::matrix_short_4x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x2,1> matrix_short_4x2_column1; }template <> struct geometric_traits<detail::matrix_short_4x2_column1> { typedef detail::matrix_short_4x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x2>::type > : index_operator_matrix_access_policy < matrix_short_4x2 > { typedef index_operator_matrix_access_policy < matrix_short_4x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x2 > { typedef dimension<4> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 3> matrix_short_4x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x3,0> matrix_short_4x3_row0; } template <> struct geometric_traits<detail::matrix_short_4x3_row0> { typedef detail::matrix_short_4x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x3,1> matrix_short_4x3_row1; } template <> struct geometric_traits<detail::matrix_short_4x3_row1> { typedef detail::matrix_short_4x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x3,2> matrix_short_4x3_row2; } template <> struct geometric_traits<detail::matrix_short_4x3_row2> { typedef detail::matrix_short_4x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x3,3> matrix_short_4x3_row3; } template <> struct geometric_traits<detail::matrix_short_4x3_row3> { typedef detail::matrix_short_4x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x3,0> matrix_short_4x3_column0; }template <> struct geometric_traits<detail::matrix_short_4x3_column0> { typedef detail::matrix_short_4x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x3,1> matrix_short_4x3_column1; }template <> struct geometric_traits<detail::matrix_short_4x3_column1> { typedef detail::matrix_short_4x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x3,2> matrix_short_4x3_column2; }template <> struct geometric_traits<detail::matrix_short_4x3_column2> { typedef detail::matrix_short_4x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x3>::type > : index_operator_matrix_access_policy < matrix_short_4x3 > { typedef index_operator_matrix_access_policy < matrix_short_4x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x3 > { typedef dimension<4> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 4> matrix_short_4x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x4,0> matrix_short_4x4_row0; } template <> struct geometric_traits<detail::matrix_short_4x4_row0> { typedef detail::matrix_short_4x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x4,1> matrix_short_4x4_row1; } template <> struct geometric_traits<detail::matrix_short_4x4_row1> { typedef detail::matrix_short_4x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x4,2> matrix_short_4x4_row2; } template <> struct geometric_traits<detail::matrix_short_4x4_row2> { typedef detail::matrix_short_4x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x4,3> matrix_short_4x4_row3; } template <> struct geometric_traits<detail::matrix_short_4x4_row3> { typedef detail::matrix_short_4x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x4,0> matrix_short_4x4_column0; }template <> struct geometric_traits<detail::matrix_short_4x4_column0> { typedef detail::matrix_short_4x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x4,1> matrix_short_4x4_column1; }template <> struct geometric_traits<detail::matrix_short_4x4_column1> { typedef detail::matrix_short_4x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x4,2> matrix_short_4x4_column2; }template <> struct geometric_traits<detail::matrix_short_4x4_column2> { typedef detail::matrix_short_4x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x4,3> matrix_short_4x4_column3; }template <> struct geometric_traits<detail::matrix_short_4x4_column3> { typedef detail::matrix_short_4x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x4>::type > : index_operator_matrix_access_policy < matrix_short_4x4 > { typedef index_operator_matrix_access_policy < matrix_short_4x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x4 > { typedef dimension<4> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 5> matrix_short_4x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x5,0> matrix_short_4x5_row0; } template <> struct geometric_traits<detail::matrix_short_4x5_row0> { typedef detail::matrix_short_4x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x5,1> matrix_short_4x5_row1; } template <> struct geometric_traits<detail::matrix_short_4x5_row1> { typedef detail::matrix_short_4x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x5,2> matrix_short_4x5_row2; } template <> struct geometric_traits<detail::matrix_short_4x5_row2> { typedef detail::matrix_short_4x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x5,3> matrix_short_4x5_row3; } template <> struct geometric_traits<detail::matrix_short_4x5_row3> { typedef detail::matrix_short_4x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x5,0> matrix_short_4x5_column0; }template <> struct geometric_traits<detail::matrix_short_4x5_column0> { typedef detail::matrix_short_4x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x5,1> matrix_short_4x5_column1; }template <> struct geometric_traits<detail::matrix_short_4x5_column1> { typedef detail::matrix_short_4x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x5,2> matrix_short_4x5_column2; }template <> struct geometric_traits<detail::matrix_short_4x5_column2> { typedef detail::matrix_short_4x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x5,3> matrix_short_4x5_column3; }template <> struct geometric_traits<detail::matrix_short_4x5_column3> { typedef detail::matrix_short_4x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x5,4> matrix_short_4x5_column4; }template <> struct geometric_traits<detail::matrix_short_4x5_column4> { typedef detail::matrix_short_4x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x5>::type > : index_operator_matrix_access_policy < matrix_short_4x5 > { typedef index_operator_matrix_access_policy < matrix_short_4x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x5 > { typedef dimension<4> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 6> matrix_short_4x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x6,0> matrix_short_4x6_row0; } template <> struct geometric_traits<detail::matrix_short_4x6_row0> { typedef detail::matrix_short_4x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x6,1> matrix_short_4x6_row1; } template <> struct geometric_traits<detail::matrix_short_4x6_row1> { typedef detail::matrix_short_4x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x6,2> matrix_short_4x6_row2; } template <> struct geometric_traits<detail::matrix_short_4x6_row2> { typedef detail::matrix_short_4x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x6,3> matrix_short_4x6_row3; } template <> struct geometric_traits<detail::matrix_short_4x6_row3> { typedef detail::matrix_short_4x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,0> matrix_short_4x6_column0; }template <> struct geometric_traits<detail::matrix_short_4x6_column0> { typedef detail::matrix_short_4x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,1> matrix_short_4x6_column1; }template <> struct geometric_traits<detail::matrix_short_4x6_column1> { typedef detail::matrix_short_4x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,2> matrix_short_4x6_column2; }template <> struct geometric_traits<detail::matrix_short_4x6_column2> { typedef detail::matrix_short_4x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,3> matrix_short_4x6_column3; }template <> struct geometric_traits<detail::matrix_short_4x6_column3> { typedef detail::matrix_short_4x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,4> matrix_short_4x6_column4; }template <> struct geometric_traits<detail::matrix_short_4x6_column4> { typedef detail::matrix_short_4x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x6,5> matrix_short_4x6_column5; }template <> struct geometric_traits<detail::matrix_short_4x6_column5> { typedef detail::matrix_short_4x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x6>::type > : index_operator_matrix_access_policy < matrix_short_4x6 > { typedef index_operator_matrix_access_policy < matrix_short_4x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x6 > { typedef dimension<4> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 7> matrix_short_4x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x7,0> matrix_short_4x7_row0; } template <> struct geometric_traits<detail::matrix_short_4x7_row0> { typedef detail::matrix_short_4x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x7,1> matrix_short_4x7_row1; } template <> struct geometric_traits<detail::matrix_short_4x7_row1> { typedef detail::matrix_short_4x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x7,2> matrix_short_4x7_row2; } template <> struct geometric_traits<detail::matrix_short_4x7_row2> { typedef detail::matrix_short_4x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x7,3> matrix_short_4x7_row3; } template <> struct geometric_traits<detail::matrix_short_4x7_row3> { typedef detail::matrix_short_4x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,0> matrix_short_4x7_column0; }template <> struct geometric_traits<detail::matrix_short_4x7_column0> { typedef detail::matrix_short_4x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,1> matrix_short_4x7_column1; }template <> struct geometric_traits<detail::matrix_short_4x7_column1> { typedef detail::matrix_short_4x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,2> matrix_short_4x7_column2; }template <> struct geometric_traits<detail::matrix_short_4x7_column2> { typedef detail::matrix_short_4x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,3> matrix_short_4x7_column3; }template <> struct geometric_traits<detail::matrix_short_4x7_column3> { typedef detail::matrix_short_4x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,4> matrix_short_4x7_column4; }template <> struct geometric_traits<detail::matrix_short_4x7_column4> { typedef detail::matrix_short_4x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,5> matrix_short_4x7_column5; }template <> struct geometric_traits<detail::matrix_short_4x7_column5> { typedef detail::matrix_short_4x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x7,6> matrix_short_4x7_column6; }template <> struct geometric_traits<detail::matrix_short_4x7_column6> { typedef detail::matrix_short_4x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x7>::type > : index_operator_matrix_access_policy < matrix_short_4x7 > { typedef index_operator_matrix_access_policy < matrix_short_4x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x7 > { typedef dimension<4> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 8> matrix_short_4x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x8,0> matrix_short_4x8_row0; } template <> struct geometric_traits<detail::matrix_short_4x8_row0> { typedef detail::matrix_short_4x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x8,1> matrix_short_4x8_row1; } template <> struct geometric_traits<detail::matrix_short_4x8_row1> { typedef detail::matrix_short_4x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x8,2> matrix_short_4x8_row2; } template <> struct geometric_traits<detail::matrix_short_4x8_row2> { typedef detail::matrix_short_4x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x8,3> matrix_short_4x8_row3; } template <> struct geometric_traits<detail::matrix_short_4x8_row3> { typedef detail::matrix_short_4x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,0> matrix_short_4x8_column0; }template <> struct geometric_traits<detail::matrix_short_4x8_column0> { typedef detail::matrix_short_4x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,1> matrix_short_4x8_column1; }template <> struct geometric_traits<detail::matrix_short_4x8_column1> { typedef detail::matrix_short_4x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,2> matrix_short_4x8_column2; }template <> struct geometric_traits<detail::matrix_short_4x8_column2> { typedef detail::matrix_short_4x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,3> matrix_short_4x8_column3; }template <> struct geometric_traits<detail::matrix_short_4x8_column3> { typedef detail::matrix_short_4x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,4> matrix_short_4x8_column4; }template <> struct geometric_traits<detail::matrix_short_4x8_column4> { typedef detail::matrix_short_4x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,5> matrix_short_4x8_column5; }template <> struct geometric_traits<detail::matrix_short_4x8_column5> { typedef detail::matrix_short_4x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,6> matrix_short_4x8_column6; }template <> struct geometric_traits<detail::matrix_short_4x8_column6> { typedef detail::matrix_short_4x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x8,7> matrix_short_4x8_column7; }template <> struct geometric_traits<detail::matrix_short_4x8_column7> { typedef detail::matrix_short_4x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x8>::type > : index_operator_matrix_access_policy < matrix_short_4x8 > { typedef index_operator_matrix_access_policy < matrix_short_4x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x8 > { typedef dimension<4> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 9> matrix_short_4x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x9,0> matrix_short_4x9_row0; } template <> struct geometric_traits<detail::matrix_short_4x9_row0> { typedef detail::matrix_short_4x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x9,1> matrix_short_4x9_row1; } template <> struct geometric_traits<detail::matrix_short_4x9_row1> { typedef detail::matrix_short_4x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x9,2> matrix_short_4x9_row2; } template <> struct geometric_traits<detail::matrix_short_4x9_row2> { typedef detail::matrix_short_4x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x9,3> matrix_short_4x9_row3; } template <> struct geometric_traits<detail::matrix_short_4x9_row3> { typedef detail::matrix_short_4x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,0> matrix_short_4x9_column0; }template <> struct geometric_traits<detail::matrix_short_4x9_column0> { typedef detail::matrix_short_4x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,1> matrix_short_4x9_column1; }template <> struct geometric_traits<detail::matrix_short_4x9_column1> { typedef detail::matrix_short_4x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,2> matrix_short_4x9_column2; }template <> struct geometric_traits<detail::matrix_short_4x9_column2> { typedef detail::matrix_short_4x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,3> matrix_short_4x9_column3; }template <> struct geometric_traits<detail::matrix_short_4x9_column3> { typedef detail::matrix_short_4x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,4> matrix_short_4x9_column4; }template <> struct geometric_traits<detail::matrix_short_4x9_column4> { typedef detail::matrix_short_4x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,5> matrix_short_4x9_column5; }template <> struct geometric_traits<detail::matrix_short_4x9_column5> { typedef detail::matrix_short_4x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,6> matrix_short_4x9_column6; }template <> struct geometric_traits<detail::matrix_short_4x9_column6> { typedef detail::matrix_short_4x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,7> matrix_short_4x9_column7; }template <> struct geometric_traits<detail::matrix_short_4x9_column7> { typedef detail::matrix_short_4x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x9,8> matrix_short_4x9_column8; }template <> struct geometric_traits<detail::matrix_short_4x9_column8> { typedef detail::matrix_short_4x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x9>::type > : index_operator_matrix_access_policy < matrix_short_4x9 > { typedef index_operator_matrix_access_policy < matrix_short_4x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x9 > { typedef dimension<4> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 4, 10> matrix_short_4x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x10,0> matrix_short_4x10_row0; } template <> struct geometric_traits<detail::matrix_short_4x10_row0> { typedef detail::matrix_short_4x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x10,1> matrix_short_4x10_row1; } template <> struct geometric_traits<detail::matrix_short_4x10_row1> { typedef detail::matrix_short_4x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x10,2> matrix_short_4x10_row2; } template <> struct geometric_traits<detail::matrix_short_4x10_row2> { typedef detail::matrix_short_4x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_4x10,3> matrix_short_4x10_row3; } template <> struct geometric_traits<detail::matrix_short_4x10_row3> { typedef detail::matrix_short_4x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,0> matrix_short_4x10_column0; }template <> struct geometric_traits<detail::matrix_short_4x10_column0> { typedef detail::matrix_short_4x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,1> matrix_short_4x10_column1; }template <> struct geometric_traits<detail::matrix_short_4x10_column1> { typedef detail::matrix_short_4x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,2> matrix_short_4x10_column2; }template <> struct geometric_traits<detail::matrix_short_4x10_column2> { typedef detail::matrix_short_4x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,3> matrix_short_4x10_column3; }template <> struct geometric_traits<detail::matrix_short_4x10_column3> { typedef detail::matrix_short_4x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,4> matrix_short_4x10_column4; }template <> struct geometric_traits<detail::matrix_short_4x10_column4> { typedef detail::matrix_short_4x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,5> matrix_short_4x10_column5; }template <> struct geometric_traits<detail::matrix_short_4x10_column5> { typedef detail::matrix_short_4x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,6> matrix_short_4x10_column6; }template <> struct geometric_traits<detail::matrix_short_4x10_column6> { typedef detail::matrix_short_4x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,7> matrix_short_4x10_column7; }template <> struct geometric_traits<detail::matrix_short_4x10_column7> { typedef detail::matrix_short_4x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,8> matrix_short_4x10_column8; }template <> struct geometric_traits<detail::matrix_short_4x10_column8> { typedef detail::matrix_short_4x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_4x10,9> matrix_short_4x10_column9; }template <> struct geometric_traits<detail::matrix_short_4x10_column9> { typedef detail::matrix_short_4x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_4x10>::type > : index_operator_matrix_access_policy < matrix_short_4x10 > { typedef index_operator_matrix_access_policy < matrix_short_4x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_4x10 > { typedef dimension<4> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 1> matrix_short_5x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x1,0> matrix_short_5x1_row0; } template <> struct geometric_traits<detail::matrix_short_5x1_row0> { typedef detail::matrix_short_5x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x1,1> matrix_short_5x1_row1; } template <> struct geometric_traits<detail::matrix_short_5x1_row1> { typedef detail::matrix_short_5x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x1,2> matrix_short_5x1_row2; } template <> struct geometric_traits<detail::matrix_short_5x1_row2> { typedef detail::matrix_short_5x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x1,3> matrix_short_5x1_row3; } template <> struct geometric_traits<detail::matrix_short_5x1_row3> { typedef detail::matrix_short_5x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x1,4> matrix_short_5x1_row4; } template <> struct geometric_traits<detail::matrix_short_5x1_row4> { typedef detail::matrix_short_5x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x1,0> matrix_short_5x1_column0; }template <> struct geometric_traits<detail::matrix_short_5x1_column0> { typedef detail::matrix_short_5x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x1>::type > : index_operator_matrix_access_policy < matrix_short_5x1 > { typedef index_operator_matrix_access_policy < matrix_short_5x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x1 > { typedef dimension<5> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 2> matrix_short_5x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x2,0> matrix_short_5x2_row0; } template <> struct geometric_traits<detail::matrix_short_5x2_row0> { typedef detail::matrix_short_5x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x2,1> matrix_short_5x2_row1; } template <> struct geometric_traits<detail::matrix_short_5x2_row1> { typedef detail::matrix_short_5x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x2,2> matrix_short_5x2_row2; } template <> struct geometric_traits<detail::matrix_short_5x2_row2> { typedef detail::matrix_short_5x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x2,3> matrix_short_5x2_row3; } template <> struct geometric_traits<detail::matrix_short_5x2_row3> { typedef detail::matrix_short_5x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x2,4> matrix_short_5x2_row4; } template <> struct geometric_traits<detail::matrix_short_5x2_row4> { typedef detail::matrix_short_5x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x2,0> matrix_short_5x2_column0; }template <> struct geometric_traits<detail::matrix_short_5x2_column0> { typedef detail::matrix_short_5x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x2,1> matrix_short_5x2_column1; }template <> struct geometric_traits<detail::matrix_short_5x2_column1> { typedef detail::matrix_short_5x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x2>::type > : index_operator_matrix_access_policy < matrix_short_5x2 > { typedef index_operator_matrix_access_policy < matrix_short_5x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x2 > { typedef dimension<5> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 3> matrix_short_5x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x3,0> matrix_short_5x3_row0; } template <> struct geometric_traits<detail::matrix_short_5x3_row0> { typedef detail::matrix_short_5x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x3,1> matrix_short_5x3_row1; } template <> struct geometric_traits<detail::matrix_short_5x3_row1> { typedef detail::matrix_short_5x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x3,2> matrix_short_5x3_row2; } template <> struct geometric_traits<detail::matrix_short_5x3_row2> { typedef detail::matrix_short_5x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x3,3> matrix_short_5x3_row3; } template <> struct geometric_traits<detail::matrix_short_5x3_row3> { typedef detail::matrix_short_5x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x3,4> matrix_short_5x3_row4; } template <> struct geometric_traits<detail::matrix_short_5x3_row4> { typedef detail::matrix_short_5x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x3,0> matrix_short_5x3_column0; }template <> struct geometric_traits<detail::matrix_short_5x3_column0> { typedef detail::matrix_short_5x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x3,1> matrix_short_5x3_column1; }template <> struct geometric_traits<detail::matrix_short_5x3_column1> { typedef detail::matrix_short_5x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x3,2> matrix_short_5x3_column2; }template <> struct geometric_traits<detail::matrix_short_5x3_column2> { typedef detail::matrix_short_5x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x3>::type > : index_operator_matrix_access_policy < matrix_short_5x3 > { typedef index_operator_matrix_access_policy < matrix_short_5x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x3 > { typedef dimension<5> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 4> matrix_short_5x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x4,0> matrix_short_5x4_row0; } template <> struct geometric_traits<detail::matrix_short_5x4_row0> { typedef detail::matrix_short_5x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x4,1> matrix_short_5x4_row1; } template <> struct geometric_traits<detail::matrix_short_5x4_row1> { typedef detail::matrix_short_5x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x4,2> matrix_short_5x4_row2; } template <> struct geometric_traits<detail::matrix_short_5x4_row2> { typedef detail::matrix_short_5x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x4,3> matrix_short_5x4_row3; } template <> struct geometric_traits<detail::matrix_short_5x4_row3> { typedef detail::matrix_short_5x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x4,4> matrix_short_5x4_row4; } template <> struct geometric_traits<detail::matrix_short_5x4_row4> { typedef detail::matrix_short_5x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x4,0> matrix_short_5x4_column0; }template <> struct geometric_traits<detail::matrix_short_5x4_column0> { typedef detail::matrix_short_5x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x4,1> matrix_short_5x4_column1; }template <> struct geometric_traits<detail::matrix_short_5x4_column1> { typedef detail::matrix_short_5x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x4,2> matrix_short_5x4_column2; }template <> struct geometric_traits<detail::matrix_short_5x4_column2> { typedef detail::matrix_short_5x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x4,3> matrix_short_5x4_column3; }template <> struct geometric_traits<detail::matrix_short_5x4_column3> { typedef detail::matrix_short_5x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x4>::type > : index_operator_matrix_access_policy < matrix_short_5x4 > { typedef index_operator_matrix_access_policy < matrix_short_5x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x4 > { typedef dimension<5> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 5> matrix_short_5x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x5,0> matrix_short_5x5_row0; } template <> struct geometric_traits<detail::matrix_short_5x5_row0> { typedef detail::matrix_short_5x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x5,1> matrix_short_5x5_row1; } template <> struct geometric_traits<detail::matrix_short_5x5_row1> { typedef detail::matrix_short_5x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x5,2> matrix_short_5x5_row2; } template <> struct geometric_traits<detail::matrix_short_5x5_row2> { typedef detail::matrix_short_5x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x5,3> matrix_short_5x5_row3; } template <> struct geometric_traits<detail::matrix_short_5x5_row3> { typedef detail::matrix_short_5x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x5,4> matrix_short_5x5_row4; } template <> struct geometric_traits<detail::matrix_short_5x5_row4> { typedef detail::matrix_short_5x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x5,0> matrix_short_5x5_column0; }template <> struct geometric_traits<detail::matrix_short_5x5_column0> { typedef detail::matrix_short_5x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x5,1> matrix_short_5x5_column1; }template <> struct geometric_traits<detail::matrix_short_5x5_column1> { typedef detail::matrix_short_5x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x5,2> matrix_short_5x5_column2; }template <> struct geometric_traits<detail::matrix_short_5x5_column2> { typedef detail::matrix_short_5x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x5,3> matrix_short_5x5_column3; }template <> struct geometric_traits<detail::matrix_short_5x5_column3> { typedef detail::matrix_short_5x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x5,4> matrix_short_5x5_column4; }template <> struct geometric_traits<detail::matrix_short_5x5_column4> { typedef detail::matrix_short_5x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x5>::type > : index_operator_matrix_access_policy < matrix_short_5x5 > { typedef index_operator_matrix_access_policy < matrix_short_5x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x5 > { typedef dimension<5> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 6> matrix_short_5x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x6,0> matrix_short_5x6_row0; } template <> struct geometric_traits<detail::matrix_short_5x6_row0> { typedef detail::matrix_short_5x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x6,1> matrix_short_5x6_row1; } template <> struct geometric_traits<detail::matrix_short_5x6_row1> { typedef detail::matrix_short_5x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x6,2> matrix_short_5x6_row2; } template <> struct geometric_traits<detail::matrix_short_5x6_row2> { typedef detail::matrix_short_5x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x6,3> matrix_short_5x6_row3; } template <> struct geometric_traits<detail::matrix_short_5x6_row3> { typedef detail::matrix_short_5x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x6,4> matrix_short_5x6_row4; } template <> struct geometric_traits<detail::matrix_short_5x6_row4> { typedef detail::matrix_short_5x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,0> matrix_short_5x6_column0; }template <> struct geometric_traits<detail::matrix_short_5x6_column0> { typedef detail::matrix_short_5x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,1> matrix_short_5x6_column1; }template <> struct geometric_traits<detail::matrix_short_5x6_column1> { typedef detail::matrix_short_5x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,2> matrix_short_5x6_column2; }template <> struct geometric_traits<detail::matrix_short_5x6_column2> { typedef detail::matrix_short_5x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,3> matrix_short_5x6_column3; }template <> struct geometric_traits<detail::matrix_short_5x6_column3> { typedef detail::matrix_short_5x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,4> matrix_short_5x6_column4; }template <> struct geometric_traits<detail::matrix_short_5x6_column4> { typedef detail::matrix_short_5x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x6,5> matrix_short_5x6_column5; }template <> struct geometric_traits<detail::matrix_short_5x6_column5> { typedef detail::matrix_short_5x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x6>::type > : index_operator_matrix_access_policy < matrix_short_5x6 > { typedef index_operator_matrix_access_policy < matrix_short_5x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x6 > { typedef dimension<5> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 7> matrix_short_5x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x7,0> matrix_short_5x7_row0; } template <> struct geometric_traits<detail::matrix_short_5x7_row0> { typedef detail::matrix_short_5x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x7,1> matrix_short_5x7_row1; } template <> struct geometric_traits<detail::matrix_short_5x7_row1> { typedef detail::matrix_short_5x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x7,2> matrix_short_5x7_row2; } template <> struct geometric_traits<detail::matrix_short_5x7_row2> { typedef detail::matrix_short_5x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x7,3> matrix_short_5x7_row3; } template <> struct geometric_traits<detail::matrix_short_5x7_row3> { typedef detail::matrix_short_5x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x7,4> matrix_short_5x7_row4; } template <> struct geometric_traits<detail::matrix_short_5x7_row4> { typedef detail::matrix_short_5x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,0> matrix_short_5x7_column0; }template <> struct geometric_traits<detail::matrix_short_5x7_column0> { typedef detail::matrix_short_5x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,1> matrix_short_5x7_column1; }template <> struct geometric_traits<detail::matrix_short_5x7_column1> { typedef detail::matrix_short_5x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,2> matrix_short_5x7_column2; }template <> struct geometric_traits<detail::matrix_short_5x7_column2> { typedef detail::matrix_short_5x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,3> matrix_short_5x7_column3; }template <> struct geometric_traits<detail::matrix_short_5x7_column3> { typedef detail::matrix_short_5x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,4> matrix_short_5x7_column4; }template <> struct geometric_traits<detail::matrix_short_5x7_column4> { typedef detail::matrix_short_5x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,5> matrix_short_5x7_column5; }template <> struct geometric_traits<detail::matrix_short_5x7_column5> { typedef detail::matrix_short_5x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x7,6> matrix_short_5x7_column6; }template <> struct geometric_traits<detail::matrix_short_5x7_column6> { typedef detail::matrix_short_5x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x7>::type > : index_operator_matrix_access_policy < matrix_short_5x7 > { typedef index_operator_matrix_access_policy < matrix_short_5x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x7 > { typedef dimension<5> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 8> matrix_short_5x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x8,0> matrix_short_5x8_row0; } template <> struct geometric_traits<detail::matrix_short_5x8_row0> { typedef detail::matrix_short_5x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x8,1> matrix_short_5x8_row1; } template <> struct geometric_traits<detail::matrix_short_5x8_row1> { typedef detail::matrix_short_5x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x8,2> matrix_short_5x8_row2; } template <> struct geometric_traits<detail::matrix_short_5x8_row2> { typedef detail::matrix_short_5x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x8,3> matrix_short_5x8_row3; } template <> struct geometric_traits<detail::matrix_short_5x8_row3> { typedef detail::matrix_short_5x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x8,4> matrix_short_5x8_row4; } template <> struct geometric_traits<detail::matrix_short_5x8_row4> { typedef detail::matrix_short_5x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,0> matrix_short_5x8_column0; }template <> struct geometric_traits<detail::matrix_short_5x8_column0> { typedef detail::matrix_short_5x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,1> matrix_short_5x8_column1; }template <> struct geometric_traits<detail::matrix_short_5x8_column1> { typedef detail::matrix_short_5x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,2> matrix_short_5x8_column2; }template <> struct geometric_traits<detail::matrix_short_5x8_column2> { typedef detail::matrix_short_5x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,3> matrix_short_5x8_column3; }template <> struct geometric_traits<detail::matrix_short_5x8_column3> { typedef detail::matrix_short_5x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,4> matrix_short_5x8_column4; }template <> struct geometric_traits<detail::matrix_short_5x8_column4> { typedef detail::matrix_short_5x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,5> matrix_short_5x8_column5; }template <> struct geometric_traits<detail::matrix_short_5x8_column5> { typedef detail::matrix_short_5x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,6> matrix_short_5x8_column6; }template <> struct geometric_traits<detail::matrix_short_5x8_column6> { typedef detail::matrix_short_5x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x8,7> matrix_short_5x8_column7; }template <> struct geometric_traits<detail::matrix_short_5x8_column7> { typedef detail::matrix_short_5x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x8>::type > : index_operator_matrix_access_policy < matrix_short_5x8 > { typedef index_operator_matrix_access_policy < matrix_short_5x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x8 > { typedef dimension<5> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 9> matrix_short_5x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x9,0> matrix_short_5x9_row0; } template <> struct geometric_traits<detail::matrix_short_5x9_row0> { typedef detail::matrix_short_5x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x9,1> matrix_short_5x9_row1; } template <> struct geometric_traits<detail::matrix_short_5x9_row1> { typedef detail::matrix_short_5x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x9,2> matrix_short_5x9_row2; } template <> struct geometric_traits<detail::matrix_short_5x9_row2> { typedef detail::matrix_short_5x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x9,3> matrix_short_5x9_row3; } template <> struct geometric_traits<detail::matrix_short_5x9_row3> { typedef detail::matrix_short_5x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x9,4> matrix_short_5x9_row4; } template <> struct geometric_traits<detail::matrix_short_5x9_row4> { typedef detail::matrix_short_5x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,0> matrix_short_5x9_column0; }template <> struct geometric_traits<detail::matrix_short_5x9_column0> { typedef detail::matrix_short_5x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,1> matrix_short_5x9_column1; }template <> struct geometric_traits<detail::matrix_short_5x9_column1> { typedef detail::matrix_short_5x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,2> matrix_short_5x9_column2; }template <> struct geometric_traits<detail::matrix_short_5x9_column2> { typedef detail::matrix_short_5x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,3> matrix_short_5x9_column3; }template <> struct geometric_traits<detail::matrix_short_5x9_column3> { typedef detail::matrix_short_5x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,4> matrix_short_5x9_column4; }template <> struct geometric_traits<detail::matrix_short_5x9_column4> { typedef detail::matrix_short_5x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,5> matrix_short_5x9_column5; }template <> struct geometric_traits<detail::matrix_short_5x9_column5> { typedef detail::matrix_short_5x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,6> matrix_short_5x9_column6; }template <> struct geometric_traits<detail::matrix_short_5x9_column6> { typedef detail::matrix_short_5x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,7> matrix_short_5x9_column7; }template <> struct geometric_traits<detail::matrix_short_5x9_column7> { typedef detail::matrix_short_5x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x9,8> matrix_short_5x9_column8; }template <> struct geometric_traits<detail::matrix_short_5x9_column8> { typedef detail::matrix_short_5x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x9>::type > : index_operator_matrix_access_policy < matrix_short_5x9 > { typedef index_operator_matrix_access_policy < matrix_short_5x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x9 > { typedef dimension<5> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 5, 10> matrix_short_5x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x10,0> matrix_short_5x10_row0; } template <> struct geometric_traits<detail::matrix_short_5x10_row0> { typedef detail::matrix_short_5x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x10,1> matrix_short_5x10_row1; } template <> struct geometric_traits<detail::matrix_short_5x10_row1> { typedef detail::matrix_short_5x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x10,2> matrix_short_5x10_row2; } template <> struct geometric_traits<detail::matrix_short_5x10_row2> { typedef detail::matrix_short_5x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x10,3> matrix_short_5x10_row3; } template <> struct geometric_traits<detail::matrix_short_5x10_row3> { typedef detail::matrix_short_5x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_5x10,4> matrix_short_5x10_row4; } template <> struct geometric_traits<detail::matrix_short_5x10_row4> { typedef detail::matrix_short_5x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,0> matrix_short_5x10_column0; }template <> struct geometric_traits<detail::matrix_short_5x10_column0> { typedef detail::matrix_short_5x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,1> matrix_short_5x10_column1; }template <> struct geometric_traits<detail::matrix_short_5x10_column1> { typedef detail::matrix_short_5x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,2> matrix_short_5x10_column2; }template <> struct geometric_traits<detail::matrix_short_5x10_column2> { typedef detail::matrix_short_5x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,3> matrix_short_5x10_column3; }template <> struct geometric_traits<detail::matrix_short_5x10_column3> { typedef detail::matrix_short_5x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,4> matrix_short_5x10_column4; }template <> struct geometric_traits<detail::matrix_short_5x10_column4> { typedef detail::matrix_short_5x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,5> matrix_short_5x10_column5; }template <> struct geometric_traits<detail::matrix_short_5x10_column5> { typedef detail::matrix_short_5x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,6> matrix_short_5x10_column6; }template <> struct geometric_traits<detail::matrix_short_5x10_column6> { typedef detail::matrix_short_5x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,7> matrix_short_5x10_column7; }template <> struct geometric_traits<detail::matrix_short_5x10_column7> { typedef detail::matrix_short_5x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,8> matrix_short_5x10_column8; }template <> struct geometric_traits<detail::matrix_short_5x10_column8> { typedef detail::matrix_short_5x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_5x10,9> matrix_short_5x10_column9; }template <> struct geometric_traits<detail::matrix_short_5x10_column9> { typedef detail::matrix_short_5x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_5x10>::type > : index_operator_matrix_access_policy < matrix_short_5x10 > { typedef index_operator_matrix_access_policy < matrix_short_5x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_5x10 > { typedef dimension<5> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 1> matrix_short_6x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,0> matrix_short_6x1_row0; } template <> struct geometric_traits<detail::matrix_short_6x1_row0> { typedef detail::matrix_short_6x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,1> matrix_short_6x1_row1; } template <> struct geometric_traits<detail::matrix_short_6x1_row1> { typedef detail::matrix_short_6x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,2> matrix_short_6x1_row2; } template <> struct geometric_traits<detail::matrix_short_6x1_row2> { typedef detail::matrix_short_6x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,3> matrix_short_6x1_row3; } template <> struct geometric_traits<detail::matrix_short_6x1_row3> { typedef detail::matrix_short_6x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,4> matrix_short_6x1_row4; } template <> struct geometric_traits<detail::matrix_short_6x1_row4> { typedef detail::matrix_short_6x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x1,5> matrix_short_6x1_row5; } template <> struct geometric_traits<detail::matrix_short_6x1_row5> { typedef detail::matrix_short_6x1_row5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x1,0> matrix_short_6x1_column0; }template <> struct geometric_traits<detail::matrix_short_6x1_column0> { typedef detail::matrix_short_6x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x1>::type > : index_operator_matrix_access_policy < matrix_short_6x1 > { typedef index_operator_matrix_access_policy < matrix_short_6x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x1 > { typedef dimension<6> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 2> matrix_short_6x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,0> matrix_short_6x2_row0; } template <> struct geometric_traits<detail::matrix_short_6x2_row0> { typedef detail::matrix_short_6x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,1> matrix_short_6x2_row1; } template <> struct geometric_traits<detail::matrix_short_6x2_row1> { typedef detail::matrix_short_6x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,2> matrix_short_6x2_row2; } template <> struct geometric_traits<detail::matrix_short_6x2_row2> { typedef detail::matrix_short_6x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,3> matrix_short_6x2_row3; } template <> struct geometric_traits<detail::matrix_short_6x2_row3> { typedef detail::matrix_short_6x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,4> matrix_short_6x2_row4; } template <> struct geometric_traits<detail::matrix_short_6x2_row4> { typedef detail::matrix_short_6x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x2,5> matrix_short_6x2_row5; } template <> struct geometric_traits<detail::matrix_short_6x2_row5> { typedef detail::matrix_short_6x2_row5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x2,0> matrix_short_6x2_column0; }template <> struct geometric_traits<detail::matrix_short_6x2_column0> { typedef detail::matrix_short_6x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x2,1> matrix_short_6x2_column1; }template <> struct geometric_traits<detail::matrix_short_6x2_column1> { typedef detail::matrix_short_6x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x2>::type > : index_operator_matrix_access_policy < matrix_short_6x2 > { typedef index_operator_matrix_access_policy < matrix_short_6x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x2 > { typedef dimension<6> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 3> matrix_short_6x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,0> matrix_short_6x3_row0; } template <> struct geometric_traits<detail::matrix_short_6x3_row0> { typedef detail::matrix_short_6x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,1> matrix_short_6x3_row1; } template <> struct geometric_traits<detail::matrix_short_6x3_row1> { typedef detail::matrix_short_6x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,2> matrix_short_6x3_row2; } template <> struct geometric_traits<detail::matrix_short_6x3_row2> { typedef detail::matrix_short_6x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,3> matrix_short_6x3_row3; } template <> struct geometric_traits<detail::matrix_short_6x3_row3> { typedef detail::matrix_short_6x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,4> matrix_short_6x3_row4; } template <> struct geometric_traits<detail::matrix_short_6x3_row4> { typedef detail::matrix_short_6x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x3,5> matrix_short_6x3_row5; } template <> struct geometric_traits<detail::matrix_short_6x3_row5> { typedef detail::matrix_short_6x3_row5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x3,0> matrix_short_6x3_column0; }template <> struct geometric_traits<detail::matrix_short_6x3_column0> { typedef detail::matrix_short_6x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x3,1> matrix_short_6x3_column1; }template <> struct geometric_traits<detail::matrix_short_6x3_column1> { typedef detail::matrix_short_6x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x3,2> matrix_short_6x3_column2; }template <> struct geometric_traits<detail::matrix_short_6x3_column2> { typedef detail::matrix_short_6x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x3>::type > : index_operator_matrix_access_policy < matrix_short_6x3 > { typedef index_operator_matrix_access_policy < matrix_short_6x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x3 > { typedef dimension<6> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 4> matrix_short_6x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,0> matrix_short_6x4_row0; } template <> struct geometric_traits<detail::matrix_short_6x4_row0> { typedef detail::matrix_short_6x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,1> matrix_short_6x4_row1; } template <> struct geometric_traits<detail::matrix_short_6x4_row1> { typedef detail::matrix_short_6x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,2> matrix_short_6x4_row2; } template <> struct geometric_traits<detail::matrix_short_6x4_row2> { typedef detail::matrix_short_6x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,3> matrix_short_6x4_row3; } template <> struct geometric_traits<detail::matrix_short_6x4_row3> { typedef detail::matrix_short_6x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,4> matrix_short_6x4_row4; } template <> struct geometric_traits<detail::matrix_short_6x4_row4> { typedef detail::matrix_short_6x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x4,5> matrix_short_6x4_row5; } template <> struct geometric_traits<detail::matrix_short_6x4_row5> { typedef detail::matrix_short_6x4_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x4,0> matrix_short_6x4_column0; }template <> struct geometric_traits<detail::matrix_short_6x4_column0> { typedef detail::matrix_short_6x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x4,1> matrix_short_6x4_column1; }template <> struct geometric_traits<detail::matrix_short_6x4_column1> { typedef detail::matrix_short_6x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x4,2> matrix_short_6x4_column2; }template <> struct geometric_traits<detail::matrix_short_6x4_column2> { typedef detail::matrix_short_6x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x4,3> matrix_short_6x4_column3; }template <> struct geometric_traits<detail::matrix_short_6x4_column3> { typedef detail::matrix_short_6x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x4>::type > : index_operator_matrix_access_policy < matrix_short_6x4 > { typedef index_operator_matrix_access_policy < matrix_short_6x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x4 > { typedef dimension<6> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 5> matrix_short_6x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,0> matrix_short_6x5_row0; } template <> struct geometric_traits<detail::matrix_short_6x5_row0> { typedef detail::matrix_short_6x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,1> matrix_short_6x5_row1; } template <> struct geometric_traits<detail::matrix_short_6x5_row1> { typedef detail::matrix_short_6x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,2> matrix_short_6x5_row2; } template <> struct geometric_traits<detail::matrix_short_6x5_row2> { typedef detail::matrix_short_6x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,3> matrix_short_6x5_row3; } template <> struct geometric_traits<detail::matrix_short_6x5_row3> { typedef detail::matrix_short_6x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,4> matrix_short_6x5_row4; } template <> struct geometric_traits<detail::matrix_short_6x5_row4> { typedef detail::matrix_short_6x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x5,5> matrix_short_6x5_row5; } template <> struct geometric_traits<detail::matrix_short_6x5_row5> { typedef detail::matrix_short_6x5_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x5,0> matrix_short_6x5_column0; }template <> struct geometric_traits<detail::matrix_short_6x5_column0> { typedef detail::matrix_short_6x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x5,1> matrix_short_6x5_column1; }template <> struct geometric_traits<detail::matrix_short_6x5_column1> { typedef detail::matrix_short_6x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x5,2> matrix_short_6x5_column2; }template <> struct geometric_traits<detail::matrix_short_6x5_column2> { typedef detail::matrix_short_6x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x5,3> matrix_short_6x5_column3; }template <> struct geometric_traits<detail::matrix_short_6x5_column3> { typedef detail::matrix_short_6x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x5,4> matrix_short_6x5_column4; }template <> struct geometric_traits<detail::matrix_short_6x5_column4> { typedef detail::matrix_short_6x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x5>::type > : index_operator_matrix_access_policy < matrix_short_6x5 > { typedef index_operator_matrix_access_policy < matrix_short_6x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x5 > { typedef dimension<6> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 6> matrix_short_6x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,0> matrix_short_6x6_row0; } template <> struct geometric_traits<detail::matrix_short_6x6_row0> { typedef detail::matrix_short_6x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,1> matrix_short_6x6_row1; } template <> struct geometric_traits<detail::matrix_short_6x6_row1> { typedef detail::matrix_short_6x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,2> matrix_short_6x6_row2; } template <> struct geometric_traits<detail::matrix_short_6x6_row2> { typedef detail::matrix_short_6x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,3> matrix_short_6x6_row3; } template <> struct geometric_traits<detail::matrix_short_6x6_row3> { typedef detail::matrix_short_6x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,4> matrix_short_6x6_row4; } template <> struct geometric_traits<detail::matrix_short_6x6_row4> { typedef detail::matrix_short_6x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x6,5> matrix_short_6x6_row5; } template <> struct geometric_traits<detail::matrix_short_6x6_row5> { typedef detail::matrix_short_6x6_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,0> matrix_short_6x6_column0; }template <> struct geometric_traits<detail::matrix_short_6x6_column0> { typedef detail::matrix_short_6x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,1> matrix_short_6x6_column1; }template <> struct geometric_traits<detail::matrix_short_6x6_column1> { typedef detail::matrix_short_6x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,2> matrix_short_6x6_column2; }template <> struct geometric_traits<detail::matrix_short_6x6_column2> { typedef detail::matrix_short_6x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,3> matrix_short_6x6_column3; }template <> struct geometric_traits<detail::matrix_short_6x6_column3> { typedef detail::matrix_short_6x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,4> matrix_short_6x6_column4; }template <> struct geometric_traits<detail::matrix_short_6x6_column4> { typedef detail::matrix_short_6x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x6,5> matrix_short_6x6_column5; }template <> struct geometric_traits<detail::matrix_short_6x6_column5> { typedef detail::matrix_short_6x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x6>::type > : index_operator_matrix_access_policy < matrix_short_6x6 > { typedef index_operator_matrix_access_policy < matrix_short_6x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x6 > { typedef dimension<6> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 7> matrix_short_6x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,0> matrix_short_6x7_row0; } template <> struct geometric_traits<detail::matrix_short_6x7_row0> { typedef detail::matrix_short_6x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,1> matrix_short_6x7_row1; } template <> struct geometric_traits<detail::matrix_short_6x7_row1> { typedef detail::matrix_short_6x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,2> matrix_short_6x7_row2; } template <> struct geometric_traits<detail::matrix_short_6x7_row2> { typedef detail::matrix_short_6x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,3> matrix_short_6x7_row3; } template <> struct geometric_traits<detail::matrix_short_6x7_row3> { typedef detail::matrix_short_6x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,4> matrix_short_6x7_row4; } template <> struct geometric_traits<detail::matrix_short_6x7_row4> { typedef detail::matrix_short_6x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x7,5> matrix_short_6x7_row5; } template <> struct geometric_traits<detail::matrix_short_6x7_row5> { typedef detail::matrix_short_6x7_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,0> matrix_short_6x7_column0; }template <> struct geometric_traits<detail::matrix_short_6x7_column0> { typedef detail::matrix_short_6x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,1> matrix_short_6x7_column1; }template <> struct geometric_traits<detail::matrix_short_6x7_column1> { typedef detail::matrix_short_6x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,2> matrix_short_6x7_column2; }template <> struct geometric_traits<detail::matrix_short_6x7_column2> { typedef detail::matrix_short_6x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,3> matrix_short_6x7_column3; }template <> struct geometric_traits<detail::matrix_short_6x7_column3> { typedef detail::matrix_short_6x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,4> matrix_short_6x7_column4; }template <> struct geometric_traits<detail::matrix_short_6x7_column4> { typedef detail::matrix_short_6x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,5> matrix_short_6x7_column5; }template <> struct geometric_traits<detail::matrix_short_6x7_column5> { typedef detail::matrix_short_6x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x7,6> matrix_short_6x7_column6; }template <> struct geometric_traits<detail::matrix_short_6x7_column6> { typedef detail::matrix_short_6x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x7>::type > : index_operator_matrix_access_policy < matrix_short_6x7 > { typedef index_operator_matrix_access_policy < matrix_short_6x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x7 > { typedef dimension<6> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 8> matrix_short_6x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,0> matrix_short_6x8_row0; } template <> struct geometric_traits<detail::matrix_short_6x8_row0> { typedef detail::matrix_short_6x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,1> matrix_short_6x8_row1; } template <> struct geometric_traits<detail::matrix_short_6x8_row1> { typedef detail::matrix_short_6x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,2> matrix_short_6x8_row2; } template <> struct geometric_traits<detail::matrix_short_6x8_row2> { typedef detail::matrix_short_6x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,3> matrix_short_6x8_row3; } template <> struct geometric_traits<detail::matrix_short_6x8_row3> { typedef detail::matrix_short_6x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,4> matrix_short_6x8_row4; } template <> struct geometric_traits<detail::matrix_short_6x8_row4> { typedef detail::matrix_short_6x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x8,5> matrix_short_6x8_row5; } template <> struct geometric_traits<detail::matrix_short_6x8_row5> { typedef detail::matrix_short_6x8_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,0> matrix_short_6x8_column0; }template <> struct geometric_traits<detail::matrix_short_6x8_column0> { typedef detail::matrix_short_6x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,1> matrix_short_6x8_column1; }template <> struct geometric_traits<detail::matrix_short_6x8_column1> { typedef detail::matrix_short_6x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,2> matrix_short_6x8_column2; }template <> struct geometric_traits<detail::matrix_short_6x8_column2> { typedef detail::matrix_short_6x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,3> matrix_short_6x8_column3; }template <> struct geometric_traits<detail::matrix_short_6x8_column3> { typedef detail::matrix_short_6x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,4> matrix_short_6x8_column4; }template <> struct geometric_traits<detail::matrix_short_6x8_column4> { typedef detail::matrix_short_6x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,5> matrix_short_6x8_column5; }template <> struct geometric_traits<detail::matrix_short_6x8_column5> { typedef detail::matrix_short_6x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,6> matrix_short_6x8_column6; }template <> struct geometric_traits<detail::matrix_short_6x8_column6> { typedef detail::matrix_short_6x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x8,7> matrix_short_6x8_column7; }template <> struct geometric_traits<detail::matrix_short_6x8_column7> { typedef detail::matrix_short_6x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x8>::type > : index_operator_matrix_access_policy < matrix_short_6x8 > { typedef index_operator_matrix_access_policy < matrix_short_6x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x8 > { typedef dimension<6> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 9> matrix_short_6x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,0> matrix_short_6x9_row0; } template <> struct geometric_traits<detail::matrix_short_6x9_row0> { typedef detail::matrix_short_6x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,1> matrix_short_6x9_row1; } template <> struct geometric_traits<detail::matrix_short_6x9_row1> { typedef detail::matrix_short_6x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,2> matrix_short_6x9_row2; } template <> struct geometric_traits<detail::matrix_short_6x9_row2> { typedef detail::matrix_short_6x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,3> matrix_short_6x9_row3; } template <> struct geometric_traits<detail::matrix_short_6x9_row3> { typedef detail::matrix_short_6x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,4> matrix_short_6x9_row4; } template <> struct geometric_traits<detail::matrix_short_6x9_row4> { typedef detail::matrix_short_6x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x9,5> matrix_short_6x9_row5; } template <> struct geometric_traits<detail::matrix_short_6x9_row5> { typedef detail::matrix_short_6x9_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,0> matrix_short_6x9_column0; }template <> struct geometric_traits<detail::matrix_short_6x9_column0> { typedef detail::matrix_short_6x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,1> matrix_short_6x9_column1; }template <> struct geometric_traits<detail::matrix_short_6x9_column1> { typedef detail::matrix_short_6x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,2> matrix_short_6x9_column2; }template <> struct geometric_traits<detail::matrix_short_6x9_column2> { typedef detail::matrix_short_6x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,3> matrix_short_6x9_column3; }template <> struct geometric_traits<detail::matrix_short_6x9_column3> { typedef detail::matrix_short_6x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,4> matrix_short_6x9_column4; }template <> struct geometric_traits<detail::matrix_short_6x9_column4> { typedef detail::matrix_short_6x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,5> matrix_short_6x9_column5; }template <> struct geometric_traits<detail::matrix_short_6x9_column5> { typedef detail::matrix_short_6x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,6> matrix_short_6x9_column6; }template <> struct geometric_traits<detail::matrix_short_6x9_column6> { typedef detail::matrix_short_6x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,7> matrix_short_6x9_column7; }template <> struct geometric_traits<detail::matrix_short_6x9_column7> { typedef detail::matrix_short_6x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x9,8> matrix_short_6x9_column8; }template <> struct geometric_traits<detail::matrix_short_6x9_column8> { typedef detail::matrix_short_6x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x9>::type > : index_operator_matrix_access_policy < matrix_short_6x9 > { typedef index_operator_matrix_access_policy < matrix_short_6x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x9 > { typedef dimension<6> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 6, 10> matrix_short_6x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,0> matrix_short_6x10_row0; } template <> struct geometric_traits<detail::matrix_short_6x10_row0> { typedef detail::matrix_short_6x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,1> matrix_short_6x10_row1; } template <> struct geometric_traits<detail::matrix_short_6x10_row1> { typedef detail::matrix_short_6x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,2> matrix_short_6x10_row2; } template <> struct geometric_traits<detail::matrix_short_6x10_row2> { typedef detail::matrix_short_6x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,3> matrix_short_6x10_row3; } template <> struct geometric_traits<detail::matrix_short_6x10_row3> { typedef detail::matrix_short_6x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,4> matrix_short_6x10_row4; } template <> struct geometric_traits<detail::matrix_short_6x10_row4> { typedef detail::matrix_short_6x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_6x10,5> matrix_short_6x10_row5; } template <> struct geometric_traits<detail::matrix_short_6x10_row5> { typedef detail::matrix_short_6x10_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,0> matrix_short_6x10_column0; }template <> struct geometric_traits<detail::matrix_short_6x10_column0> { typedef detail::matrix_short_6x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,1> matrix_short_6x10_column1; }template <> struct geometric_traits<detail::matrix_short_6x10_column1> { typedef detail::matrix_short_6x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,2> matrix_short_6x10_column2; }template <> struct geometric_traits<detail::matrix_short_6x10_column2> { typedef detail::matrix_short_6x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,3> matrix_short_6x10_column3; }template <> struct geometric_traits<detail::matrix_short_6x10_column3> { typedef detail::matrix_short_6x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,4> matrix_short_6x10_column4; }template <> struct geometric_traits<detail::matrix_short_6x10_column4> { typedef detail::matrix_short_6x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,5> matrix_short_6x10_column5; }template <> struct geometric_traits<detail::matrix_short_6x10_column5> { typedef detail::matrix_short_6x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,6> matrix_short_6x10_column6; }template <> struct geometric_traits<detail::matrix_short_6x10_column6> { typedef detail::matrix_short_6x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,7> matrix_short_6x10_column7; }template <> struct geometric_traits<detail::matrix_short_6x10_column7> { typedef detail::matrix_short_6x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,8> matrix_short_6x10_column8; }template <> struct geometric_traits<detail::matrix_short_6x10_column8> { typedef detail::matrix_short_6x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_6x10,9> matrix_short_6x10_column9; }template <> struct geometric_traits<detail::matrix_short_6x10_column9> { typedef detail::matrix_short_6x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_6x10>::type > : index_operator_matrix_access_policy < matrix_short_6x10 > { typedef index_operator_matrix_access_policy < matrix_short_6x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_6x10 > { typedef dimension<6> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 1> matrix_short_7x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,0> matrix_short_7x1_row0; } template <> struct geometric_traits<detail::matrix_short_7x1_row0> { typedef detail::matrix_short_7x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,1> matrix_short_7x1_row1; } template <> struct geometric_traits<detail::matrix_short_7x1_row1> { typedef detail::matrix_short_7x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,2> matrix_short_7x1_row2; } template <> struct geometric_traits<detail::matrix_short_7x1_row2> { typedef detail::matrix_short_7x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,3> matrix_short_7x1_row3; } template <> struct geometric_traits<detail::matrix_short_7x1_row3> { typedef detail::matrix_short_7x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,4> matrix_short_7x1_row4; } template <> struct geometric_traits<detail::matrix_short_7x1_row4> { typedef detail::matrix_short_7x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,5> matrix_short_7x1_row5; } template <> struct geometric_traits<detail::matrix_short_7x1_row5> { typedef detail::matrix_short_7x1_row5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x1,6> matrix_short_7x1_row6; } template <> struct geometric_traits<detail::matrix_short_7x1_row6> { typedef detail::matrix_short_7x1_row6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x1,0> matrix_short_7x1_column0; }template <> struct geometric_traits<detail::matrix_short_7x1_column0> { typedef detail::matrix_short_7x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x1>::type > : index_operator_matrix_access_policy < matrix_short_7x1 > { typedef index_operator_matrix_access_policy < matrix_short_7x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x1 > { typedef dimension<7> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 2> matrix_short_7x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,0> matrix_short_7x2_row0; } template <> struct geometric_traits<detail::matrix_short_7x2_row0> { typedef detail::matrix_short_7x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,1> matrix_short_7x2_row1; } template <> struct geometric_traits<detail::matrix_short_7x2_row1> { typedef detail::matrix_short_7x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,2> matrix_short_7x2_row2; } template <> struct geometric_traits<detail::matrix_short_7x2_row2> { typedef detail::matrix_short_7x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,3> matrix_short_7x2_row3; } template <> struct geometric_traits<detail::matrix_short_7x2_row3> { typedef detail::matrix_short_7x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,4> matrix_short_7x2_row4; } template <> struct geometric_traits<detail::matrix_short_7x2_row4> { typedef detail::matrix_short_7x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,5> matrix_short_7x2_row5; } template <> struct geometric_traits<detail::matrix_short_7x2_row5> { typedef detail::matrix_short_7x2_row5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x2,6> matrix_short_7x2_row6; } template <> struct geometric_traits<detail::matrix_short_7x2_row6> { typedef detail::matrix_short_7x2_row6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x2,0> matrix_short_7x2_column0; }template <> struct geometric_traits<detail::matrix_short_7x2_column0> { typedef detail::matrix_short_7x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x2,1> matrix_short_7x2_column1; }template <> struct geometric_traits<detail::matrix_short_7x2_column1> { typedef detail::matrix_short_7x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x2>::type > : index_operator_matrix_access_policy < matrix_short_7x2 > { typedef index_operator_matrix_access_policy < matrix_short_7x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x2 > { typedef dimension<7> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 3> matrix_short_7x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,0> matrix_short_7x3_row0; } template <> struct geometric_traits<detail::matrix_short_7x3_row0> { typedef detail::matrix_short_7x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,1> matrix_short_7x3_row1; } template <> struct geometric_traits<detail::matrix_short_7x3_row1> { typedef detail::matrix_short_7x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,2> matrix_short_7x3_row2; } template <> struct geometric_traits<detail::matrix_short_7x3_row2> { typedef detail::matrix_short_7x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,3> matrix_short_7x3_row3; } template <> struct geometric_traits<detail::matrix_short_7x3_row3> { typedef detail::matrix_short_7x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,4> matrix_short_7x3_row4; } template <> struct geometric_traits<detail::matrix_short_7x3_row4> { typedef detail::matrix_short_7x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,5> matrix_short_7x3_row5; } template <> struct geometric_traits<detail::matrix_short_7x3_row5> { typedef detail::matrix_short_7x3_row5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x3,6> matrix_short_7x3_row6; } template <> struct geometric_traits<detail::matrix_short_7x3_row6> { typedef detail::matrix_short_7x3_row6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x3,0> matrix_short_7x3_column0; }template <> struct geometric_traits<detail::matrix_short_7x3_column0> { typedef detail::matrix_short_7x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x3,1> matrix_short_7x3_column1; }template <> struct geometric_traits<detail::matrix_short_7x3_column1> { typedef detail::matrix_short_7x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x3,2> matrix_short_7x3_column2; }template <> struct geometric_traits<detail::matrix_short_7x3_column2> { typedef detail::matrix_short_7x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x3>::type > : index_operator_matrix_access_policy < matrix_short_7x3 > { typedef index_operator_matrix_access_policy < matrix_short_7x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x3 > { typedef dimension<7> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 4> matrix_short_7x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,0> matrix_short_7x4_row0; } template <> struct geometric_traits<detail::matrix_short_7x4_row0> { typedef detail::matrix_short_7x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,1> matrix_short_7x4_row1; } template <> struct geometric_traits<detail::matrix_short_7x4_row1> { typedef detail::matrix_short_7x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,2> matrix_short_7x4_row2; } template <> struct geometric_traits<detail::matrix_short_7x4_row2> { typedef detail::matrix_short_7x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,3> matrix_short_7x4_row3; } template <> struct geometric_traits<detail::matrix_short_7x4_row3> { typedef detail::matrix_short_7x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,4> matrix_short_7x4_row4; } template <> struct geometric_traits<detail::matrix_short_7x4_row4> { typedef detail::matrix_short_7x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,5> matrix_short_7x4_row5; } template <> struct geometric_traits<detail::matrix_short_7x4_row5> { typedef detail::matrix_short_7x4_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x4,6> matrix_short_7x4_row6; } template <> struct geometric_traits<detail::matrix_short_7x4_row6> { typedef detail::matrix_short_7x4_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x4,0> matrix_short_7x4_column0; }template <> struct geometric_traits<detail::matrix_short_7x4_column0> { typedef detail::matrix_short_7x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x4,1> matrix_short_7x4_column1; }template <> struct geometric_traits<detail::matrix_short_7x4_column1> { typedef detail::matrix_short_7x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x4,2> matrix_short_7x4_column2; }template <> struct geometric_traits<detail::matrix_short_7x4_column2> { typedef detail::matrix_short_7x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x4,3> matrix_short_7x4_column3; }template <> struct geometric_traits<detail::matrix_short_7x4_column3> { typedef detail::matrix_short_7x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x4>::type > : index_operator_matrix_access_policy < matrix_short_7x4 > { typedef index_operator_matrix_access_policy < matrix_short_7x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x4 > { typedef dimension<7> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 5> matrix_short_7x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,0> matrix_short_7x5_row0; } template <> struct geometric_traits<detail::matrix_short_7x5_row0> { typedef detail::matrix_short_7x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,1> matrix_short_7x5_row1; } template <> struct geometric_traits<detail::matrix_short_7x5_row1> { typedef detail::matrix_short_7x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,2> matrix_short_7x5_row2; } template <> struct geometric_traits<detail::matrix_short_7x5_row2> { typedef detail::matrix_short_7x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,3> matrix_short_7x5_row3; } template <> struct geometric_traits<detail::matrix_short_7x5_row3> { typedef detail::matrix_short_7x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,4> matrix_short_7x5_row4; } template <> struct geometric_traits<detail::matrix_short_7x5_row4> { typedef detail::matrix_short_7x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,5> matrix_short_7x5_row5; } template <> struct geometric_traits<detail::matrix_short_7x5_row5> { typedef detail::matrix_short_7x5_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x5,6> matrix_short_7x5_row6; } template <> struct geometric_traits<detail::matrix_short_7x5_row6> { typedef detail::matrix_short_7x5_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x5,0> matrix_short_7x5_column0; }template <> struct geometric_traits<detail::matrix_short_7x5_column0> { typedef detail::matrix_short_7x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x5,1> matrix_short_7x5_column1; }template <> struct geometric_traits<detail::matrix_short_7x5_column1> { typedef detail::matrix_short_7x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x5,2> matrix_short_7x5_column2; }template <> struct geometric_traits<detail::matrix_short_7x5_column2> { typedef detail::matrix_short_7x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x5,3> matrix_short_7x5_column3; }template <> struct geometric_traits<detail::matrix_short_7x5_column3> { typedef detail::matrix_short_7x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x5,4> matrix_short_7x5_column4; }template <> struct geometric_traits<detail::matrix_short_7x5_column4> { typedef detail::matrix_short_7x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x5>::type > : index_operator_matrix_access_policy < matrix_short_7x5 > { typedef index_operator_matrix_access_policy < matrix_short_7x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x5 > { typedef dimension<7> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 6> matrix_short_7x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,0> matrix_short_7x6_row0; } template <> struct geometric_traits<detail::matrix_short_7x6_row0> { typedef detail::matrix_short_7x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,1> matrix_short_7x6_row1; } template <> struct geometric_traits<detail::matrix_short_7x6_row1> { typedef detail::matrix_short_7x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,2> matrix_short_7x6_row2; } template <> struct geometric_traits<detail::matrix_short_7x6_row2> { typedef detail::matrix_short_7x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,3> matrix_short_7x6_row3; } template <> struct geometric_traits<detail::matrix_short_7x6_row3> { typedef detail::matrix_short_7x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,4> matrix_short_7x6_row4; } template <> struct geometric_traits<detail::matrix_short_7x6_row4> { typedef detail::matrix_short_7x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,5> matrix_short_7x6_row5; } template <> struct geometric_traits<detail::matrix_short_7x6_row5> { typedef detail::matrix_short_7x6_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x6,6> matrix_short_7x6_row6; } template <> struct geometric_traits<detail::matrix_short_7x6_row6> { typedef detail::matrix_short_7x6_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,0> matrix_short_7x6_column0; }template <> struct geometric_traits<detail::matrix_short_7x6_column0> { typedef detail::matrix_short_7x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,1> matrix_short_7x6_column1; }template <> struct geometric_traits<detail::matrix_short_7x6_column1> { typedef detail::matrix_short_7x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,2> matrix_short_7x6_column2; }template <> struct geometric_traits<detail::matrix_short_7x6_column2> { typedef detail::matrix_short_7x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,3> matrix_short_7x6_column3; }template <> struct geometric_traits<detail::matrix_short_7x6_column3> { typedef detail::matrix_short_7x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,4> matrix_short_7x6_column4; }template <> struct geometric_traits<detail::matrix_short_7x6_column4> { typedef detail::matrix_short_7x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x6,5> matrix_short_7x6_column5; }template <> struct geometric_traits<detail::matrix_short_7x6_column5> { typedef detail::matrix_short_7x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x6>::type > : index_operator_matrix_access_policy < matrix_short_7x6 > { typedef index_operator_matrix_access_policy < matrix_short_7x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x6 > { typedef dimension<7> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 7> matrix_short_7x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,0> matrix_short_7x7_row0; } template <> struct geometric_traits<detail::matrix_short_7x7_row0> { typedef detail::matrix_short_7x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,1> matrix_short_7x7_row1; } template <> struct geometric_traits<detail::matrix_short_7x7_row1> { typedef detail::matrix_short_7x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,2> matrix_short_7x7_row2; } template <> struct geometric_traits<detail::matrix_short_7x7_row2> { typedef detail::matrix_short_7x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,3> matrix_short_7x7_row3; } template <> struct geometric_traits<detail::matrix_short_7x7_row3> { typedef detail::matrix_short_7x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,4> matrix_short_7x7_row4; } template <> struct geometric_traits<detail::matrix_short_7x7_row4> { typedef detail::matrix_short_7x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,5> matrix_short_7x7_row5; } template <> struct geometric_traits<detail::matrix_short_7x7_row5> { typedef detail::matrix_short_7x7_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x7,6> matrix_short_7x7_row6; } template <> struct geometric_traits<detail::matrix_short_7x7_row6> { typedef detail::matrix_short_7x7_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,0> matrix_short_7x7_column0; }template <> struct geometric_traits<detail::matrix_short_7x7_column0> { typedef detail::matrix_short_7x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,1> matrix_short_7x7_column1; }template <> struct geometric_traits<detail::matrix_short_7x7_column1> { typedef detail::matrix_short_7x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,2> matrix_short_7x7_column2; }template <> struct geometric_traits<detail::matrix_short_7x7_column2> { typedef detail::matrix_short_7x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,3> matrix_short_7x7_column3; }template <> struct geometric_traits<detail::matrix_short_7x7_column3> { typedef detail::matrix_short_7x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,4> matrix_short_7x7_column4; }template <> struct geometric_traits<detail::matrix_short_7x7_column4> { typedef detail::matrix_short_7x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,5> matrix_short_7x7_column5; }template <> struct geometric_traits<detail::matrix_short_7x7_column5> { typedef detail::matrix_short_7x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x7,6> matrix_short_7x7_column6; }template <> struct geometric_traits<detail::matrix_short_7x7_column6> { typedef detail::matrix_short_7x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x7>::type > : index_operator_matrix_access_policy < matrix_short_7x7 > { typedef index_operator_matrix_access_policy < matrix_short_7x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x7 > { typedef dimension<7> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 8> matrix_short_7x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,0> matrix_short_7x8_row0; } template <> struct geometric_traits<detail::matrix_short_7x8_row0> { typedef detail::matrix_short_7x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,1> matrix_short_7x8_row1; } template <> struct geometric_traits<detail::matrix_short_7x8_row1> { typedef detail::matrix_short_7x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,2> matrix_short_7x8_row2; } template <> struct geometric_traits<detail::matrix_short_7x8_row2> { typedef detail::matrix_short_7x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,3> matrix_short_7x8_row3; } template <> struct geometric_traits<detail::matrix_short_7x8_row3> { typedef detail::matrix_short_7x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,4> matrix_short_7x8_row4; } template <> struct geometric_traits<detail::matrix_short_7x8_row4> { typedef detail::matrix_short_7x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,5> matrix_short_7x8_row5; } template <> struct geometric_traits<detail::matrix_short_7x8_row5> { typedef detail::matrix_short_7x8_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x8,6> matrix_short_7x8_row6; } template <> struct geometric_traits<detail::matrix_short_7x8_row6> { typedef detail::matrix_short_7x8_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,0> matrix_short_7x8_column0; }template <> struct geometric_traits<detail::matrix_short_7x8_column0> { typedef detail::matrix_short_7x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,1> matrix_short_7x8_column1; }template <> struct geometric_traits<detail::matrix_short_7x8_column1> { typedef detail::matrix_short_7x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,2> matrix_short_7x8_column2; }template <> struct geometric_traits<detail::matrix_short_7x8_column2> { typedef detail::matrix_short_7x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,3> matrix_short_7x8_column3; }template <> struct geometric_traits<detail::matrix_short_7x8_column3> { typedef detail::matrix_short_7x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,4> matrix_short_7x8_column4; }template <> struct geometric_traits<detail::matrix_short_7x8_column4> { typedef detail::matrix_short_7x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,5> matrix_short_7x8_column5; }template <> struct geometric_traits<detail::matrix_short_7x8_column5> { typedef detail::matrix_short_7x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,6> matrix_short_7x8_column6; }template <> struct geometric_traits<detail::matrix_short_7x8_column6> { typedef detail::matrix_short_7x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x8,7> matrix_short_7x8_column7; }template <> struct geometric_traits<detail::matrix_short_7x8_column7> { typedef detail::matrix_short_7x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x8>::type > : index_operator_matrix_access_policy < matrix_short_7x8 > { typedef index_operator_matrix_access_policy < matrix_short_7x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x8 > { typedef dimension<7> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 9> matrix_short_7x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,0> matrix_short_7x9_row0; } template <> struct geometric_traits<detail::matrix_short_7x9_row0> { typedef detail::matrix_short_7x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,1> matrix_short_7x9_row1; } template <> struct geometric_traits<detail::matrix_short_7x9_row1> { typedef detail::matrix_short_7x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,2> matrix_short_7x9_row2; } template <> struct geometric_traits<detail::matrix_short_7x9_row2> { typedef detail::matrix_short_7x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,3> matrix_short_7x9_row3; } template <> struct geometric_traits<detail::matrix_short_7x9_row3> { typedef detail::matrix_short_7x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,4> matrix_short_7x9_row4; } template <> struct geometric_traits<detail::matrix_short_7x9_row4> { typedef detail::matrix_short_7x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,5> matrix_short_7x9_row5; } template <> struct geometric_traits<detail::matrix_short_7x9_row5> { typedef detail::matrix_short_7x9_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x9,6> matrix_short_7x9_row6; } template <> struct geometric_traits<detail::matrix_short_7x9_row6> { typedef detail::matrix_short_7x9_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,0> matrix_short_7x9_column0; }template <> struct geometric_traits<detail::matrix_short_7x9_column0> { typedef detail::matrix_short_7x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,1> matrix_short_7x9_column1; }template <> struct geometric_traits<detail::matrix_short_7x9_column1> { typedef detail::matrix_short_7x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,2> matrix_short_7x9_column2; }template <> struct geometric_traits<detail::matrix_short_7x9_column2> { typedef detail::matrix_short_7x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,3> matrix_short_7x9_column3; }template <> struct geometric_traits<detail::matrix_short_7x9_column3> { typedef detail::matrix_short_7x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,4> matrix_short_7x9_column4; }template <> struct geometric_traits<detail::matrix_short_7x9_column4> { typedef detail::matrix_short_7x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,5> matrix_short_7x9_column5; }template <> struct geometric_traits<detail::matrix_short_7x9_column5> { typedef detail::matrix_short_7x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,6> matrix_short_7x9_column6; }template <> struct geometric_traits<detail::matrix_short_7x9_column6> { typedef detail::matrix_short_7x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,7> matrix_short_7x9_column7; }template <> struct geometric_traits<detail::matrix_short_7x9_column7> { typedef detail::matrix_short_7x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x9,8> matrix_short_7x9_column8; }template <> struct geometric_traits<detail::matrix_short_7x9_column8> { typedef detail::matrix_short_7x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x9>::type > : index_operator_matrix_access_policy < matrix_short_7x9 > { typedef index_operator_matrix_access_policy < matrix_short_7x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x9 > { typedef dimension<7> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 7, 10> matrix_short_7x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,0> matrix_short_7x10_row0; } template <> struct geometric_traits<detail::matrix_short_7x10_row0> { typedef detail::matrix_short_7x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,1> matrix_short_7x10_row1; } template <> struct geometric_traits<detail::matrix_short_7x10_row1> { typedef detail::matrix_short_7x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,2> matrix_short_7x10_row2; } template <> struct geometric_traits<detail::matrix_short_7x10_row2> { typedef detail::matrix_short_7x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,3> matrix_short_7x10_row3; } template <> struct geometric_traits<detail::matrix_short_7x10_row3> { typedef detail::matrix_short_7x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,4> matrix_short_7x10_row4; } template <> struct geometric_traits<detail::matrix_short_7x10_row4> { typedef detail::matrix_short_7x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,5> matrix_short_7x10_row5; } template <> struct geometric_traits<detail::matrix_short_7x10_row5> { typedef detail::matrix_short_7x10_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_7x10,6> matrix_short_7x10_row6; } template <> struct geometric_traits<detail::matrix_short_7x10_row6> { typedef detail::matrix_short_7x10_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,0> matrix_short_7x10_column0; }template <> struct geometric_traits<detail::matrix_short_7x10_column0> { typedef detail::matrix_short_7x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,1> matrix_short_7x10_column1; }template <> struct geometric_traits<detail::matrix_short_7x10_column1> { typedef detail::matrix_short_7x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,2> matrix_short_7x10_column2; }template <> struct geometric_traits<detail::matrix_short_7x10_column2> { typedef detail::matrix_short_7x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,3> matrix_short_7x10_column3; }template <> struct geometric_traits<detail::matrix_short_7x10_column3> { typedef detail::matrix_short_7x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,4> matrix_short_7x10_column4; }template <> struct geometric_traits<detail::matrix_short_7x10_column4> { typedef detail::matrix_short_7x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,5> matrix_short_7x10_column5; }template <> struct geometric_traits<detail::matrix_short_7x10_column5> { typedef detail::matrix_short_7x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,6> matrix_short_7x10_column6; }template <> struct geometric_traits<detail::matrix_short_7x10_column6> { typedef detail::matrix_short_7x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,7> matrix_short_7x10_column7; }template <> struct geometric_traits<detail::matrix_short_7x10_column7> { typedef detail::matrix_short_7x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,8> matrix_short_7x10_column8; }template <> struct geometric_traits<detail::matrix_short_7x10_column8> { typedef detail::matrix_short_7x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_7x10,9> matrix_short_7x10_column9; }template <> struct geometric_traits<detail::matrix_short_7x10_column9> { typedef detail::matrix_short_7x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_7x10>::type > : index_operator_matrix_access_policy < matrix_short_7x10 > { typedef index_operator_matrix_access_policy < matrix_short_7x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_7x10 > { typedef dimension<7> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 1> matrix_short_8x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,0> matrix_short_8x1_row0; } template <> struct geometric_traits<detail::matrix_short_8x1_row0> { typedef detail::matrix_short_8x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,1> matrix_short_8x1_row1; } template <> struct geometric_traits<detail::matrix_short_8x1_row1> { typedef detail::matrix_short_8x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,2> matrix_short_8x1_row2; } template <> struct geometric_traits<detail::matrix_short_8x1_row2> { typedef detail::matrix_short_8x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,3> matrix_short_8x1_row3; } template <> struct geometric_traits<detail::matrix_short_8x1_row3> { typedef detail::matrix_short_8x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,4> matrix_short_8x1_row4; } template <> struct geometric_traits<detail::matrix_short_8x1_row4> { typedef detail::matrix_short_8x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,5> matrix_short_8x1_row5; } template <> struct geometric_traits<detail::matrix_short_8x1_row5> { typedef detail::matrix_short_8x1_row5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,6> matrix_short_8x1_row6; } template <> struct geometric_traits<detail::matrix_short_8x1_row6> { typedef detail::matrix_short_8x1_row6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x1,7> matrix_short_8x1_row7; } template <> struct geometric_traits<detail::matrix_short_8x1_row7> { typedef detail::matrix_short_8x1_row7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x1,0> matrix_short_8x1_column0; }template <> struct geometric_traits<detail::matrix_short_8x1_column0> { typedef detail::matrix_short_8x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x1>::type > : index_operator_matrix_access_policy < matrix_short_8x1 > { typedef index_operator_matrix_access_policy < matrix_short_8x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x1 > { typedef dimension<8> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 2> matrix_short_8x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,0> matrix_short_8x2_row0; } template <> struct geometric_traits<detail::matrix_short_8x2_row0> { typedef detail::matrix_short_8x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,1> matrix_short_8x2_row1; } template <> struct geometric_traits<detail::matrix_short_8x2_row1> { typedef detail::matrix_short_8x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,2> matrix_short_8x2_row2; } template <> struct geometric_traits<detail::matrix_short_8x2_row2> { typedef detail::matrix_short_8x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,3> matrix_short_8x2_row3; } template <> struct geometric_traits<detail::matrix_short_8x2_row3> { typedef detail::matrix_short_8x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,4> matrix_short_8x2_row4; } template <> struct geometric_traits<detail::matrix_short_8x2_row4> { typedef detail::matrix_short_8x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,5> matrix_short_8x2_row5; } template <> struct geometric_traits<detail::matrix_short_8x2_row5> { typedef detail::matrix_short_8x2_row5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,6> matrix_short_8x2_row6; } template <> struct geometric_traits<detail::matrix_short_8x2_row6> { typedef detail::matrix_short_8x2_row6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x2,7> matrix_short_8x2_row7; } template <> struct geometric_traits<detail::matrix_short_8x2_row7> { typedef detail::matrix_short_8x2_row7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x2,0> matrix_short_8x2_column0; }template <> struct geometric_traits<detail::matrix_short_8x2_column0> { typedef detail::matrix_short_8x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x2,1> matrix_short_8x2_column1; }template <> struct geometric_traits<detail::matrix_short_8x2_column1> { typedef detail::matrix_short_8x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x2>::type > : index_operator_matrix_access_policy < matrix_short_8x2 > { typedef index_operator_matrix_access_policy < matrix_short_8x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x2 > { typedef dimension<8> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 3> matrix_short_8x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,0> matrix_short_8x3_row0; } template <> struct geometric_traits<detail::matrix_short_8x3_row0> { typedef detail::matrix_short_8x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,1> matrix_short_8x3_row1; } template <> struct geometric_traits<detail::matrix_short_8x3_row1> { typedef detail::matrix_short_8x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,2> matrix_short_8x3_row2; } template <> struct geometric_traits<detail::matrix_short_8x3_row2> { typedef detail::matrix_short_8x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,3> matrix_short_8x3_row3; } template <> struct geometric_traits<detail::matrix_short_8x3_row3> { typedef detail::matrix_short_8x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,4> matrix_short_8x3_row4; } template <> struct geometric_traits<detail::matrix_short_8x3_row4> { typedef detail::matrix_short_8x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,5> matrix_short_8x3_row5; } template <> struct geometric_traits<detail::matrix_short_8x3_row5> { typedef detail::matrix_short_8x3_row5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,6> matrix_short_8x3_row6; } template <> struct geometric_traits<detail::matrix_short_8x3_row6> { typedef detail::matrix_short_8x3_row6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x3,7> matrix_short_8x3_row7; } template <> struct geometric_traits<detail::matrix_short_8x3_row7> { typedef detail::matrix_short_8x3_row7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x3,0> matrix_short_8x3_column0; }template <> struct geometric_traits<detail::matrix_short_8x3_column0> { typedef detail::matrix_short_8x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x3,1> matrix_short_8x3_column1; }template <> struct geometric_traits<detail::matrix_short_8x3_column1> { typedef detail::matrix_short_8x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x3,2> matrix_short_8x3_column2; }template <> struct geometric_traits<detail::matrix_short_8x3_column2> { typedef detail::matrix_short_8x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x3>::type > : index_operator_matrix_access_policy < matrix_short_8x3 > { typedef index_operator_matrix_access_policy < matrix_short_8x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x3 > { typedef dimension<8> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 4> matrix_short_8x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,0> matrix_short_8x4_row0; } template <> struct geometric_traits<detail::matrix_short_8x4_row0> { typedef detail::matrix_short_8x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,1> matrix_short_8x4_row1; } template <> struct geometric_traits<detail::matrix_short_8x4_row1> { typedef detail::matrix_short_8x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,2> matrix_short_8x4_row2; } template <> struct geometric_traits<detail::matrix_short_8x4_row2> { typedef detail::matrix_short_8x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,3> matrix_short_8x4_row3; } template <> struct geometric_traits<detail::matrix_short_8x4_row3> { typedef detail::matrix_short_8x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,4> matrix_short_8x4_row4; } template <> struct geometric_traits<detail::matrix_short_8x4_row4> { typedef detail::matrix_short_8x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,5> matrix_short_8x4_row5; } template <> struct geometric_traits<detail::matrix_short_8x4_row5> { typedef detail::matrix_short_8x4_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,6> matrix_short_8x4_row6; } template <> struct geometric_traits<detail::matrix_short_8x4_row6> { typedef detail::matrix_short_8x4_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x4,7> matrix_short_8x4_row7; } template <> struct geometric_traits<detail::matrix_short_8x4_row7> { typedef detail::matrix_short_8x4_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x4,0> matrix_short_8x4_column0; }template <> struct geometric_traits<detail::matrix_short_8x4_column0> { typedef detail::matrix_short_8x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x4,1> matrix_short_8x4_column1; }template <> struct geometric_traits<detail::matrix_short_8x4_column1> { typedef detail::matrix_short_8x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x4,2> matrix_short_8x4_column2; }template <> struct geometric_traits<detail::matrix_short_8x4_column2> { typedef detail::matrix_short_8x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x4,3> matrix_short_8x4_column3; }template <> struct geometric_traits<detail::matrix_short_8x4_column3> { typedef detail::matrix_short_8x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x4>::type > : index_operator_matrix_access_policy < matrix_short_8x4 > { typedef index_operator_matrix_access_policy < matrix_short_8x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x4 > { typedef dimension<8> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 5> matrix_short_8x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,0> matrix_short_8x5_row0; } template <> struct geometric_traits<detail::matrix_short_8x5_row0> { typedef detail::matrix_short_8x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,1> matrix_short_8x5_row1; } template <> struct geometric_traits<detail::matrix_short_8x5_row1> { typedef detail::matrix_short_8x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,2> matrix_short_8x5_row2; } template <> struct geometric_traits<detail::matrix_short_8x5_row2> { typedef detail::matrix_short_8x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,3> matrix_short_8x5_row3; } template <> struct geometric_traits<detail::matrix_short_8x5_row3> { typedef detail::matrix_short_8x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,4> matrix_short_8x5_row4; } template <> struct geometric_traits<detail::matrix_short_8x5_row4> { typedef detail::matrix_short_8x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,5> matrix_short_8x5_row5; } template <> struct geometric_traits<detail::matrix_short_8x5_row5> { typedef detail::matrix_short_8x5_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,6> matrix_short_8x5_row6; } template <> struct geometric_traits<detail::matrix_short_8x5_row6> { typedef detail::matrix_short_8x5_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x5,7> matrix_short_8x5_row7; } template <> struct geometric_traits<detail::matrix_short_8x5_row7> { typedef detail::matrix_short_8x5_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x5,0> matrix_short_8x5_column0; }template <> struct geometric_traits<detail::matrix_short_8x5_column0> { typedef detail::matrix_short_8x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x5,1> matrix_short_8x5_column1; }template <> struct geometric_traits<detail::matrix_short_8x5_column1> { typedef detail::matrix_short_8x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x5,2> matrix_short_8x5_column2; }template <> struct geometric_traits<detail::matrix_short_8x5_column2> { typedef detail::matrix_short_8x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x5,3> matrix_short_8x5_column3; }template <> struct geometric_traits<detail::matrix_short_8x5_column3> { typedef detail::matrix_short_8x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x5,4> matrix_short_8x5_column4; }template <> struct geometric_traits<detail::matrix_short_8x5_column4> { typedef detail::matrix_short_8x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x5>::type > : index_operator_matrix_access_policy < matrix_short_8x5 > { typedef index_operator_matrix_access_policy < matrix_short_8x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x5 > { typedef dimension<8> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 6> matrix_short_8x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,0> matrix_short_8x6_row0; } template <> struct geometric_traits<detail::matrix_short_8x6_row0> { typedef detail::matrix_short_8x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,1> matrix_short_8x6_row1; } template <> struct geometric_traits<detail::matrix_short_8x6_row1> { typedef detail::matrix_short_8x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,2> matrix_short_8x6_row2; } template <> struct geometric_traits<detail::matrix_short_8x6_row2> { typedef detail::matrix_short_8x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,3> matrix_short_8x6_row3; } template <> struct geometric_traits<detail::matrix_short_8x6_row3> { typedef detail::matrix_short_8x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,4> matrix_short_8x6_row4; } template <> struct geometric_traits<detail::matrix_short_8x6_row4> { typedef detail::matrix_short_8x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,5> matrix_short_8x6_row5; } template <> struct geometric_traits<detail::matrix_short_8x6_row5> { typedef detail::matrix_short_8x6_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,6> matrix_short_8x6_row6; } template <> struct geometric_traits<detail::matrix_short_8x6_row6> { typedef detail::matrix_short_8x6_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x6,7> matrix_short_8x6_row7; } template <> struct geometric_traits<detail::matrix_short_8x6_row7> { typedef detail::matrix_short_8x6_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,0> matrix_short_8x6_column0; }template <> struct geometric_traits<detail::matrix_short_8x6_column0> { typedef detail::matrix_short_8x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,1> matrix_short_8x6_column1; }template <> struct geometric_traits<detail::matrix_short_8x6_column1> { typedef detail::matrix_short_8x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,2> matrix_short_8x6_column2; }template <> struct geometric_traits<detail::matrix_short_8x6_column2> { typedef detail::matrix_short_8x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,3> matrix_short_8x6_column3; }template <> struct geometric_traits<detail::matrix_short_8x6_column3> { typedef detail::matrix_short_8x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,4> matrix_short_8x6_column4; }template <> struct geometric_traits<detail::matrix_short_8x6_column4> { typedef detail::matrix_short_8x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x6,5> matrix_short_8x6_column5; }template <> struct geometric_traits<detail::matrix_short_8x6_column5> { typedef detail::matrix_short_8x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x6>::type > : index_operator_matrix_access_policy < matrix_short_8x6 > { typedef index_operator_matrix_access_policy < matrix_short_8x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x6 > { typedef dimension<8> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 7> matrix_short_8x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,0> matrix_short_8x7_row0; } template <> struct geometric_traits<detail::matrix_short_8x7_row0> { typedef detail::matrix_short_8x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,1> matrix_short_8x7_row1; } template <> struct geometric_traits<detail::matrix_short_8x7_row1> { typedef detail::matrix_short_8x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,2> matrix_short_8x7_row2; } template <> struct geometric_traits<detail::matrix_short_8x7_row2> { typedef detail::matrix_short_8x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,3> matrix_short_8x7_row3; } template <> struct geometric_traits<detail::matrix_short_8x7_row3> { typedef detail::matrix_short_8x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,4> matrix_short_8x7_row4; } template <> struct geometric_traits<detail::matrix_short_8x7_row4> { typedef detail::matrix_short_8x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,5> matrix_short_8x7_row5; } template <> struct geometric_traits<detail::matrix_short_8x7_row5> { typedef detail::matrix_short_8x7_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,6> matrix_short_8x7_row6; } template <> struct geometric_traits<detail::matrix_short_8x7_row6> { typedef detail::matrix_short_8x7_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x7,7> matrix_short_8x7_row7; } template <> struct geometric_traits<detail::matrix_short_8x7_row7> { typedef detail::matrix_short_8x7_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,0> matrix_short_8x7_column0; }template <> struct geometric_traits<detail::matrix_short_8x7_column0> { typedef detail::matrix_short_8x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,1> matrix_short_8x7_column1; }template <> struct geometric_traits<detail::matrix_short_8x7_column1> { typedef detail::matrix_short_8x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,2> matrix_short_8x7_column2; }template <> struct geometric_traits<detail::matrix_short_8x7_column2> { typedef detail::matrix_short_8x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,3> matrix_short_8x7_column3; }template <> struct geometric_traits<detail::matrix_short_8x7_column3> { typedef detail::matrix_short_8x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,4> matrix_short_8x7_column4; }template <> struct geometric_traits<detail::matrix_short_8x7_column4> { typedef detail::matrix_short_8x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,5> matrix_short_8x7_column5; }template <> struct geometric_traits<detail::matrix_short_8x7_column5> { typedef detail::matrix_short_8x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x7,6> matrix_short_8x7_column6; }template <> struct geometric_traits<detail::matrix_short_8x7_column6> { typedef detail::matrix_short_8x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x7>::type > : index_operator_matrix_access_policy < matrix_short_8x7 > { typedef index_operator_matrix_access_policy < matrix_short_8x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x7 > { typedef dimension<8> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 8> matrix_short_8x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,0> matrix_short_8x8_row0; } template <> struct geometric_traits<detail::matrix_short_8x8_row0> { typedef detail::matrix_short_8x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,1> matrix_short_8x8_row1; } template <> struct geometric_traits<detail::matrix_short_8x8_row1> { typedef detail::matrix_short_8x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,2> matrix_short_8x8_row2; } template <> struct geometric_traits<detail::matrix_short_8x8_row2> { typedef detail::matrix_short_8x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,3> matrix_short_8x8_row3; } template <> struct geometric_traits<detail::matrix_short_8x8_row3> { typedef detail::matrix_short_8x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,4> matrix_short_8x8_row4; } template <> struct geometric_traits<detail::matrix_short_8x8_row4> { typedef detail::matrix_short_8x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,5> matrix_short_8x8_row5; } template <> struct geometric_traits<detail::matrix_short_8x8_row5> { typedef detail::matrix_short_8x8_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,6> matrix_short_8x8_row6; } template <> struct geometric_traits<detail::matrix_short_8x8_row6> { typedef detail::matrix_short_8x8_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x8,7> matrix_short_8x8_row7; } template <> struct geometric_traits<detail::matrix_short_8x8_row7> { typedef detail::matrix_short_8x8_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,0> matrix_short_8x8_column0; }template <> struct geometric_traits<detail::matrix_short_8x8_column0> { typedef detail::matrix_short_8x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,1> matrix_short_8x8_column1; }template <> struct geometric_traits<detail::matrix_short_8x8_column1> { typedef detail::matrix_short_8x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,2> matrix_short_8x8_column2; }template <> struct geometric_traits<detail::matrix_short_8x8_column2> { typedef detail::matrix_short_8x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,3> matrix_short_8x8_column3; }template <> struct geometric_traits<detail::matrix_short_8x8_column3> { typedef detail::matrix_short_8x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,4> matrix_short_8x8_column4; }template <> struct geometric_traits<detail::matrix_short_8x8_column4> { typedef detail::matrix_short_8x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,5> matrix_short_8x8_column5; }template <> struct geometric_traits<detail::matrix_short_8x8_column5> { typedef detail::matrix_short_8x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,6> matrix_short_8x8_column6; }template <> struct geometric_traits<detail::matrix_short_8x8_column6> { typedef detail::matrix_short_8x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x8,7> matrix_short_8x8_column7; }template <> struct geometric_traits<detail::matrix_short_8x8_column7> { typedef detail::matrix_short_8x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x8>::type > : index_operator_matrix_access_policy < matrix_short_8x8 > { typedef index_operator_matrix_access_policy < matrix_short_8x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x8 > { typedef dimension<8> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 9> matrix_short_8x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,0> matrix_short_8x9_row0; } template <> struct geometric_traits<detail::matrix_short_8x9_row0> { typedef detail::matrix_short_8x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,1> matrix_short_8x9_row1; } template <> struct geometric_traits<detail::matrix_short_8x9_row1> { typedef detail::matrix_short_8x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,2> matrix_short_8x9_row2; } template <> struct geometric_traits<detail::matrix_short_8x9_row2> { typedef detail::matrix_short_8x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,3> matrix_short_8x9_row3; } template <> struct geometric_traits<detail::matrix_short_8x9_row3> { typedef detail::matrix_short_8x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,4> matrix_short_8x9_row4; } template <> struct geometric_traits<detail::matrix_short_8x9_row4> { typedef detail::matrix_short_8x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,5> matrix_short_8x9_row5; } template <> struct geometric_traits<detail::matrix_short_8x9_row5> { typedef detail::matrix_short_8x9_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,6> matrix_short_8x9_row6; } template <> struct geometric_traits<detail::matrix_short_8x9_row6> { typedef detail::matrix_short_8x9_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x9,7> matrix_short_8x9_row7; } template <> struct geometric_traits<detail::matrix_short_8x9_row7> { typedef detail::matrix_short_8x9_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,0> matrix_short_8x9_column0; }template <> struct geometric_traits<detail::matrix_short_8x9_column0> { typedef detail::matrix_short_8x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,1> matrix_short_8x9_column1; }template <> struct geometric_traits<detail::matrix_short_8x9_column1> { typedef detail::matrix_short_8x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,2> matrix_short_8x9_column2; }template <> struct geometric_traits<detail::matrix_short_8x9_column2> { typedef detail::matrix_short_8x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,3> matrix_short_8x9_column3; }template <> struct geometric_traits<detail::matrix_short_8x9_column3> { typedef detail::matrix_short_8x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,4> matrix_short_8x9_column4; }template <> struct geometric_traits<detail::matrix_short_8x9_column4> { typedef detail::matrix_short_8x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,5> matrix_short_8x9_column5; }template <> struct geometric_traits<detail::matrix_short_8x9_column5> { typedef detail::matrix_short_8x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,6> matrix_short_8x9_column6; }template <> struct geometric_traits<detail::matrix_short_8x9_column6> { typedef detail::matrix_short_8x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,7> matrix_short_8x9_column7; }template <> struct geometric_traits<detail::matrix_short_8x9_column7> { typedef detail::matrix_short_8x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x9,8> matrix_short_8x9_column8; }template <> struct geometric_traits<detail::matrix_short_8x9_column8> { typedef detail::matrix_short_8x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x9>::type > : index_operator_matrix_access_policy < matrix_short_8x9 > { typedef index_operator_matrix_access_policy < matrix_short_8x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x9 > { typedef dimension<8> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 8, 10> matrix_short_8x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,0> matrix_short_8x10_row0; } template <> struct geometric_traits<detail::matrix_short_8x10_row0> { typedef detail::matrix_short_8x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,1> matrix_short_8x10_row1; } template <> struct geometric_traits<detail::matrix_short_8x10_row1> { typedef detail::matrix_short_8x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,2> matrix_short_8x10_row2; } template <> struct geometric_traits<detail::matrix_short_8x10_row2> { typedef detail::matrix_short_8x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,3> matrix_short_8x10_row3; } template <> struct geometric_traits<detail::matrix_short_8x10_row3> { typedef detail::matrix_short_8x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,4> matrix_short_8x10_row4; } template <> struct geometric_traits<detail::matrix_short_8x10_row4> { typedef detail::matrix_short_8x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,5> matrix_short_8x10_row5; } template <> struct geometric_traits<detail::matrix_short_8x10_row5> { typedef detail::matrix_short_8x10_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,6> matrix_short_8x10_row6; } template <> struct geometric_traits<detail::matrix_short_8x10_row6> { typedef detail::matrix_short_8x10_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_8x10,7> matrix_short_8x10_row7; } template <> struct geometric_traits<detail::matrix_short_8x10_row7> { typedef detail::matrix_short_8x10_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,0> matrix_short_8x10_column0; }template <> struct geometric_traits<detail::matrix_short_8x10_column0> { typedef detail::matrix_short_8x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,1> matrix_short_8x10_column1; }template <> struct geometric_traits<detail::matrix_short_8x10_column1> { typedef detail::matrix_short_8x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,2> matrix_short_8x10_column2; }template <> struct geometric_traits<detail::matrix_short_8x10_column2> { typedef detail::matrix_short_8x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,3> matrix_short_8x10_column3; }template <> struct geometric_traits<detail::matrix_short_8x10_column3> { typedef detail::matrix_short_8x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,4> matrix_short_8x10_column4; }template <> struct geometric_traits<detail::matrix_short_8x10_column4> { typedef detail::matrix_short_8x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,5> matrix_short_8x10_column5; }template <> struct geometric_traits<detail::matrix_short_8x10_column5> { typedef detail::matrix_short_8x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,6> matrix_short_8x10_column6; }template <> struct geometric_traits<detail::matrix_short_8x10_column6> { typedef detail::matrix_short_8x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,7> matrix_short_8x10_column7; }template <> struct geometric_traits<detail::matrix_short_8x10_column7> { typedef detail::matrix_short_8x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,8> matrix_short_8x10_column8; }template <> struct geometric_traits<detail::matrix_short_8x10_column8> { typedef detail::matrix_short_8x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_8x10,9> matrix_short_8x10_column9; }template <> struct geometric_traits<detail::matrix_short_8x10_column9> { typedef detail::matrix_short_8x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_8x10>::type > : index_operator_matrix_access_policy < matrix_short_8x10 > { typedef index_operator_matrix_access_policy < matrix_short_8x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_8x10 > { typedef dimension<8> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 1> matrix_short_9x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,0> matrix_short_9x1_row0; } template <> struct geometric_traits<detail::matrix_short_9x1_row0> { typedef detail::matrix_short_9x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,1> matrix_short_9x1_row1; } template <> struct geometric_traits<detail::matrix_short_9x1_row1> { typedef detail::matrix_short_9x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,2> matrix_short_9x1_row2; } template <> struct geometric_traits<detail::matrix_short_9x1_row2> { typedef detail::matrix_short_9x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,3> matrix_short_9x1_row3; } template <> struct geometric_traits<detail::matrix_short_9x1_row3> { typedef detail::matrix_short_9x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,4> matrix_short_9x1_row4; } template <> struct geometric_traits<detail::matrix_short_9x1_row4> { typedef detail::matrix_short_9x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,5> matrix_short_9x1_row5; } template <> struct geometric_traits<detail::matrix_short_9x1_row5> { typedef detail::matrix_short_9x1_row5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,6> matrix_short_9x1_row6; } template <> struct geometric_traits<detail::matrix_short_9x1_row6> { typedef detail::matrix_short_9x1_row6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,7> matrix_short_9x1_row7; } template <> struct geometric_traits<detail::matrix_short_9x1_row7> { typedef detail::matrix_short_9x1_row7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x1,8> matrix_short_9x1_row8; } template <> struct geometric_traits<detail::matrix_short_9x1_row8> { typedef detail::matrix_short_9x1_row8 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x1,0> matrix_short_9x1_column0; }template <> struct geometric_traits<detail::matrix_short_9x1_column0> { typedef detail::matrix_short_9x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x1>::type > : index_operator_matrix_access_policy < matrix_short_9x1 > { typedef index_operator_matrix_access_policy < matrix_short_9x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x1 > { typedef dimension<9> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 2> matrix_short_9x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,0> matrix_short_9x2_row0; } template <> struct geometric_traits<detail::matrix_short_9x2_row0> { typedef detail::matrix_short_9x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,1> matrix_short_9x2_row1; } template <> struct geometric_traits<detail::matrix_short_9x2_row1> { typedef detail::matrix_short_9x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,2> matrix_short_9x2_row2; } template <> struct geometric_traits<detail::matrix_short_9x2_row2> { typedef detail::matrix_short_9x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,3> matrix_short_9x2_row3; } template <> struct geometric_traits<detail::matrix_short_9x2_row3> { typedef detail::matrix_short_9x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,4> matrix_short_9x2_row4; } template <> struct geometric_traits<detail::matrix_short_9x2_row4> { typedef detail::matrix_short_9x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,5> matrix_short_9x2_row5; } template <> struct geometric_traits<detail::matrix_short_9x2_row5> { typedef detail::matrix_short_9x2_row5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,6> matrix_short_9x2_row6; } template <> struct geometric_traits<detail::matrix_short_9x2_row6> { typedef detail::matrix_short_9x2_row6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,7> matrix_short_9x2_row7; } template <> struct geometric_traits<detail::matrix_short_9x2_row7> { typedef detail::matrix_short_9x2_row7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x2,8> matrix_short_9x2_row8; } template <> struct geometric_traits<detail::matrix_short_9x2_row8> { typedef detail::matrix_short_9x2_row8 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x2,0> matrix_short_9x2_column0; }template <> struct geometric_traits<detail::matrix_short_9x2_column0> { typedef detail::matrix_short_9x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x2,1> matrix_short_9x2_column1; }template <> struct geometric_traits<detail::matrix_short_9x2_column1> { typedef detail::matrix_short_9x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x2>::type > : index_operator_matrix_access_policy < matrix_short_9x2 > { typedef index_operator_matrix_access_policy < matrix_short_9x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x2 > { typedef dimension<9> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 3> matrix_short_9x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,0> matrix_short_9x3_row0; } template <> struct geometric_traits<detail::matrix_short_9x3_row0> { typedef detail::matrix_short_9x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,1> matrix_short_9x3_row1; } template <> struct geometric_traits<detail::matrix_short_9x3_row1> { typedef detail::matrix_short_9x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,2> matrix_short_9x3_row2; } template <> struct geometric_traits<detail::matrix_short_9x3_row2> { typedef detail::matrix_short_9x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,3> matrix_short_9x3_row3; } template <> struct geometric_traits<detail::matrix_short_9x3_row3> { typedef detail::matrix_short_9x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,4> matrix_short_9x3_row4; } template <> struct geometric_traits<detail::matrix_short_9x3_row4> { typedef detail::matrix_short_9x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,5> matrix_short_9x3_row5; } template <> struct geometric_traits<detail::matrix_short_9x3_row5> { typedef detail::matrix_short_9x3_row5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,6> matrix_short_9x3_row6; } template <> struct geometric_traits<detail::matrix_short_9x3_row6> { typedef detail::matrix_short_9x3_row6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,7> matrix_short_9x3_row7; } template <> struct geometric_traits<detail::matrix_short_9x3_row7> { typedef detail::matrix_short_9x3_row7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x3,8> matrix_short_9x3_row8; } template <> struct geometric_traits<detail::matrix_short_9x3_row8> { typedef detail::matrix_short_9x3_row8 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x3,0> matrix_short_9x3_column0; }template <> struct geometric_traits<detail::matrix_short_9x3_column0> { typedef detail::matrix_short_9x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x3,1> matrix_short_9x3_column1; }template <> struct geometric_traits<detail::matrix_short_9x3_column1> { typedef detail::matrix_short_9x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x3,2> matrix_short_9x3_column2; }template <> struct geometric_traits<detail::matrix_short_9x3_column2> { typedef detail::matrix_short_9x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x3>::type > : index_operator_matrix_access_policy < matrix_short_9x3 > { typedef index_operator_matrix_access_policy < matrix_short_9x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x3 > { typedef dimension<9> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 4> matrix_short_9x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,0> matrix_short_9x4_row0; } template <> struct geometric_traits<detail::matrix_short_9x4_row0> { typedef detail::matrix_short_9x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,1> matrix_short_9x4_row1; } template <> struct geometric_traits<detail::matrix_short_9x4_row1> { typedef detail::matrix_short_9x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,2> matrix_short_9x4_row2; } template <> struct geometric_traits<detail::matrix_short_9x4_row2> { typedef detail::matrix_short_9x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,3> matrix_short_9x4_row3; } template <> struct geometric_traits<detail::matrix_short_9x4_row3> { typedef detail::matrix_short_9x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,4> matrix_short_9x4_row4; } template <> struct geometric_traits<detail::matrix_short_9x4_row4> { typedef detail::matrix_short_9x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,5> matrix_short_9x4_row5; } template <> struct geometric_traits<detail::matrix_short_9x4_row5> { typedef detail::matrix_short_9x4_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,6> matrix_short_9x4_row6; } template <> struct geometric_traits<detail::matrix_short_9x4_row6> { typedef detail::matrix_short_9x4_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,7> matrix_short_9x4_row7; } template <> struct geometric_traits<detail::matrix_short_9x4_row7> { typedef detail::matrix_short_9x4_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x4,8> matrix_short_9x4_row8; } template <> struct geometric_traits<detail::matrix_short_9x4_row8> { typedef detail::matrix_short_9x4_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x4,0> matrix_short_9x4_column0; }template <> struct geometric_traits<detail::matrix_short_9x4_column0> { typedef detail::matrix_short_9x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x4,1> matrix_short_9x4_column1; }template <> struct geometric_traits<detail::matrix_short_9x4_column1> { typedef detail::matrix_short_9x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x4,2> matrix_short_9x4_column2; }template <> struct geometric_traits<detail::matrix_short_9x4_column2> { typedef detail::matrix_short_9x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x4,3> matrix_short_9x4_column3; }template <> struct geometric_traits<detail::matrix_short_9x4_column3> { typedef detail::matrix_short_9x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x4>::type > : index_operator_matrix_access_policy < matrix_short_9x4 > { typedef index_operator_matrix_access_policy < matrix_short_9x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x4 > { typedef dimension<9> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 5> matrix_short_9x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,0> matrix_short_9x5_row0; } template <> struct geometric_traits<detail::matrix_short_9x5_row0> { typedef detail::matrix_short_9x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,1> matrix_short_9x5_row1; } template <> struct geometric_traits<detail::matrix_short_9x5_row1> { typedef detail::matrix_short_9x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,2> matrix_short_9x5_row2; } template <> struct geometric_traits<detail::matrix_short_9x5_row2> { typedef detail::matrix_short_9x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,3> matrix_short_9x5_row3; } template <> struct geometric_traits<detail::matrix_short_9x5_row3> { typedef detail::matrix_short_9x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,4> matrix_short_9x5_row4; } template <> struct geometric_traits<detail::matrix_short_9x5_row4> { typedef detail::matrix_short_9x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,5> matrix_short_9x5_row5; } template <> struct geometric_traits<detail::matrix_short_9x5_row5> { typedef detail::matrix_short_9x5_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,6> matrix_short_9x5_row6; } template <> struct geometric_traits<detail::matrix_short_9x5_row6> { typedef detail::matrix_short_9x5_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,7> matrix_short_9x5_row7; } template <> struct geometric_traits<detail::matrix_short_9x5_row7> { typedef detail::matrix_short_9x5_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x5,8> matrix_short_9x5_row8; } template <> struct geometric_traits<detail::matrix_short_9x5_row8> { typedef detail::matrix_short_9x5_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x5,0> matrix_short_9x5_column0; }template <> struct geometric_traits<detail::matrix_short_9x5_column0> { typedef detail::matrix_short_9x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x5,1> matrix_short_9x5_column1; }template <> struct geometric_traits<detail::matrix_short_9x5_column1> { typedef detail::matrix_short_9x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x5,2> matrix_short_9x5_column2; }template <> struct geometric_traits<detail::matrix_short_9x5_column2> { typedef detail::matrix_short_9x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x5,3> matrix_short_9x5_column3; }template <> struct geometric_traits<detail::matrix_short_9x5_column3> { typedef detail::matrix_short_9x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x5,4> matrix_short_9x5_column4; }template <> struct geometric_traits<detail::matrix_short_9x5_column4> { typedef detail::matrix_short_9x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x5>::type > : index_operator_matrix_access_policy < matrix_short_9x5 > { typedef index_operator_matrix_access_policy < matrix_short_9x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x5 > { typedef dimension<9> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 6> matrix_short_9x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,0> matrix_short_9x6_row0; } template <> struct geometric_traits<detail::matrix_short_9x6_row0> { typedef detail::matrix_short_9x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,1> matrix_short_9x6_row1; } template <> struct geometric_traits<detail::matrix_short_9x6_row1> { typedef detail::matrix_short_9x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,2> matrix_short_9x6_row2; } template <> struct geometric_traits<detail::matrix_short_9x6_row2> { typedef detail::matrix_short_9x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,3> matrix_short_9x6_row3; } template <> struct geometric_traits<detail::matrix_short_9x6_row3> { typedef detail::matrix_short_9x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,4> matrix_short_9x6_row4; } template <> struct geometric_traits<detail::matrix_short_9x6_row4> { typedef detail::matrix_short_9x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,5> matrix_short_9x6_row5; } template <> struct geometric_traits<detail::matrix_short_9x6_row5> { typedef detail::matrix_short_9x6_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,6> matrix_short_9x6_row6; } template <> struct geometric_traits<detail::matrix_short_9x6_row6> { typedef detail::matrix_short_9x6_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,7> matrix_short_9x6_row7; } template <> struct geometric_traits<detail::matrix_short_9x6_row7> { typedef detail::matrix_short_9x6_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x6,8> matrix_short_9x6_row8; } template <> struct geometric_traits<detail::matrix_short_9x6_row8> { typedef detail::matrix_short_9x6_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,0> matrix_short_9x6_column0; }template <> struct geometric_traits<detail::matrix_short_9x6_column0> { typedef detail::matrix_short_9x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,1> matrix_short_9x6_column1; }template <> struct geometric_traits<detail::matrix_short_9x6_column1> { typedef detail::matrix_short_9x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,2> matrix_short_9x6_column2; }template <> struct geometric_traits<detail::matrix_short_9x6_column2> { typedef detail::matrix_short_9x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,3> matrix_short_9x6_column3; }template <> struct geometric_traits<detail::matrix_short_9x6_column3> { typedef detail::matrix_short_9x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,4> matrix_short_9x6_column4; }template <> struct geometric_traits<detail::matrix_short_9x6_column4> { typedef detail::matrix_short_9x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x6,5> matrix_short_9x6_column5; }template <> struct geometric_traits<detail::matrix_short_9x6_column5> { typedef detail::matrix_short_9x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x6>::type > : index_operator_matrix_access_policy < matrix_short_9x6 > { typedef index_operator_matrix_access_policy < matrix_short_9x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x6 > { typedef dimension<9> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 7> matrix_short_9x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,0> matrix_short_9x7_row0; } template <> struct geometric_traits<detail::matrix_short_9x7_row0> { typedef detail::matrix_short_9x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,1> matrix_short_9x7_row1; } template <> struct geometric_traits<detail::matrix_short_9x7_row1> { typedef detail::matrix_short_9x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,2> matrix_short_9x7_row2; } template <> struct geometric_traits<detail::matrix_short_9x7_row2> { typedef detail::matrix_short_9x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,3> matrix_short_9x7_row3; } template <> struct geometric_traits<detail::matrix_short_9x7_row3> { typedef detail::matrix_short_9x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,4> matrix_short_9x7_row4; } template <> struct geometric_traits<detail::matrix_short_9x7_row4> { typedef detail::matrix_short_9x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,5> matrix_short_9x7_row5; } template <> struct geometric_traits<detail::matrix_short_9x7_row5> { typedef detail::matrix_short_9x7_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,6> matrix_short_9x7_row6; } template <> struct geometric_traits<detail::matrix_short_9x7_row6> { typedef detail::matrix_short_9x7_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,7> matrix_short_9x7_row7; } template <> struct geometric_traits<detail::matrix_short_9x7_row7> { typedef detail::matrix_short_9x7_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x7,8> matrix_short_9x7_row8; } template <> struct geometric_traits<detail::matrix_short_9x7_row8> { typedef detail::matrix_short_9x7_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,0> matrix_short_9x7_column0; }template <> struct geometric_traits<detail::matrix_short_9x7_column0> { typedef detail::matrix_short_9x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,1> matrix_short_9x7_column1; }template <> struct geometric_traits<detail::matrix_short_9x7_column1> { typedef detail::matrix_short_9x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,2> matrix_short_9x7_column2; }template <> struct geometric_traits<detail::matrix_short_9x7_column2> { typedef detail::matrix_short_9x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,3> matrix_short_9x7_column3; }template <> struct geometric_traits<detail::matrix_short_9x7_column3> { typedef detail::matrix_short_9x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,4> matrix_short_9x7_column4; }template <> struct geometric_traits<detail::matrix_short_9x7_column4> { typedef detail::matrix_short_9x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,5> matrix_short_9x7_column5; }template <> struct geometric_traits<detail::matrix_short_9x7_column5> { typedef detail::matrix_short_9x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x7,6> matrix_short_9x7_column6; }template <> struct geometric_traits<detail::matrix_short_9x7_column6> { typedef detail::matrix_short_9x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x7>::type > : index_operator_matrix_access_policy < matrix_short_9x7 > { typedef index_operator_matrix_access_policy < matrix_short_9x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x7 > { typedef dimension<9> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 8> matrix_short_9x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,0> matrix_short_9x8_row0; } template <> struct geometric_traits<detail::matrix_short_9x8_row0> { typedef detail::matrix_short_9x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,1> matrix_short_9x8_row1; } template <> struct geometric_traits<detail::matrix_short_9x8_row1> { typedef detail::matrix_short_9x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,2> matrix_short_9x8_row2; } template <> struct geometric_traits<detail::matrix_short_9x8_row2> { typedef detail::matrix_short_9x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,3> matrix_short_9x8_row3; } template <> struct geometric_traits<detail::matrix_short_9x8_row3> { typedef detail::matrix_short_9x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,4> matrix_short_9x8_row4; } template <> struct geometric_traits<detail::matrix_short_9x8_row4> { typedef detail::matrix_short_9x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,5> matrix_short_9x8_row5; } template <> struct geometric_traits<detail::matrix_short_9x8_row5> { typedef detail::matrix_short_9x8_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,6> matrix_short_9x8_row6; } template <> struct geometric_traits<detail::matrix_short_9x8_row6> { typedef detail::matrix_short_9x8_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,7> matrix_short_9x8_row7; } template <> struct geometric_traits<detail::matrix_short_9x8_row7> { typedef detail::matrix_short_9x8_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x8,8> matrix_short_9x8_row8; } template <> struct geometric_traits<detail::matrix_short_9x8_row8> { typedef detail::matrix_short_9x8_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,0> matrix_short_9x8_column0; }template <> struct geometric_traits<detail::matrix_short_9x8_column0> { typedef detail::matrix_short_9x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,1> matrix_short_9x8_column1; }template <> struct geometric_traits<detail::matrix_short_9x8_column1> { typedef detail::matrix_short_9x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,2> matrix_short_9x8_column2; }template <> struct geometric_traits<detail::matrix_short_9x8_column2> { typedef detail::matrix_short_9x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,3> matrix_short_9x8_column3; }template <> struct geometric_traits<detail::matrix_short_9x8_column3> { typedef detail::matrix_short_9x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,4> matrix_short_9x8_column4; }template <> struct geometric_traits<detail::matrix_short_9x8_column4> { typedef detail::matrix_short_9x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,5> matrix_short_9x8_column5; }template <> struct geometric_traits<detail::matrix_short_9x8_column5> { typedef detail::matrix_short_9x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,6> matrix_short_9x8_column6; }template <> struct geometric_traits<detail::matrix_short_9x8_column6> { typedef detail::matrix_short_9x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x8,7> matrix_short_9x8_column7; }template <> struct geometric_traits<detail::matrix_short_9x8_column7> { typedef detail::matrix_short_9x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x8>::type > : index_operator_matrix_access_policy < matrix_short_9x8 > { typedef index_operator_matrix_access_policy < matrix_short_9x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x8 > { typedef dimension<9> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 9> matrix_short_9x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,0> matrix_short_9x9_row0; } template <> struct geometric_traits<detail::matrix_short_9x9_row0> { typedef detail::matrix_short_9x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,1> matrix_short_9x9_row1; } template <> struct geometric_traits<detail::matrix_short_9x9_row1> { typedef detail::matrix_short_9x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,2> matrix_short_9x9_row2; } template <> struct geometric_traits<detail::matrix_short_9x9_row2> { typedef detail::matrix_short_9x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,3> matrix_short_9x9_row3; } template <> struct geometric_traits<detail::matrix_short_9x9_row3> { typedef detail::matrix_short_9x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,4> matrix_short_9x9_row4; } template <> struct geometric_traits<detail::matrix_short_9x9_row4> { typedef detail::matrix_short_9x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,5> matrix_short_9x9_row5; } template <> struct geometric_traits<detail::matrix_short_9x9_row5> { typedef detail::matrix_short_9x9_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,6> matrix_short_9x9_row6; } template <> struct geometric_traits<detail::matrix_short_9x9_row6> { typedef detail::matrix_short_9x9_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,7> matrix_short_9x9_row7; } template <> struct geometric_traits<detail::matrix_short_9x9_row7> { typedef detail::matrix_short_9x9_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x9,8> matrix_short_9x9_row8; } template <> struct geometric_traits<detail::matrix_short_9x9_row8> { typedef detail::matrix_short_9x9_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,0> matrix_short_9x9_column0; }template <> struct geometric_traits<detail::matrix_short_9x9_column0> { typedef detail::matrix_short_9x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,1> matrix_short_9x9_column1; }template <> struct geometric_traits<detail::matrix_short_9x9_column1> { typedef detail::matrix_short_9x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,2> matrix_short_9x9_column2; }template <> struct geometric_traits<detail::matrix_short_9x9_column2> { typedef detail::matrix_short_9x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,3> matrix_short_9x9_column3; }template <> struct geometric_traits<detail::matrix_short_9x9_column3> { typedef detail::matrix_short_9x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,4> matrix_short_9x9_column4; }template <> struct geometric_traits<detail::matrix_short_9x9_column4> { typedef detail::matrix_short_9x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,5> matrix_short_9x9_column5; }template <> struct geometric_traits<detail::matrix_short_9x9_column5> { typedef detail::matrix_short_9x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,6> matrix_short_9x9_column6; }template <> struct geometric_traits<detail::matrix_short_9x9_column6> { typedef detail::matrix_short_9x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,7> matrix_short_9x9_column7; }template <> struct geometric_traits<detail::matrix_short_9x9_column7> { typedef detail::matrix_short_9x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x9,8> matrix_short_9x9_column8; }template <> struct geometric_traits<detail::matrix_short_9x9_column8> { typedef detail::matrix_short_9x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x9>::type > : index_operator_matrix_access_policy < matrix_short_9x9 > { typedef index_operator_matrix_access_policy < matrix_short_9x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x9 > { typedef dimension<9> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 9, 10> matrix_short_9x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,0> matrix_short_9x10_row0; } template <> struct geometric_traits<detail::matrix_short_9x10_row0> { typedef detail::matrix_short_9x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,1> matrix_short_9x10_row1; } template <> struct geometric_traits<detail::matrix_short_9x10_row1> { typedef detail::matrix_short_9x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,2> matrix_short_9x10_row2; } template <> struct geometric_traits<detail::matrix_short_9x10_row2> { typedef detail::matrix_short_9x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,3> matrix_short_9x10_row3; } template <> struct geometric_traits<detail::matrix_short_9x10_row3> { typedef detail::matrix_short_9x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,4> matrix_short_9x10_row4; } template <> struct geometric_traits<detail::matrix_short_9x10_row4> { typedef detail::matrix_short_9x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,5> matrix_short_9x10_row5; } template <> struct geometric_traits<detail::matrix_short_9x10_row5> { typedef detail::matrix_short_9x10_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,6> matrix_short_9x10_row6; } template <> struct geometric_traits<detail::matrix_short_9x10_row6> { typedef detail::matrix_short_9x10_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,7> matrix_short_9x10_row7; } template <> struct geometric_traits<detail::matrix_short_9x10_row7> { typedef detail::matrix_short_9x10_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_9x10,8> matrix_short_9x10_row8; } template <> struct geometric_traits<detail::matrix_short_9x10_row8> { typedef detail::matrix_short_9x10_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,0> matrix_short_9x10_column0; }template <> struct geometric_traits<detail::matrix_short_9x10_column0> { typedef detail::matrix_short_9x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,1> matrix_short_9x10_column1; }template <> struct geometric_traits<detail::matrix_short_9x10_column1> { typedef detail::matrix_short_9x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,2> matrix_short_9x10_column2; }template <> struct geometric_traits<detail::matrix_short_9x10_column2> { typedef detail::matrix_short_9x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,3> matrix_short_9x10_column3; }template <> struct geometric_traits<detail::matrix_short_9x10_column3> { typedef detail::matrix_short_9x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,4> matrix_short_9x10_column4; }template <> struct geometric_traits<detail::matrix_short_9x10_column4> { typedef detail::matrix_short_9x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,5> matrix_short_9x10_column5; }template <> struct geometric_traits<detail::matrix_short_9x10_column5> { typedef detail::matrix_short_9x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,6> matrix_short_9x10_column6; }template <> struct geometric_traits<detail::matrix_short_9x10_column6> { typedef detail::matrix_short_9x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,7> matrix_short_9x10_column7; }template <> struct geometric_traits<detail::matrix_short_9x10_column7> { typedef detail::matrix_short_9x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,8> matrix_short_9x10_column8; }template <> struct geometric_traits<detail::matrix_short_9x10_column8> { typedef detail::matrix_short_9x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_9x10,9> matrix_short_9x10_column9; }template <> struct geometric_traits<detail::matrix_short_9x10_column9> { typedef detail::matrix_short_9x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_9x10>::type > : index_operator_matrix_access_policy < matrix_short_9x10 > { typedef index_operator_matrix_access_policy < matrix_short_9x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_9x10 > { typedef dimension<9> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 1> matrix_short_10x1; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,0> matrix_short_10x1_row0; } template <> struct geometric_traits<detail::matrix_short_10x1_row0> { typedef detail::matrix_short_10x1_row0 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,1> matrix_short_10x1_row1; } template <> struct geometric_traits<detail::matrix_short_10x1_row1> { typedef detail::matrix_short_10x1_row1 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,2> matrix_short_10x1_row2; } template <> struct geometric_traits<detail::matrix_short_10x1_row2> { typedef detail::matrix_short_10x1_row2 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,3> matrix_short_10x1_row3; } template <> struct geometric_traits<detail::matrix_short_10x1_row3> { typedef detail::matrix_short_10x1_row3 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,4> matrix_short_10x1_row4; } template <> struct geometric_traits<detail::matrix_short_10x1_row4> { typedef detail::matrix_short_10x1_row4 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,5> matrix_short_10x1_row5; } template <> struct geometric_traits<detail::matrix_short_10x1_row5> { typedef detail::matrix_short_10x1_row5 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,6> matrix_short_10x1_row6; } template <> struct geometric_traits<detail::matrix_short_10x1_row6> { typedef detail::matrix_short_10x1_row6 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,7> matrix_short_10x1_row7; } template <> struct geometric_traits<detail::matrix_short_10x1_row7> { typedef detail::matrix_short_10x1_row7 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,8> matrix_short_10x1_row8; } template <> struct geometric_traits<detail::matrix_short_10x1_row8> { typedef detail::matrix_short_10x1_row8 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x1,9> matrix_short_10x1_row9; } template <> struct geometric_traits<detail::matrix_short_10x1_row9> { typedef detail::matrix_short_10x1_row9 sequence_type; typedef boost::mpl::vector<short> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x1,0> matrix_short_10x1_column0; }template <> struct geometric_traits<detail::matrix_short_10x1_column0> { typedef detail::matrix_short_10x1_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x1>::type > : index_operator_matrix_access_policy < matrix_short_10x1 > { typedef index_operator_matrix_access_policy < matrix_short_10x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x1 > { typedef dimension<10> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 2> matrix_short_10x2; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,0> matrix_short_10x2_row0; } template <> struct geometric_traits<detail::matrix_short_10x2_row0> { typedef detail::matrix_short_10x2_row0 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,1> matrix_short_10x2_row1; } template <> struct geometric_traits<detail::matrix_short_10x2_row1> { typedef detail::matrix_short_10x2_row1 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,2> matrix_short_10x2_row2; } template <> struct geometric_traits<detail::matrix_short_10x2_row2> { typedef detail::matrix_short_10x2_row2 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,3> matrix_short_10x2_row3; } template <> struct geometric_traits<detail::matrix_short_10x2_row3> { typedef detail::matrix_short_10x2_row3 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,4> matrix_short_10x2_row4; } template <> struct geometric_traits<detail::matrix_short_10x2_row4> { typedef detail::matrix_short_10x2_row4 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,5> matrix_short_10x2_row5; } template <> struct geometric_traits<detail::matrix_short_10x2_row5> { typedef detail::matrix_short_10x2_row5 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,6> matrix_short_10x2_row6; } template <> struct geometric_traits<detail::matrix_short_10x2_row6> { typedef detail::matrix_short_10x2_row6 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,7> matrix_short_10x2_row7; } template <> struct geometric_traits<detail::matrix_short_10x2_row7> { typedef detail::matrix_short_10x2_row7 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,8> matrix_short_10x2_row8; } template <> struct geometric_traits<detail::matrix_short_10x2_row8> { typedef detail::matrix_short_10x2_row8 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x2,9> matrix_short_10x2_row9; } template <> struct geometric_traits<detail::matrix_short_10x2_row9> { typedef detail::matrix_short_10x2_row9 sequence_type; typedef boost::mpl::vector<short, short> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x2,0> matrix_short_10x2_column0; }template <> struct geometric_traits<detail::matrix_short_10x2_column0> { typedef detail::matrix_short_10x2_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x2,1> matrix_short_10x2_column1; }template <> struct geometric_traits<detail::matrix_short_10x2_column1> { typedef detail::matrix_short_10x2_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x2>::type > : index_operator_matrix_access_policy < matrix_short_10x2 > { typedef index_operator_matrix_access_policy < matrix_short_10x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x2 > { typedef dimension<10> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 3> matrix_short_10x3; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,0> matrix_short_10x3_row0; } template <> struct geometric_traits<detail::matrix_short_10x3_row0> { typedef detail::matrix_short_10x3_row0 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,1> matrix_short_10x3_row1; } template <> struct geometric_traits<detail::matrix_short_10x3_row1> { typedef detail::matrix_short_10x3_row1 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,2> matrix_short_10x3_row2; } template <> struct geometric_traits<detail::matrix_short_10x3_row2> { typedef detail::matrix_short_10x3_row2 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,3> matrix_short_10x3_row3; } template <> struct geometric_traits<detail::matrix_short_10x3_row3> { typedef detail::matrix_short_10x3_row3 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,4> matrix_short_10x3_row4; } template <> struct geometric_traits<detail::matrix_short_10x3_row4> { typedef detail::matrix_short_10x3_row4 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,5> matrix_short_10x3_row5; } template <> struct geometric_traits<detail::matrix_short_10x3_row5> { typedef detail::matrix_short_10x3_row5 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,6> matrix_short_10x3_row6; } template <> struct geometric_traits<detail::matrix_short_10x3_row6> { typedef detail::matrix_short_10x3_row6 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,7> matrix_short_10x3_row7; } template <> struct geometric_traits<detail::matrix_short_10x3_row7> { typedef detail::matrix_short_10x3_row7 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,8> matrix_short_10x3_row8; } template <> struct geometric_traits<detail::matrix_short_10x3_row8> { typedef detail::matrix_short_10x3_row8 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x3,9> matrix_short_10x3_row9; } template <> struct geometric_traits<detail::matrix_short_10x3_row9> { typedef detail::matrix_short_10x3_row9 sequence_type; typedef boost::mpl::vector<short, short, short> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x3,0> matrix_short_10x3_column0; }template <> struct geometric_traits<detail::matrix_short_10x3_column0> { typedef detail::matrix_short_10x3_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x3,1> matrix_short_10x3_column1; }template <> struct geometric_traits<detail::matrix_short_10x3_column1> { typedef detail::matrix_short_10x3_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x3,2> matrix_short_10x3_column2; }template <> struct geometric_traits<detail::matrix_short_10x3_column2> { typedef detail::matrix_short_10x3_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x3>::type > : index_operator_matrix_access_policy < matrix_short_10x3 > { typedef index_operator_matrix_access_policy < matrix_short_10x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x3 > { typedef dimension<10> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 4> matrix_short_10x4; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,0> matrix_short_10x4_row0; } template <> struct geometric_traits<detail::matrix_short_10x4_row0> { typedef detail::matrix_short_10x4_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,1> matrix_short_10x4_row1; } template <> struct geometric_traits<detail::matrix_short_10x4_row1> { typedef detail::matrix_short_10x4_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,2> matrix_short_10x4_row2; } template <> struct geometric_traits<detail::matrix_short_10x4_row2> { typedef detail::matrix_short_10x4_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,3> matrix_short_10x4_row3; } template <> struct geometric_traits<detail::matrix_short_10x4_row3> { typedef detail::matrix_short_10x4_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,4> matrix_short_10x4_row4; } template <> struct geometric_traits<detail::matrix_short_10x4_row4> { typedef detail::matrix_short_10x4_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,5> matrix_short_10x4_row5; } template <> struct geometric_traits<detail::matrix_short_10x4_row5> { typedef detail::matrix_short_10x4_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,6> matrix_short_10x4_row6; } template <> struct geometric_traits<detail::matrix_short_10x4_row6> { typedef detail::matrix_short_10x4_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,7> matrix_short_10x4_row7; } template <> struct geometric_traits<detail::matrix_short_10x4_row7> { typedef detail::matrix_short_10x4_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,8> matrix_short_10x4_row8; } template <> struct geometric_traits<detail::matrix_short_10x4_row8> { typedef detail::matrix_short_10x4_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x4,9> matrix_short_10x4_row9; } template <> struct geometric_traits<detail::matrix_short_10x4_row9> { typedef detail::matrix_short_10x4_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x4,0> matrix_short_10x4_column0; }template <> struct geometric_traits<detail::matrix_short_10x4_column0> { typedef detail::matrix_short_10x4_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x4,1> matrix_short_10x4_column1; }template <> struct geometric_traits<detail::matrix_short_10x4_column1> { typedef detail::matrix_short_10x4_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x4,2> matrix_short_10x4_column2; }template <> struct geometric_traits<detail::matrix_short_10x4_column2> { typedef detail::matrix_short_10x4_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x4,3> matrix_short_10x4_column3; }template <> struct geometric_traits<detail::matrix_short_10x4_column3> { typedef detail::matrix_short_10x4_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x4>::type > : index_operator_matrix_access_policy < matrix_short_10x4 > { typedef index_operator_matrix_access_policy < matrix_short_10x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x4 > { typedef dimension<10> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 5> matrix_short_10x5; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,0> matrix_short_10x5_row0; } template <> struct geometric_traits<detail::matrix_short_10x5_row0> { typedef detail::matrix_short_10x5_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,1> matrix_short_10x5_row1; } template <> struct geometric_traits<detail::matrix_short_10x5_row1> { typedef detail::matrix_short_10x5_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,2> matrix_short_10x5_row2; } template <> struct geometric_traits<detail::matrix_short_10x5_row2> { typedef detail::matrix_short_10x5_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,3> matrix_short_10x5_row3; } template <> struct geometric_traits<detail::matrix_short_10x5_row3> { typedef detail::matrix_short_10x5_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,4> matrix_short_10x5_row4; } template <> struct geometric_traits<detail::matrix_short_10x5_row4> { typedef detail::matrix_short_10x5_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,5> matrix_short_10x5_row5; } template <> struct geometric_traits<detail::matrix_short_10x5_row5> { typedef detail::matrix_short_10x5_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,6> matrix_short_10x5_row6; } template <> struct geometric_traits<detail::matrix_short_10x5_row6> { typedef detail::matrix_short_10x5_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,7> matrix_short_10x5_row7; } template <> struct geometric_traits<detail::matrix_short_10x5_row7> { typedef detail::matrix_short_10x5_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,8> matrix_short_10x5_row8; } template <> struct geometric_traits<detail::matrix_short_10x5_row8> { typedef detail::matrix_short_10x5_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x5,9> matrix_short_10x5_row9; } template <> struct geometric_traits<detail::matrix_short_10x5_row9> { typedef detail::matrix_short_10x5_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x5,0> matrix_short_10x5_column0; }template <> struct geometric_traits<detail::matrix_short_10x5_column0> { typedef detail::matrix_short_10x5_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x5,1> matrix_short_10x5_column1; }template <> struct geometric_traits<detail::matrix_short_10x5_column1> { typedef detail::matrix_short_10x5_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x5,2> matrix_short_10x5_column2; }template <> struct geometric_traits<detail::matrix_short_10x5_column2> { typedef detail::matrix_short_10x5_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x5,3> matrix_short_10x5_column3; }template <> struct geometric_traits<detail::matrix_short_10x5_column3> { typedef detail::matrix_short_10x5_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x5,4> matrix_short_10x5_column4; }template <> struct geometric_traits<detail::matrix_short_10x5_column4> { typedef detail::matrix_short_10x5_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x5>::type > : index_operator_matrix_access_policy < matrix_short_10x5 > { typedef index_operator_matrix_access_policy < matrix_short_10x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x5 > { typedef dimension<10> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 6> matrix_short_10x6; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,0> matrix_short_10x6_row0; } template <> struct geometric_traits<detail::matrix_short_10x6_row0> { typedef detail::matrix_short_10x6_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,1> matrix_short_10x6_row1; } template <> struct geometric_traits<detail::matrix_short_10x6_row1> { typedef detail::matrix_short_10x6_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,2> matrix_short_10x6_row2; } template <> struct geometric_traits<detail::matrix_short_10x6_row2> { typedef detail::matrix_short_10x6_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,3> matrix_short_10x6_row3; } template <> struct geometric_traits<detail::matrix_short_10x6_row3> { typedef detail::matrix_short_10x6_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,4> matrix_short_10x6_row4; } template <> struct geometric_traits<detail::matrix_short_10x6_row4> { typedef detail::matrix_short_10x6_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,5> matrix_short_10x6_row5; } template <> struct geometric_traits<detail::matrix_short_10x6_row5> { typedef detail::matrix_short_10x6_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,6> matrix_short_10x6_row6; } template <> struct geometric_traits<detail::matrix_short_10x6_row6> { typedef detail::matrix_short_10x6_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,7> matrix_short_10x6_row7; } template <> struct geometric_traits<detail::matrix_short_10x6_row7> { typedef detail::matrix_short_10x6_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,8> matrix_short_10x6_row8; } template <> struct geometric_traits<detail::matrix_short_10x6_row8> { typedef detail::matrix_short_10x6_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x6,9> matrix_short_10x6_row9; } template <> struct geometric_traits<detail::matrix_short_10x6_row9> { typedef detail::matrix_short_10x6_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,0> matrix_short_10x6_column0; }template <> struct geometric_traits<detail::matrix_short_10x6_column0> { typedef detail::matrix_short_10x6_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,1> matrix_short_10x6_column1; }template <> struct geometric_traits<detail::matrix_short_10x6_column1> { typedef detail::matrix_short_10x6_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,2> matrix_short_10x6_column2; }template <> struct geometric_traits<detail::matrix_short_10x6_column2> { typedef detail::matrix_short_10x6_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,3> matrix_short_10x6_column3; }template <> struct geometric_traits<detail::matrix_short_10x6_column3> { typedef detail::matrix_short_10x6_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,4> matrix_short_10x6_column4; }template <> struct geometric_traits<detail::matrix_short_10x6_column4> { typedef detail::matrix_short_10x6_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x6,5> matrix_short_10x6_column5; }template <> struct geometric_traits<detail::matrix_short_10x6_column5> { typedef detail::matrix_short_10x6_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x6>::type > : index_operator_matrix_access_policy < matrix_short_10x6 > { typedef index_operator_matrix_access_policy < matrix_short_10x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x6 > { typedef dimension<10> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 7> matrix_short_10x7; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,0> matrix_short_10x7_row0; } template <> struct geometric_traits<detail::matrix_short_10x7_row0> { typedef detail::matrix_short_10x7_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,1> matrix_short_10x7_row1; } template <> struct geometric_traits<detail::matrix_short_10x7_row1> { typedef detail::matrix_short_10x7_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,2> matrix_short_10x7_row2; } template <> struct geometric_traits<detail::matrix_short_10x7_row2> { typedef detail::matrix_short_10x7_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,3> matrix_short_10x7_row3; } template <> struct geometric_traits<detail::matrix_short_10x7_row3> { typedef detail::matrix_short_10x7_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,4> matrix_short_10x7_row4; } template <> struct geometric_traits<detail::matrix_short_10x7_row4> { typedef detail::matrix_short_10x7_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,5> matrix_short_10x7_row5; } template <> struct geometric_traits<detail::matrix_short_10x7_row5> { typedef detail::matrix_short_10x7_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,6> matrix_short_10x7_row6; } template <> struct geometric_traits<detail::matrix_short_10x7_row6> { typedef detail::matrix_short_10x7_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,7> matrix_short_10x7_row7; } template <> struct geometric_traits<detail::matrix_short_10x7_row7> { typedef detail::matrix_short_10x7_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,8> matrix_short_10x7_row8; } template <> struct geometric_traits<detail::matrix_short_10x7_row8> { typedef detail::matrix_short_10x7_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x7,9> matrix_short_10x7_row9; } template <> struct geometric_traits<detail::matrix_short_10x7_row9> { typedef detail::matrix_short_10x7_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,0> matrix_short_10x7_column0; }template <> struct geometric_traits<detail::matrix_short_10x7_column0> { typedef detail::matrix_short_10x7_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,1> matrix_short_10x7_column1; }template <> struct geometric_traits<detail::matrix_short_10x7_column1> { typedef detail::matrix_short_10x7_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,2> matrix_short_10x7_column2; }template <> struct geometric_traits<detail::matrix_short_10x7_column2> { typedef detail::matrix_short_10x7_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,3> matrix_short_10x7_column3; }template <> struct geometric_traits<detail::matrix_short_10x7_column3> { typedef detail::matrix_short_10x7_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,4> matrix_short_10x7_column4; }template <> struct geometric_traits<detail::matrix_short_10x7_column4> { typedef detail::matrix_short_10x7_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,5> matrix_short_10x7_column5; }template <> struct geometric_traits<detail::matrix_short_10x7_column5> { typedef detail::matrix_short_10x7_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x7,6> matrix_short_10x7_column6; }template <> struct geometric_traits<detail::matrix_short_10x7_column6> { typedef detail::matrix_short_10x7_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x7>::type > : index_operator_matrix_access_policy < matrix_short_10x7 > { typedef index_operator_matrix_access_policy < matrix_short_10x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x7 > { typedef dimension<10> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 8> matrix_short_10x8; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,0> matrix_short_10x8_row0; } template <> struct geometric_traits<detail::matrix_short_10x8_row0> { typedef detail::matrix_short_10x8_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,1> matrix_short_10x8_row1; } template <> struct geometric_traits<detail::matrix_short_10x8_row1> { typedef detail::matrix_short_10x8_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,2> matrix_short_10x8_row2; } template <> struct geometric_traits<detail::matrix_short_10x8_row2> { typedef detail::matrix_short_10x8_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,3> matrix_short_10x8_row3; } template <> struct geometric_traits<detail::matrix_short_10x8_row3> { typedef detail::matrix_short_10x8_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,4> matrix_short_10x8_row4; } template <> struct geometric_traits<detail::matrix_short_10x8_row4> { typedef detail::matrix_short_10x8_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,5> matrix_short_10x8_row5; } template <> struct geometric_traits<detail::matrix_short_10x8_row5> { typedef detail::matrix_short_10x8_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,6> matrix_short_10x8_row6; } template <> struct geometric_traits<detail::matrix_short_10x8_row6> { typedef detail::matrix_short_10x8_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,7> matrix_short_10x8_row7; } template <> struct geometric_traits<detail::matrix_short_10x8_row7> { typedef detail::matrix_short_10x8_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,8> matrix_short_10x8_row8; } template <> struct geometric_traits<detail::matrix_short_10x8_row8> { typedef detail::matrix_short_10x8_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x8,9> matrix_short_10x8_row9; } template <> struct geometric_traits<detail::matrix_short_10x8_row9> { typedef detail::matrix_short_10x8_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,0> matrix_short_10x8_column0; }template <> struct geometric_traits<detail::matrix_short_10x8_column0> { typedef detail::matrix_short_10x8_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,1> matrix_short_10x8_column1; }template <> struct geometric_traits<detail::matrix_short_10x8_column1> { typedef detail::matrix_short_10x8_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,2> matrix_short_10x8_column2; }template <> struct geometric_traits<detail::matrix_short_10x8_column2> { typedef detail::matrix_short_10x8_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,3> matrix_short_10x8_column3; }template <> struct geometric_traits<detail::matrix_short_10x8_column3> { typedef detail::matrix_short_10x8_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,4> matrix_short_10x8_column4; }template <> struct geometric_traits<detail::matrix_short_10x8_column4> { typedef detail::matrix_short_10x8_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,5> matrix_short_10x8_column5; }template <> struct geometric_traits<detail::matrix_short_10x8_column5> { typedef detail::matrix_short_10x8_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,6> matrix_short_10x8_column6; }template <> struct geometric_traits<detail::matrix_short_10x8_column6> { typedef detail::matrix_short_10x8_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x8,7> matrix_short_10x8_column7; }template <> struct geometric_traits<detail::matrix_short_10x8_column7> { typedef detail::matrix_short_10x8_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x8>::type > : index_operator_matrix_access_policy < matrix_short_10x8 > { typedef index_operator_matrix_access_policy < matrix_short_10x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x8 > { typedef dimension<10> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 9> matrix_short_10x9; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,0> matrix_short_10x9_row0; } template <> struct geometric_traits<detail::matrix_short_10x9_row0> { typedef detail::matrix_short_10x9_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,1> matrix_short_10x9_row1; } template <> struct geometric_traits<detail::matrix_short_10x9_row1> { typedef detail::matrix_short_10x9_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,2> matrix_short_10x9_row2; } template <> struct geometric_traits<detail::matrix_short_10x9_row2> { typedef detail::matrix_short_10x9_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,3> matrix_short_10x9_row3; } template <> struct geometric_traits<detail::matrix_short_10x9_row3> { typedef detail::matrix_short_10x9_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,4> matrix_short_10x9_row4; } template <> struct geometric_traits<detail::matrix_short_10x9_row4> { typedef detail::matrix_short_10x9_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,5> matrix_short_10x9_row5; } template <> struct geometric_traits<detail::matrix_short_10x9_row5> { typedef detail::matrix_short_10x9_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,6> matrix_short_10x9_row6; } template <> struct geometric_traits<detail::matrix_short_10x9_row6> { typedef detail::matrix_short_10x9_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,7> matrix_short_10x9_row7; } template <> struct geometric_traits<detail::matrix_short_10x9_row7> { typedef detail::matrix_short_10x9_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,8> matrix_short_10x9_row8; } template <> struct geometric_traits<detail::matrix_short_10x9_row8> { typedef detail::matrix_short_10x9_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x9,9> matrix_short_10x9_row9; } template <> struct geometric_traits<detail::matrix_short_10x9_row9> { typedef detail::matrix_short_10x9_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,0> matrix_short_10x9_column0; }template <> struct geometric_traits<detail::matrix_short_10x9_column0> { typedef detail::matrix_short_10x9_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,1> matrix_short_10x9_column1; }template <> struct geometric_traits<detail::matrix_short_10x9_column1> { typedef detail::matrix_short_10x9_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,2> matrix_short_10x9_column2; }template <> struct geometric_traits<detail::matrix_short_10x9_column2> { typedef detail::matrix_short_10x9_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,3> matrix_short_10x9_column3; }template <> struct geometric_traits<detail::matrix_short_10x9_column3> { typedef detail::matrix_short_10x9_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,4> matrix_short_10x9_column4; }template <> struct geometric_traits<detail::matrix_short_10x9_column4> { typedef detail::matrix_short_10x9_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,5> matrix_short_10x9_column5; }template <> struct geometric_traits<detail::matrix_short_10x9_column5> { typedef detail::matrix_short_10x9_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,6> matrix_short_10x9_column6; }template <> struct geometric_traits<detail::matrix_short_10x9_column6> { typedef detail::matrix_short_10x9_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,7> matrix_short_10x9_column7; }template <> struct geometric_traits<detail::matrix_short_10x9_column7> { typedef detail::matrix_short_10x9_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x9,8> matrix_short_10x9_column8; }template <> struct geometric_traits<detail::matrix_short_10x9_column8> { typedef detail::matrix_short_10x9_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x9>::type > : index_operator_matrix_access_policy < matrix_short_10x9 > { typedef index_operator_matrix_access_policy < matrix_short_10x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x9 > { typedef dimension<10> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<short, 10, 10> matrix_short_10x10; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,0> matrix_short_10x10_row0; } template <> struct geometric_traits<detail::matrix_short_10x10_row0> { typedef detail::matrix_short_10x10_row0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,1> matrix_short_10x10_row1; } template <> struct geometric_traits<detail::matrix_short_10x10_row1> { typedef detail::matrix_short_10x10_row1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,2> matrix_short_10x10_row2; } template <> struct geometric_traits<detail::matrix_short_10x10_row2> { typedef detail::matrix_short_10x10_row2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,3> matrix_short_10x10_row3; } template <> struct geometric_traits<detail::matrix_short_10x10_row3> { typedef detail::matrix_short_10x10_row3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,4> matrix_short_10x10_row4; } template <> struct geometric_traits<detail::matrix_short_10x10_row4> { typedef detail::matrix_short_10x10_row4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,5> matrix_short_10x10_row5; } template <> struct geometric_traits<detail::matrix_short_10x10_row5> { typedef detail::matrix_short_10x10_row5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,6> matrix_short_10x10_row6; } template <> struct geometric_traits<detail::matrix_short_10x10_row6> { typedef detail::matrix_short_10x10_row6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,7> matrix_short_10x10_row7; } template <> struct geometric_traits<detail::matrix_short_10x10_row7> { typedef detail::matrix_short_10x10_row7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,8> matrix_short_10x10_row8; } template <> struct geometric_traits<detail::matrix_short_10x10_row8> { typedef detail::matrix_short_10x10_row8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_short_10x10,9> matrix_short_10x10_row9; } template <> struct geometric_traits<detail::matrix_short_10x10_row9> { typedef detail::matrix_short_10x10_row9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,0> matrix_short_10x10_column0; }template <> struct geometric_traits<detail::matrix_short_10x10_column0> { typedef detail::matrix_short_10x10_column0 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,1> matrix_short_10x10_column1; }template <> struct geometric_traits<detail::matrix_short_10x10_column1> { typedef detail::matrix_short_10x10_column1 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,2> matrix_short_10x10_column2; }template <> struct geometric_traits<detail::matrix_short_10x10_column2> { typedef detail::matrix_short_10x10_column2 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,3> matrix_short_10x10_column3; }template <> struct geometric_traits<detail::matrix_short_10x10_column3> { typedef detail::matrix_short_10x10_column3 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,4> matrix_short_10x10_column4; }template <> struct geometric_traits<detail::matrix_short_10x10_column4> { typedef detail::matrix_short_10x10_column4 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,5> matrix_short_10x10_column5; }template <> struct geometric_traits<detail::matrix_short_10x10_column5> { typedef detail::matrix_short_10x10_column5 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,6> matrix_short_10x10_column6; }template <> struct geometric_traits<detail::matrix_short_10x10_column6> { typedef detail::matrix_short_10x10_column6 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,7> matrix_short_10x10_column7; }template <> struct geometric_traits<detail::matrix_short_10x10_column7> { typedef detail::matrix_short_10x10_column7 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,8> matrix_short_10x10_column8; }template <> struct geometric_traits<detail::matrix_short_10x10_column8> { typedef detail::matrix_short_10x10_column8 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_short_10x10,9> matrix_short_10x10_column9; }template <> struct geometric_traits<detail::matrix_short_10x10_column9> { typedef detail::matrix_short_10x10_column9 sequence_type; typedef boost::mpl::vector<short, short, short, short, short, short, short, short, short, short> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_short_10x10>::type > : index_operator_matrix_access_policy < matrix_short_10x10 > { typedef index_operator_matrix_access_policy < matrix_short_10x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_short_10x10 > { typedef dimension<10> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; }
    namespace geometrix { typedef matrix<char, 1, 1> matrix_char_1x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x1,0> matrix_char_1x1_row0; } template <> struct geometric_traits<detail::matrix_char_1x1_row0> { typedef detail::matrix_char_1x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x1,0> matrix_char_1x1_column0; }template <> struct geometric_traits<detail::matrix_char_1x1_column0> { typedef detail::matrix_char_1x1_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x1>::type > : index_operator_matrix_access_policy < matrix_char_1x1 > { typedef index_operator_matrix_access_policy < matrix_char_1x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x1 > { typedef dimension<1> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 2> matrix_char_1x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x2,0> matrix_char_1x2_row0; } template <> struct geometric_traits<detail::matrix_char_1x2_row0> { typedef detail::matrix_char_1x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x2,0> matrix_char_1x2_column0; }template <> struct geometric_traits<detail::matrix_char_1x2_column0> { typedef detail::matrix_char_1x2_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x2,1> matrix_char_1x2_column1; }template <> struct geometric_traits<detail::matrix_char_1x2_column1> { typedef detail::matrix_char_1x2_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x2>::type > : index_operator_matrix_access_policy < matrix_char_1x2 > { typedef index_operator_matrix_access_policy < matrix_char_1x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x2 > { typedef dimension<1> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 3> matrix_char_1x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x3,0> matrix_char_1x3_row0; } template <> struct geometric_traits<detail::matrix_char_1x3_row0> { typedef detail::matrix_char_1x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x3,0> matrix_char_1x3_column0; }template <> struct geometric_traits<detail::matrix_char_1x3_column0> { typedef detail::matrix_char_1x3_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x3,1> matrix_char_1x3_column1; }template <> struct geometric_traits<detail::matrix_char_1x3_column1> { typedef detail::matrix_char_1x3_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x3,2> matrix_char_1x3_column2; }template <> struct geometric_traits<detail::matrix_char_1x3_column2> { typedef detail::matrix_char_1x3_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x3>::type > : index_operator_matrix_access_policy < matrix_char_1x3 > { typedef index_operator_matrix_access_policy < matrix_char_1x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x3 > { typedef dimension<1> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 4> matrix_char_1x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x4,0> matrix_char_1x4_row0; } template <> struct geometric_traits<detail::matrix_char_1x4_row0> { typedef detail::matrix_char_1x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x4,0> matrix_char_1x4_column0; }template <> struct geometric_traits<detail::matrix_char_1x4_column0> { typedef detail::matrix_char_1x4_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x4,1> matrix_char_1x4_column1; }template <> struct geometric_traits<detail::matrix_char_1x4_column1> { typedef detail::matrix_char_1x4_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x4,2> matrix_char_1x4_column2; }template <> struct geometric_traits<detail::matrix_char_1x4_column2> { typedef detail::matrix_char_1x4_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x4,3> matrix_char_1x4_column3; }template <> struct geometric_traits<detail::matrix_char_1x4_column3> { typedef detail::matrix_char_1x4_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x4>::type > : index_operator_matrix_access_policy < matrix_char_1x4 > { typedef index_operator_matrix_access_policy < matrix_char_1x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x4 > { typedef dimension<1> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 5> matrix_char_1x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x5,0> matrix_char_1x5_row0; } template <> struct geometric_traits<detail::matrix_char_1x5_row0> { typedef detail::matrix_char_1x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x5,0> matrix_char_1x5_column0; }template <> struct geometric_traits<detail::matrix_char_1x5_column0> { typedef detail::matrix_char_1x5_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x5,1> matrix_char_1x5_column1; }template <> struct geometric_traits<detail::matrix_char_1x5_column1> { typedef detail::matrix_char_1x5_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x5,2> matrix_char_1x5_column2; }template <> struct geometric_traits<detail::matrix_char_1x5_column2> { typedef detail::matrix_char_1x5_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x5,3> matrix_char_1x5_column3; }template <> struct geometric_traits<detail::matrix_char_1x5_column3> { typedef detail::matrix_char_1x5_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x5,4> matrix_char_1x5_column4; }template <> struct geometric_traits<detail::matrix_char_1x5_column4> { typedef detail::matrix_char_1x5_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x5>::type > : index_operator_matrix_access_policy < matrix_char_1x5 > { typedef index_operator_matrix_access_policy < matrix_char_1x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x5 > { typedef dimension<1> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 6> matrix_char_1x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x6,0> matrix_char_1x6_row0; } template <> struct geometric_traits<detail::matrix_char_1x6_row0> { typedef detail::matrix_char_1x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,0> matrix_char_1x6_column0; }template <> struct geometric_traits<detail::matrix_char_1x6_column0> { typedef detail::matrix_char_1x6_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,1> matrix_char_1x6_column1; }template <> struct geometric_traits<detail::matrix_char_1x6_column1> { typedef detail::matrix_char_1x6_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,2> matrix_char_1x6_column2; }template <> struct geometric_traits<detail::matrix_char_1x6_column2> { typedef detail::matrix_char_1x6_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,3> matrix_char_1x6_column3; }template <> struct geometric_traits<detail::matrix_char_1x6_column3> { typedef detail::matrix_char_1x6_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,4> matrix_char_1x6_column4; }template <> struct geometric_traits<detail::matrix_char_1x6_column4> { typedef detail::matrix_char_1x6_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x6,5> matrix_char_1x6_column5; }template <> struct geometric_traits<detail::matrix_char_1x6_column5> { typedef detail::matrix_char_1x6_column5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x6>::type > : index_operator_matrix_access_policy < matrix_char_1x6 > { typedef index_operator_matrix_access_policy < matrix_char_1x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x6 > { typedef dimension<1> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 7> matrix_char_1x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x7,0> matrix_char_1x7_row0; } template <> struct geometric_traits<detail::matrix_char_1x7_row0> { typedef detail::matrix_char_1x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,0> matrix_char_1x7_column0; }template <> struct geometric_traits<detail::matrix_char_1x7_column0> { typedef detail::matrix_char_1x7_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,1> matrix_char_1x7_column1; }template <> struct geometric_traits<detail::matrix_char_1x7_column1> { typedef detail::matrix_char_1x7_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,2> matrix_char_1x7_column2; }template <> struct geometric_traits<detail::matrix_char_1x7_column2> { typedef detail::matrix_char_1x7_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,3> matrix_char_1x7_column3; }template <> struct geometric_traits<detail::matrix_char_1x7_column3> { typedef detail::matrix_char_1x7_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,4> matrix_char_1x7_column4; }template <> struct geometric_traits<detail::matrix_char_1x7_column4> { typedef detail::matrix_char_1x7_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,5> matrix_char_1x7_column5; }template <> struct geometric_traits<detail::matrix_char_1x7_column5> { typedef detail::matrix_char_1x7_column5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x7,6> matrix_char_1x7_column6; }template <> struct geometric_traits<detail::matrix_char_1x7_column6> { typedef detail::matrix_char_1x7_column6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x7>::type > : index_operator_matrix_access_policy < matrix_char_1x7 > { typedef index_operator_matrix_access_policy < matrix_char_1x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x7 > { typedef dimension<1> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 8> matrix_char_1x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x8,0> matrix_char_1x8_row0; } template <> struct geometric_traits<detail::matrix_char_1x8_row0> { typedef detail::matrix_char_1x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,0> matrix_char_1x8_column0; }template <> struct geometric_traits<detail::matrix_char_1x8_column0> { typedef detail::matrix_char_1x8_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,1> matrix_char_1x8_column1; }template <> struct geometric_traits<detail::matrix_char_1x8_column1> { typedef detail::matrix_char_1x8_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,2> matrix_char_1x8_column2; }template <> struct geometric_traits<detail::matrix_char_1x8_column2> { typedef detail::matrix_char_1x8_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,3> matrix_char_1x8_column3; }template <> struct geometric_traits<detail::matrix_char_1x8_column3> { typedef detail::matrix_char_1x8_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,4> matrix_char_1x8_column4; }template <> struct geometric_traits<detail::matrix_char_1x8_column4> { typedef detail::matrix_char_1x8_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,5> matrix_char_1x8_column5; }template <> struct geometric_traits<detail::matrix_char_1x8_column5> { typedef detail::matrix_char_1x8_column5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,6> matrix_char_1x8_column6; }template <> struct geometric_traits<detail::matrix_char_1x8_column6> { typedef detail::matrix_char_1x8_column6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x8,7> matrix_char_1x8_column7; }template <> struct geometric_traits<detail::matrix_char_1x8_column7> { typedef detail::matrix_char_1x8_column7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x8>::type > : index_operator_matrix_access_policy < matrix_char_1x8 > { typedef index_operator_matrix_access_policy < matrix_char_1x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x8 > { typedef dimension<1> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 9> matrix_char_1x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x9,0> matrix_char_1x9_row0; } template <> struct geometric_traits<detail::matrix_char_1x9_row0> { typedef detail::matrix_char_1x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,0> matrix_char_1x9_column0; }template <> struct geometric_traits<detail::matrix_char_1x9_column0> { typedef detail::matrix_char_1x9_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,1> matrix_char_1x9_column1; }template <> struct geometric_traits<detail::matrix_char_1x9_column1> { typedef detail::matrix_char_1x9_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,2> matrix_char_1x9_column2; }template <> struct geometric_traits<detail::matrix_char_1x9_column2> { typedef detail::matrix_char_1x9_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,3> matrix_char_1x9_column3; }template <> struct geometric_traits<detail::matrix_char_1x9_column3> { typedef detail::matrix_char_1x9_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,4> matrix_char_1x9_column4; }template <> struct geometric_traits<detail::matrix_char_1x9_column4> { typedef detail::matrix_char_1x9_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,5> matrix_char_1x9_column5; }template <> struct geometric_traits<detail::matrix_char_1x9_column5> { typedef detail::matrix_char_1x9_column5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,6> matrix_char_1x9_column6; }template <> struct geometric_traits<detail::matrix_char_1x9_column6> { typedef detail::matrix_char_1x9_column6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,7> matrix_char_1x9_column7; }template <> struct geometric_traits<detail::matrix_char_1x9_column7> { typedef detail::matrix_char_1x9_column7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x9,8> matrix_char_1x9_column8; }template <> struct geometric_traits<detail::matrix_char_1x9_column8> { typedef detail::matrix_char_1x9_column8 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x9>::type > : index_operator_matrix_access_policy < matrix_char_1x9 > { typedef index_operator_matrix_access_policy < matrix_char_1x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x9 > { typedef dimension<1> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 1, 10> matrix_char_1x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_1x10,0> matrix_char_1x10_row0; } template <> struct geometric_traits<detail::matrix_char_1x10_row0> { typedef detail::matrix_char_1x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,0> matrix_char_1x10_column0; }template <> struct geometric_traits<detail::matrix_char_1x10_column0> { typedef detail::matrix_char_1x10_column0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,1> matrix_char_1x10_column1; }template <> struct geometric_traits<detail::matrix_char_1x10_column1> { typedef detail::matrix_char_1x10_column1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,2> matrix_char_1x10_column2; }template <> struct geometric_traits<detail::matrix_char_1x10_column2> { typedef detail::matrix_char_1x10_column2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,3> matrix_char_1x10_column3; }template <> struct geometric_traits<detail::matrix_char_1x10_column3> { typedef detail::matrix_char_1x10_column3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,4> matrix_char_1x10_column4; }template <> struct geometric_traits<detail::matrix_char_1x10_column4> { typedef detail::matrix_char_1x10_column4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,5> matrix_char_1x10_column5; }template <> struct geometric_traits<detail::matrix_char_1x10_column5> { typedef detail::matrix_char_1x10_column5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,6> matrix_char_1x10_column6; }template <> struct geometric_traits<detail::matrix_char_1x10_column6> { typedef detail::matrix_char_1x10_column6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,7> matrix_char_1x10_column7; }template <> struct geometric_traits<detail::matrix_char_1x10_column7> { typedef detail::matrix_char_1x10_column7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,8> matrix_char_1x10_column8; }template <> struct geometric_traits<detail::matrix_char_1x10_column8> { typedef detail::matrix_char_1x10_column8 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_1x10,9> matrix_char_1x10_column9; }template <> struct geometric_traits<detail::matrix_char_1x10_column9> { typedef detail::matrix_char_1x10_column9 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_1x10>::type > : index_operator_matrix_access_policy < matrix_char_1x10 > { typedef index_operator_matrix_access_policy < matrix_char_1x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_1x10 > { typedef dimension<1> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 1> matrix_char_2x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x1,0> matrix_char_2x1_row0; } template <> struct geometric_traits<detail::matrix_char_2x1_row0> { typedef detail::matrix_char_2x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x1,1> matrix_char_2x1_row1; } template <> struct geometric_traits<detail::matrix_char_2x1_row1> { typedef detail::matrix_char_2x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x1,0> matrix_char_2x1_column0; }template <> struct geometric_traits<detail::matrix_char_2x1_column0> { typedef detail::matrix_char_2x1_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x1>::type > : index_operator_matrix_access_policy < matrix_char_2x1 > { typedef index_operator_matrix_access_policy < matrix_char_2x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x1 > { typedef dimension<2> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 2> matrix_char_2x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x2,0> matrix_char_2x2_row0; } template <> struct geometric_traits<detail::matrix_char_2x2_row0> { typedef detail::matrix_char_2x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x2,1> matrix_char_2x2_row1; } template <> struct geometric_traits<detail::matrix_char_2x2_row1> { typedef detail::matrix_char_2x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x2,0> matrix_char_2x2_column0; }template <> struct geometric_traits<detail::matrix_char_2x2_column0> { typedef detail::matrix_char_2x2_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x2,1> matrix_char_2x2_column1; }template <> struct geometric_traits<detail::matrix_char_2x2_column1> { typedef detail::matrix_char_2x2_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x2>::type > : index_operator_matrix_access_policy < matrix_char_2x2 > { typedef index_operator_matrix_access_policy < matrix_char_2x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x2 > { typedef dimension<2> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 3> matrix_char_2x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x3,0> matrix_char_2x3_row0; } template <> struct geometric_traits<detail::matrix_char_2x3_row0> { typedef detail::matrix_char_2x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x3,1> matrix_char_2x3_row1; } template <> struct geometric_traits<detail::matrix_char_2x3_row1> { typedef detail::matrix_char_2x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x3,0> matrix_char_2x3_column0; }template <> struct geometric_traits<detail::matrix_char_2x3_column0> { typedef detail::matrix_char_2x3_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x3,1> matrix_char_2x3_column1; }template <> struct geometric_traits<detail::matrix_char_2x3_column1> { typedef detail::matrix_char_2x3_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x3,2> matrix_char_2x3_column2; }template <> struct geometric_traits<detail::matrix_char_2x3_column2> { typedef detail::matrix_char_2x3_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x3>::type > : index_operator_matrix_access_policy < matrix_char_2x3 > { typedef index_operator_matrix_access_policy < matrix_char_2x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x3 > { typedef dimension<2> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 4> matrix_char_2x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x4,0> matrix_char_2x4_row0; } template <> struct geometric_traits<detail::matrix_char_2x4_row0> { typedef detail::matrix_char_2x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x4,1> matrix_char_2x4_row1; } template <> struct geometric_traits<detail::matrix_char_2x4_row1> { typedef detail::matrix_char_2x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x4,0> matrix_char_2x4_column0; }template <> struct geometric_traits<detail::matrix_char_2x4_column0> { typedef detail::matrix_char_2x4_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x4,1> matrix_char_2x4_column1; }template <> struct geometric_traits<detail::matrix_char_2x4_column1> { typedef detail::matrix_char_2x4_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x4,2> matrix_char_2x4_column2; }template <> struct geometric_traits<detail::matrix_char_2x4_column2> { typedef detail::matrix_char_2x4_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x4,3> matrix_char_2x4_column3; }template <> struct geometric_traits<detail::matrix_char_2x4_column3> { typedef detail::matrix_char_2x4_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x4>::type > : index_operator_matrix_access_policy < matrix_char_2x4 > { typedef index_operator_matrix_access_policy < matrix_char_2x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x4 > { typedef dimension<2> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 5> matrix_char_2x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x5,0> matrix_char_2x5_row0; } template <> struct geometric_traits<detail::matrix_char_2x5_row0> { typedef detail::matrix_char_2x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x5,1> matrix_char_2x5_row1; } template <> struct geometric_traits<detail::matrix_char_2x5_row1> { typedef detail::matrix_char_2x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x5,0> matrix_char_2x5_column0; }template <> struct geometric_traits<detail::matrix_char_2x5_column0> { typedef detail::matrix_char_2x5_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x5,1> matrix_char_2x5_column1; }template <> struct geometric_traits<detail::matrix_char_2x5_column1> { typedef detail::matrix_char_2x5_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x5,2> matrix_char_2x5_column2; }template <> struct geometric_traits<detail::matrix_char_2x5_column2> { typedef detail::matrix_char_2x5_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x5,3> matrix_char_2x5_column3; }template <> struct geometric_traits<detail::matrix_char_2x5_column3> { typedef detail::matrix_char_2x5_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x5,4> matrix_char_2x5_column4; }template <> struct geometric_traits<detail::matrix_char_2x5_column4> { typedef detail::matrix_char_2x5_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x5>::type > : index_operator_matrix_access_policy < matrix_char_2x5 > { typedef index_operator_matrix_access_policy < matrix_char_2x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x5 > { typedef dimension<2> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 6> matrix_char_2x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x6,0> matrix_char_2x6_row0; } template <> struct geometric_traits<detail::matrix_char_2x6_row0> { typedef detail::matrix_char_2x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x6,1> matrix_char_2x6_row1; } template <> struct geometric_traits<detail::matrix_char_2x6_row1> { typedef detail::matrix_char_2x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,0> matrix_char_2x6_column0; }template <> struct geometric_traits<detail::matrix_char_2x6_column0> { typedef detail::matrix_char_2x6_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,1> matrix_char_2x6_column1; }template <> struct geometric_traits<detail::matrix_char_2x6_column1> { typedef detail::matrix_char_2x6_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,2> matrix_char_2x6_column2; }template <> struct geometric_traits<detail::matrix_char_2x6_column2> { typedef detail::matrix_char_2x6_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,3> matrix_char_2x6_column3; }template <> struct geometric_traits<detail::matrix_char_2x6_column3> { typedef detail::matrix_char_2x6_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,4> matrix_char_2x6_column4; }template <> struct geometric_traits<detail::matrix_char_2x6_column4> { typedef detail::matrix_char_2x6_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x6,5> matrix_char_2x6_column5; }template <> struct geometric_traits<detail::matrix_char_2x6_column5> { typedef detail::matrix_char_2x6_column5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x6>::type > : index_operator_matrix_access_policy < matrix_char_2x6 > { typedef index_operator_matrix_access_policy < matrix_char_2x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x6 > { typedef dimension<2> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 7> matrix_char_2x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x7,0> matrix_char_2x7_row0; } template <> struct geometric_traits<detail::matrix_char_2x7_row0> { typedef detail::matrix_char_2x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x7,1> matrix_char_2x7_row1; } template <> struct geometric_traits<detail::matrix_char_2x7_row1> { typedef detail::matrix_char_2x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,0> matrix_char_2x7_column0; }template <> struct geometric_traits<detail::matrix_char_2x7_column0> { typedef detail::matrix_char_2x7_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,1> matrix_char_2x7_column1; }template <> struct geometric_traits<detail::matrix_char_2x7_column1> { typedef detail::matrix_char_2x7_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,2> matrix_char_2x7_column2; }template <> struct geometric_traits<detail::matrix_char_2x7_column2> { typedef detail::matrix_char_2x7_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,3> matrix_char_2x7_column3; }template <> struct geometric_traits<detail::matrix_char_2x7_column3> { typedef detail::matrix_char_2x7_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,4> matrix_char_2x7_column4; }template <> struct geometric_traits<detail::matrix_char_2x7_column4> { typedef detail::matrix_char_2x7_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,5> matrix_char_2x7_column5; }template <> struct geometric_traits<detail::matrix_char_2x7_column5> { typedef detail::matrix_char_2x7_column5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x7,6> matrix_char_2x7_column6; }template <> struct geometric_traits<detail::matrix_char_2x7_column6> { typedef detail::matrix_char_2x7_column6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x7>::type > : index_operator_matrix_access_policy < matrix_char_2x7 > { typedef index_operator_matrix_access_policy < matrix_char_2x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x7 > { typedef dimension<2> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 8> matrix_char_2x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x8,0> matrix_char_2x8_row0; } template <> struct geometric_traits<detail::matrix_char_2x8_row0> { typedef detail::matrix_char_2x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x8,1> matrix_char_2x8_row1; } template <> struct geometric_traits<detail::matrix_char_2x8_row1> { typedef detail::matrix_char_2x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,0> matrix_char_2x8_column0; }template <> struct geometric_traits<detail::matrix_char_2x8_column0> { typedef detail::matrix_char_2x8_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,1> matrix_char_2x8_column1; }template <> struct geometric_traits<detail::matrix_char_2x8_column1> { typedef detail::matrix_char_2x8_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,2> matrix_char_2x8_column2; }template <> struct geometric_traits<detail::matrix_char_2x8_column2> { typedef detail::matrix_char_2x8_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,3> matrix_char_2x8_column3; }template <> struct geometric_traits<detail::matrix_char_2x8_column3> { typedef detail::matrix_char_2x8_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,4> matrix_char_2x8_column4; }template <> struct geometric_traits<detail::matrix_char_2x8_column4> { typedef detail::matrix_char_2x8_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,5> matrix_char_2x8_column5; }template <> struct geometric_traits<detail::matrix_char_2x8_column5> { typedef detail::matrix_char_2x8_column5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,6> matrix_char_2x8_column6; }template <> struct geometric_traits<detail::matrix_char_2x8_column6> { typedef detail::matrix_char_2x8_column6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x8,7> matrix_char_2x8_column7; }template <> struct geometric_traits<detail::matrix_char_2x8_column7> { typedef detail::matrix_char_2x8_column7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x8>::type > : index_operator_matrix_access_policy < matrix_char_2x8 > { typedef index_operator_matrix_access_policy < matrix_char_2x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x8 > { typedef dimension<2> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 9> matrix_char_2x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x9,0> matrix_char_2x9_row0; } template <> struct geometric_traits<detail::matrix_char_2x9_row0> { typedef detail::matrix_char_2x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x9,1> matrix_char_2x9_row1; } template <> struct geometric_traits<detail::matrix_char_2x9_row1> { typedef detail::matrix_char_2x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,0> matrix_char_2x9_column0; }template <> struct geometric_traits<detail::matrix_char_2x9_column0> { typedef detail::matrix_char_2x9_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,1> matrix_char_2x9_column1; }template <> struct geometric_traits<detail::matrix_char_2x9_column1> { typedef detail::matrix_char_2x9_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,2> matrix_char_2x9_column2; }template <> struct geometric_traits<detail::matrix_char_2x9_column2> { typedef detail::matrix_char_2x9_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,3> matrix_char_2x9_column3; }template <> struct geometric_traits<detail::matrix_char_2x9_column3> { typedef detail::matrix_char_2x9_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,4> matrix_char_2x9_column4; }template <> struct geometric_traits<detail::matrix_char_2x9_column4> { typedef detail::matrix_char_2x9_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,5> matrix_char_2x9_column5; }template <> struct geometric_traits<detail::matrix_char_2x9_column5> { typedef detail::matrix_char_2x9_column5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,6> matrix_char_2x9_column6; }template <> struct geometric_traits<detail::matrix_char_2x9_column6> { typedef detail::matrix_char_2x9_column6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,7> matrix_char_2x9_column7; }template <> struct geometric_traits<detail::matrix_char_2x9_column7> { typedef detail::matrix_char_2x9_column7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x9,8> matrix_char_2x9_column8; }template <> struct geometric_traits<detail::matrix_char_2x9_column8> { typedef detail::matrix_char_2x9_column8 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x9>::type > : index_operator_matrix_access_policy < matrix_char_2x9 > { typedef index_operator_matrix_access_policy < matrix_char_2x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x9 > { typedef dimension<2> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 2, 10> matrix_char_2x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x10,0> matrix_char_2x10_row0; } template <> struct geometric_traits<detail::matrix_char_2x10_row0> { typedef detail::matrix_char_2x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_2x10,1> matrix_char_2x10_row1; } template <> struct geometric_traits<detail::matrix_char_2x10_row1> { typedef detail::matrix_char_2x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,0> matrix_char_2x10_column0; }template <> struct geometric_traits<detail::matrix_char_2x10_column0> { typedef detail::matrix_char_2x10_column0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,1> matrix_char_2x10_column1; }template <> struct geometric_traits<detail::matrix_char_2x10_column1> { typedef detail::matrix_char_2x10_column1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,2> matrix_char_2x10_column2; }template <> struct geometric_traits<detail::matrix_char_2x10_column2> { typedef detail::matrix_char_2x10_column2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,3> matrix_char_2x10_column3; }template <> struct geometric_traits<detail::matrix_char_2x10_column3> { typedef detail::matrix_char_2x10_column3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,4> matrix_char_2x10_column4; }template <> struct geometric_traits<detail::matrix_char_2x10_column4> { typedef detail::matrix_char_2x10_column4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,5> matrix_char_2x10_column5; }template <> struct geometric_traits<detail::matrix_char_2x10_column5> { typedef detail::matrix_char_2x10_column5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,6> matrix_char_2x10_column6; }template <> struct geometric_traits<detail::matrix_char_2x10_column6> { typedef detail::matrix_char_2x10_column6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,7> matrix_char_2x10_column7; }template <> struct geometric_traits<detail::matrix_char_2x10_column7> { typedef detail::matrix_char_2x10_column7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,8> matrix_char_2x10_column8; }template <> struct geometric_traits<detail::matrix_char_2x10_column8> { typedef detail::matrix_char_2x10_column8 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_2x10,9> matrix_char_2x10_column9; }template <> struct geometric_traits<detail::matrix_char_2x10_column9> { typedef detail::matrix_char_2x10_column9 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_2x10>::type > : index_operator_matrix_access_policy < matrix_char_2x10 > { typedef index_operator_matrix_access_policy < matrix_char_2x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_2x10 > { typedef dimension<2> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 1> matrix_char_3x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x1,0> matrix_char_3x1_row0; } template <> struct geometric_traits<detail::matrix_char_3x1_row0> { typedef detail::matrix_char_3x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x1,1> matrix_char_3x1_row1; } template <> struct geometric_traits<detail::matrix_char_3x1_row1> { typedef detail::matrix_char_3x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x1,2> matrix_char_3x1_row2; } template <> struct geometric_traits<detail::matrix_char_3x1_row2> { typedef detail::matrix_char_3x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x1,0> matrix_char_3x1_column0; }template <> struct geometric_traits<detail::matrix_char_3x1_column0> { typedef detail::matrix_char_3x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x1>::type > : index_operator_matrix_access_policy < matrix_char_3x1 > { typedef index_operator_matrix_access_policy < matrix_char_3x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x1 > { typedef dimension<3> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 2> matrix_char_3x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x2,0> matrix_char_3x2_row0; } template <> struct geometric_traits<detail::matrix_char_3x2_row0> { typedef detail::matrix_char_3x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x2,1> matrix_char_3x2_row1; } template <> struct geometric_traits<detail::matrix_char_3x2_row1> { typedef detail::matrix_char_3x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x2,2> matrix_char_3x2_row2; } template <> struct geometric_traits<detail::matrix_char_3x2_row2> { typedef detail::matrix_char_3x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x2,0> matrix_char_3x2_column0; }template <> struct geometric_traits<detail::matrix_char_3x2_column0> { typedef detail::matrix_char_3x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x2,1> matrix_char_3x2_column1; }template <> struct geometric_traits<detail::matrix_char_3x2_column1> { typedef detail::matrix_char_3x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x2>::type > : index_operator_matrix_access_policy < matrix_char_3x2 > { typedef index_operator_matrix_access_policy < matrix_char_3x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x2 > { typedef dimension<3> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 3> matrix_char_3x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x3,0> matrix_char_3x3_row0; } template <> struct geometric_traits<detail::matrix_char_3x3_row0> { typedef detail::matrix_char_3x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x3,1> matrix_char_3x3_row1; } template <> struct geometric_traits<detail::matrix_char_3x3_row1> { typedef detail::matrix_char_3x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x3,2> matrix_char_3x3_row2; } template <> struct geometric_traits<detail::matrix_char_3x3_row2> { typedef detail::matrix_char_3x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x3,0> matrix_char_3x3_column0; }template <> struct geometric_traits<detail::matrix_char_3x3_column0> { typedef detail::matrix_char_3x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x3,1> matrix_char_3x3_column1; }template <> struct geometric_traits<detail::matrix_char_3x3_column1> { typedef detail::matrix_char_3x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x3,2> matrix_char_3x3_column2; }template <> struct geometric_traits<detail::matrix_char_3x3_column2> { typedef detail::matrix_char_3x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x3>::type > : index_operator_matrix_access_policy < matrix_char_3x3 > { typedef index_operator_matrix_access_policy < matrix_char_3x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x3 > { typedef dimension<3> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 4> matrix_char_3x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x4,0> matrix_char_3x4_row0; } template <> struct geometric_traits<detail::matrix_char_3x4_row0> { typedef detail::matrix_char_3x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x4,1> matrix_char_3x4_row1; } template <> struct geometric_traits<detail::matrix_char_3x4_row1> { typedef detail::matrix_char_3x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x4,2> matrix_char_3x4_row2; } template <> struct geometric_traits<detail::matrix_char_3x4_row2> { typedef detail::matrix_char_3x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x4,0> matrix_char_3x4_column0; }template <> struct geometric_traits<detail::matrix_char_3x4_column0> { typedef detail::matrix_char_3x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x4,1> matrix_char_3x4_column1; }template <> struct geometric_traits<detail::matrix_char_3x4_column1> { typedef detail::matrix_char_3x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x4,2> matrix_char_3x4_column2; }template <> struct geometric_traits<detail::matrix_char_3x4_column2> { typedef detail::matrix_char_3x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x4,3> matrix_char_3x4_column3; }template <> struct geometric_traits<detail::matrix_char_3x4_column3> { typedef detail::matrix_char_3x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x4>::type > : index_operator_matrix_access_policy < matrix_char_3x4 > { typedef index_operator_matrix_access_policy < matrix_char_3x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x4 > { typedef dimension<3> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 5> matrix_char_3x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x5,0> matrix_char_3x5_row0; } template <> struct geometric_traits<detail::matrix_char_3x5_row0> { typedef detail::matrix_char_3x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x5,1> matrix_char_3x5_row1; } template <> struct geometric_traits<detail::matrix_char_3x5_row1> { typedef detail::matrix_char_3x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x5,2> matrix_char_3x5_row2; } template <> struct geometric_traits<detail::matrix_char_3x5_row2> { typedef detail::matrix_char_3x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x5,0> matrix_char_3x5_column0; }template <> struct geometric_traits<detail::matrix_char_3x5_column0> { typedef detail::matrix_char_3x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x5,1> matrix_char_3x5_column1; }template <> struct geometric_traits<detail::matrix_char_3x5_column1> { typedef detail::matrix_char_3x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x5,2> matrix_char_3x5_column2; }template <> struct geometric_traits<detail::matrix_char_3x5_column2> { typedef detail::matrix_char_3x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x5,3> matrix_char_3x5_column3; }template <> struct geometric_traits<detail::matrix_char_3x5_column3> { typedef detail::matrix_char_3x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x5,4> matrix_char_3x5_column4; }template <> struct geometric_traits<detail::matrix_char_3x5_column4> { typedef detail::matrix_char_3x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x5>::type > : index_operator_matrix_access_policy < matrix_char_3x5 > { typedef index_operator_matrix_access_policy < matrix_char_3x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x5 > { typedef dimension<3> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 6> matrix_char_3x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x6,0> matrix_char_3x6_row0; } template <> struct geometric_traits<detail::matrix_char_3x6_row0> { typedef detail::matrix_char_3x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x6,1> matrix_char_3x6_row1; } template <> struct geometric_traits<detail::matrix_char_3x6_row1> { typedef detail::matrix_char_3x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x6,2> matrix_char_3x6_row2; } template <> struct geometric_traits<detail::matrix_char_3x6_row2> { typedef detail::matrix_char_3x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,0> matrix_char_3x6_column0; }template <> struct geometric_traits<detail::matrix_char_3x6_column0> { typedef detail::matrix_char_3x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,1> matrix_char_3x6_column1; }template <> struct geometric_traits<detail::matrix_char_3x6_column1> { typedef detail::matrix_char_3x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,2> matrix_char_3x6_column2; }template <> struct geometric_traits<detail::matrix_char_3x6_column2> { typedef detail::matrix_char_3x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,3> matrix_char_3x6_column3; }template <> struct geometric_traits<detail::matrix_char_3x6_column3> { typedef detail::matrix_char_3x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,4> matrix_char_3x6_column4; }template <> struct geometric_traits<detail::matrix_char_3x6_column4> { typedef detail::matrix_char_3x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x6,5> matrix_char_3x6_column5; }template <> struct geometric_traits<detail::matrix_char_3x6_column5> { typedef detail::matrix_char_3x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x6>::type > : index_operator_matrix_access_policy < matrix_char_3x6 > { typedef index_operator_matrix_access_policy < matrix_char_3x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x6 > { typedef dimension<3> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 7> matrix_char_3x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x7,0> matrix_char_3x7_row0; } template <> struct geometric_traits<detail::matrix_char_3x7_row0> { typedef detail::matrix_char_3x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x7,1> matrix_char_3x7_row1; } template <> struct geometric_traits<detail::matrix_char_3x7_row1> { typedef detail::matrix_char_3x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x7,2> matrix_char_3x7_row2; } template <> struct geometric_traits<detail::matrix_char_3x7_row2> { typedef detail::matrix_char_3x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,0> matrix_char_3x7_column0; }template <> struct geometric_traits<detail::matrix_char_3x7_column0> { typedef detail::matrix_char_3x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,1> matrix_char_3x7_column1; }template <> struct geometric_traits<detail::matrix_char_3x7_column1> { typedef detail::matrix_char_3x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,2> matrix_char_3x7_column2; }template <> struct geometric_traits<detail::matrix_char_3x7_column2> { typedef detail::matrix_char_3x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,3> matrix_char_3x7_column3; }template <> struct geometric_traits<detail::matrix_char_3x7_column3> { typedef detail::matrix_char_3x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,4> matrix_char_3x7_column4; }template <> struct geometric_traits<detail::matrix_char_3x7_column4> { typedef detail::matrix_char_3x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,5> matrix_char_3x7_column5; }template <> struct geometric_traits<detail::matrix_char_3x7_column5> { typedef detail::matrix_char_3x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x7,6> matrix_char_3x7_column6; }template <> struct geometric_traits<detail::matrix_char_3x7_column6> { typedef detail::matrix_char_3x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x7>::type > : index_operator_matrix_access_policy < matrix_char_3x7 > { typedef index_operator_matrix_access_policy < matrix_char_3x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x7 > { typedef dimension<3> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 8> matrix_char_3x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x8,0> matrix_char_3x8_row0; } template <> struct geometric_traits<detail::matrix_char_3x8_row0> { typedef detail::matrix_char_3x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x8,1> matrix_char_3x8_row1; } template <> struct geometric_traits<detail::matrix_char_3x8_row1> { typedef detail::matrix_char_3x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x8,2> matrix_char_3x8_row2; } template <> struct geometric_traits<detail::matrix_char_3x8_row2> { typedef detail::matrix_char_3x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,0> matrix_char_3x8_column0; }template <> struct geometric_traits<detail::matrix_char_3x8_column0> { typedef detail::matrix_char_3x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,1> matrix_char_3x8_column1; }template <> struct geometric_traits<detail::matrix_char_3x8_column1> { typedef detail::matrix_char_3x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,2> matrix_char_3x8_column2; }template <> struct geometric_traits<detail::matrix_char_3x8_column2> { typedef detail::matrix_char_3x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,3> matrix_char_3x8_column3; }template <> struct geometric_traits<detail::matrix_char_3x8_column3> { typedef detail::matrix_char_3x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,4> matrix_char_3x8_column4; }template <> struct geometric_traits<detail::matrix_char_3x8_column4> { typedef detail::matrix_char_3x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,5> matrix_char_3x8_column5; }template <> struct geometric_traits<detail::matrix_char_3x8_column5> { typedef detail::matrix_char_3x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,6> matrix_char_3x8_column6; }template <> struct geometric_traits<detail::matrix_char_3x8_column6> { typedef detail::matrix_char_3x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x8,7> matrix_char_3x8_column7; }template <> struct geometric_traits<detail::matrix_char_3x8_column7> { typedef detail::matrix_char_3x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x8>::type > : index_operator_matrix_access_policy < matrix_char_3x8 > { typedef index_operator_matrix_access_policy < matrix_char_3x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x8 > { typedef dimension<3> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 9> matrix_char_3x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x9,0> matrix_char_3x9_row0; } template <> struct geometric_traits<detail::matrix_char_3x9_row0> { typedef detail::matrix_char_3x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x9,1> matrix_char_3x9_row1; } template <> struct geometric_traits<detail::matrix_char_3x9_row1> { typedef detail::matrix_char_3x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x9,2> matrix_char_3x9_row2; } template <> struct geometric_traits<detail::matrix_char_3x9_row2> { typedef detail::matrix_char_3x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,0> matrix_char_3x9_column0; }template <> struct geometric_traits<detail::matrix_char_3x9_column0> { typedef detail::matrix_char_3x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,1> matrix_char_3x9_column1; }template <> struct geometric_traits<detail::matrix_char_3x9_column1> { typedef detail::matrix_char_3x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,2> matrix_char_3x9_column2; }template <> struct geometric_traits<detail::matrix_char_3x9_column2> { typedef detail::matrix_char_3x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,3> matrix_char_3x9_column3; }template <> struct geometric_traits<detail::matrix_char_3x9_column3> { typedef detail::matrix_char_3x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,4> matrix_char_3x9_column4; }template <> struct geometric_traits<detail::matrix_char_3x9_column4> { typedef detail::matrix_char_3x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,5> matrix_char_3x9_column5; }template <> struct geometric_traits<detail::matrix_char_3x9_column5> { typedef detail::matrix_char_3x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,6> matrix_char_3x9_column6; }template <> struct geometric_traits<detail::matrix_char_3x9_column6> { typedef detail::matrix_char_3x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,7> matrix_char_3x9_column7; }template <> struct geometric_traits<detail::matrix_char_3x9_column7> { typedef detail::matrix_char_3x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x9,8> matrix_char_3x9_column8; }template <> struct geometric_traits<detail::matrix_char_3x9_column8> { typedef detail::matrix_char_3x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x9>::type > : index_operator_matrix_access_policy < matrix_char_3x9 > { typedef index_operator_matrix_access_policy < matrix_char_3x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x9 > { typedef dimension<3> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 3, 10> matrix_char_3x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x10,0> matrix_char_3x10_row0; } template <> struct geometric_traits<detail::matrix_char_3x10_row0> { typedef detail::matrix_char_3x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x10,1> matrix_char_3x10_row1; } template <> struct geometric_traits<detail::matrix_char_3x10_row1> { typedef detail::matrix_char_3x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_3x10,2> matrix_char_3x10_row2; } template <> struct geometric_traits<detail::matrix_char_3x10_row2> { typedef detail::matrix_char_3x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,0> matrix_char_3x10_column0; }template <> struct geometric_traits<detail::matrix_char_3x10_column0> { typedef detail::matrix_char_3x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,1> matrix_char_3x10_column1; }template <> struct geometric_traits<detail::matrix_char_3x10_column1> { typedef detail::matrix_char_3x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,2> matrix_char_3x10_column2; }template <> struct geometric_traits<detail::matrix_char_3x10_column2> { typedef detail::matrix_char_3x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,3> matrix_char_3x10_column3; }template <> struct geometric_traits<detail::matrix_char_3x10_column3> { typedef detail::matrix_char_3x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,4> matrix_char_3x10_column4; }template <> struct geometric_traits<detail::matrix_char_3x10_column4> { typedef detail::matrix_char_3x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,5> matrix_char_3x10_column5; }template <> struct geometric_traits<detail::matrix_char_3x10_column5> { typedef detail::matrix_char_3x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,6> matrix_char_3x10_column6; }template <> struct geometric_traits<detail::matrix_char_3x10_column6> { typedef detail::matrix_char_3x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,7> matrix_char_3x10_column7; }template <> struct geometric_traits<detail::matrix_char_3x10_column7> { typedef detail::matrix_char_3x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,8> matrix_char_3x10_column8; }template <> struct geometric_traits<detail::matrix_char_3x10_column8> { typedef detail::matrix_char_3x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_3x10,9> matrix_char_3x10_column9; }template <> struct geometric_traits<detail::matrix_char_3x10_column9> { typedef detail::matrix_char_3x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_3x10>::type > : index_operator_matrix_access_policy < matrix_char_3x10 > { typedef index_operator_matrix_access_policy < matrix_char_3x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_3x10 > { typedef dimension<3> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 1> matrix_char_4x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x1,0> matrix_char_4x1_row0; } template <> struct geometric_traits<detail::matrix_char_4x1_row0> { typedef detail::matrix_char_4x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x1,1> matrix_char_4x1_row1; } template <> struct geometric_traits<detail::matrix_char_4x1_row1> { typedef detail::matrix_char_4x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x1,2> matrix_char_4x1_row2; } template <> struct geometric_traits<detail::matrix_char_4x1_row2> { typedef detail::matrix_char_4x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x1,3> matrix_char_4x1_row3; } template <> struct geometric_traits<detail::matrix_char_4x1_row3> { typedef detail::matrix_char_4x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x1,0> matrix_char_4x1_column0; }template <> struct geometric_traits<detail::matrix_char_4x1_column0> { typedef detail::matrix_char_4x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x1>::type > : index_operator_matrix_access_policy < matrix_char_4x1 > { typedef index_operator_matrix_access_policy < matrix_char_4x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x1 > { typedef dimension<4> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 2> matrix_char_4x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x2,0> matrix_char_4x2_row0; } template <> struct geometric_traits<detail::matrix_char_4x2_row0> { typedef detail::matrix_char_4x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x2,1> matrix_char_4x2_row1; } template <> struct geometric_traits<detail::matrix_char_4x2_row1> { typedef detail::matrix_char_4x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x2,2> matrix_char_4x2_row2; } template <> struct geometric_traits<detail::matrix_char_4x2_row2> { typedef detail::matrix_char_4x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x2,3> matrix_char_4x2_row3; } template <> struct geometric_traits<detail::matrix_char_4x2_row3> { typedef detail::matrix_char_4x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x2,0> matrix_char_4x2_column0; }template <> struct geometric_traits<detail::matrix_char_4x2_column0> { typedef detail::matrix_char_4x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x2,1> matrix_char_4x2_column1; }template <> struct geometric_traits<detail::matrix_char_4x2_column1> { typedef detail::matrix_char_4x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x2>::type > : index_operator_matrix_access_policy < matrix_char_4x2 > { typedef index_operator_matrix_access_policy < matrix_char_4x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x2 > { typedef dimension<4> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 3> matrix_char_4x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x3,0> matrix_char_4x3_row0; } template <> struct geometric_traits<detail::matrix_char_4x3_row0> { typedef detail::matrix_char_4x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x3,1> matrix_char_4x3_row1; } template <> struct geometric_traits<detail::matrix_char_4x3_row1> { typedef detail::matrix_char_4x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x3,2> matrix_char_4x3_row2; } template <> struct geometric_traits<detail::matrix_char_4x3_row2> { typedef detail::matrix_char_4x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x3,3> matrix_char_4x3_row3; } template <> struct geometric_traits<detail::matrix_char_4x3_row3> { typedef detail::matrix_char_4x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x3,0> matrix_char_4x3_column0; }template <> struct geometric_traits<detail::matrix_char_4x3_column0> { typedef detail::matrix_char_4x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x3,1> matrix_char_4x3_column1; }template <> struct geometric_traits<detail::matrix_char_4x3_column1> { typedef detail::matrix_char_4x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x3,2> matrix_char_4x3_column2; }template <> struct geometric_traits<detail::matrix_char_4x3_column2> { typedef detail::matrix_char_4x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x3>::type > : index_operator_matrix_access_policy < matrix_char_4x3 > { typedef index_operator_matrix_access_policy < matrix_char_4x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x3 > { typedef dimension<4> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 4> matrix_char_4x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x4,0> matrix_char_4x4_row0; } template <> struct geometric_traits<detail::matrix_char_4x4_row0> { typedef detail::matrix_char_4x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x4,1> matrix_char_4x4_row1; } template <> struct geometric_traits<detail::matrix_char_4x4_row1> { typedef detail::matrix_char_4x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x4,2> matrix_char_4x4_row2; } template <> struct geometric_traits<detail::matrix_char_4x4_row2> { typedef detail::matrix_char_4x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x4,3> matrix_char_4x4_row3; } template <> struct geometric_traits<detail::matrix_char_4x4_row3> { typedef detail::matrix_char_4x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x4,0> matrix_char_4x4_column0; }template <> struct geometric_traits<detail::matrix_char_4x4_column0> { typedef detail::matrix_char_4x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x4,1> matrix_char_4x4_column1; }template <> struct geometric_traits<detail::matrix_char_4x4_column1> { typedef detail::matrix_char_4x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x4,2> matrix_char_4x4_column2; }template <> struct geometric_traits<detail::matrix_char_4x4_column2> { typedef detail::matrix_char_4x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x4,3> matrix_char_4x4_column3; }template <> struct geometric_traits<detail::matrix_char_4x4_column3> { typedef detail::matrix_char_4x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x4>::type > : index_operator_matrix_access_policy < matrix_char_4x4 > { typedef index_operator_matrix_access_policy < matrix_char_4x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x4 > { typedef dimension<4> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 5> matrix_char_4x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x5,0> matrix_char_4x5_row0; } template <> struct geometric_traits<detail::matrix_char_4x5_row0> { typedef detail::matrix_char_4x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x5,1> matrix_char_4x5_row1; } template <> struct geometric_traits<detail::matrix_char_4x5_row1> { typedef detail::matrix_char_4x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x5,2> matrix_char_4x5_row2; } template <> struct geometric_traits<detail::matrix_char_4x5_row2> { typedef detail::matrix_char_4x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x5,3> matrix_char_4x5_row3; } template <> struct geometric_traits<detail::matrix_char_4x5_row3> { typedef detail::matrix_char_4x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x5,0> matrix_char_4x5_column0; }template <> struct geometric_traits<detail::matrix_char_4x5_column0> { typedef detail::matrix_char_4x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x5,1> matrix_char_4x5_column1; }template <> struct geometric_traits<detail::matrix_char_4x5_column1> { typedef detail::matrix_char_4x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x5,2> matrix_char_4x5_column2; }template <> struct geometric_traits<detail::matrix_char_4x5_column2> { typedef detail::matrix_char_4x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x5,3> matrix_char_4x5_column3; }template <> struct geometric_traits<detail::matrix_char_4x5_column3> { typedef detail::matrix_char_4x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x5,4> matrix_char_4x5_column4; }template <> struct geometric_traits<detail::matrix_char_4x5_column4> { typedef detail::matrix_char_4x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x5>::type > : index_operator_matrix_access_policy < matrix_char_4x5 > { typedef index_operator_matrix_access_policy < matrix_char_4x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x5 > { typedef dimension<4> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 6> matrix_char_4x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x6,0> matrix_char_4x6_row0; } template <> struct geometric_traits<detail::matrix_char_4x6_row0> { typedef detail::matrix_char_4x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x6,1> matrix_char_4x6_row1; } template <> struct geometric_traits<detail::matrix_char_4x6_row1> { typedef detail::matrix_char_4x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x6,2> matrix_char_4x6_row2; } template <> struct geometric_traits<detail::matrix_char_4x6_row2> { typedef detail::matrix_char_4x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x6,3> matrix_char_4x6_row3; } template <> struct geometric_traits<detail::matrix_char_4x6_row3> { typedef detail::matrix_char_4x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,0> matrix_char_4x6_column0; }template <> struct geometric_traits<detail::matrix_char_4x6_column0> { typedef detail::matrix_char_4x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,1> matrix_char_4x6_column1; }template <> struct geometric_traits<detail::matrix_char_4x6_column1> { typedef detail::matrix_char_4x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,2> matrix_char_4x6_column2; }template <> struct geometric_traits<detail::matrix_char_4x6_column2> { typedef detail::matrix_char_4x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,3> matrix_char_4x6_column3; }template <> struct geometric_traits<detail::matrix_char_4x6_column3> { typedef detail::matrix_char_4x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,4> matrix_char_4x6_column4; }template <> struct geometric_traits<detail::matrix_char_4x6_column4> { typedef detail::matrix_char_4x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x6,5> matrix_char_4x6_column5; }template <> struct geometric_traits<detail::matrix_char_4x6_column5> { typedef detail::matrix_char_4x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x6>::type > : index_operator_matrix_access_policy < matrix_char_4x6 > { typedef index_operator_matrix_access_policy < matrix_char_4x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x6 > { typedef dimension<4> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 7> matrix_char_4x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x7,0> matrix_char_4x7_row0; } template <> struct geometric_traits<detail::matrix_char_4x7_row0> { typedef detail::matrix_char_4x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x7,1> matrix_char_4x7_row1; } template <> struct geometric_traits<detail::matrix_char_4x7_row1> { typedef detail::matrix_char_4x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x7,2> matrix_char_4x7_row2; } template <> struct geometric_traits<detail::matrix_char_4x7_row2> { typedef detail::matrix_char_4x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x7,3> matrix_char_4x7_row3; } template <> struct geometric_traits<detail::matrix_char_4x7_row3> { typedef detail::matrix_char_4x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,0> matrix_char_4x7_column0; }template <> struct geometric_traits<detail::matrix_char_4x7_column0> { typedef detail::matrix_char_4x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,1> matrix_char_4x7_column1; }template <> struct geometric_traits<detail::matrix_char_4x7_column1> { typedef detail::matrix_char_4x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,2> matrix_char_4x7_column2; }template <> struct geometric_traits<detail::matrix_char_4x7_column2> { typedef detail::matrix_char_4x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,3> matrix_char_4x7_column3; }template <> struct geometric_traits<detail::matrix_char_4x7_column3> { typedef detail::matrix_char_4x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,4> matrix_char_4x7_column4; }template <> struct geometric_traits<detail::matrix_char_4x7_column4> { typedef detail::matrix_char_4x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,5> matrix_char_4x7_column5; }template <> struct geometric_traits<detail::matrix_char_4x7_column5> { typedef detail::matrix_char_4x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x7,6> matrix_char_4x7_column6; }template <> struct geometric_traits<detail::matrix_char_4x7_column6> { typedef detail::matrix_char_4x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x7>::type > : index_operator_matrix_access_policy < matrix_char_4x7 > { typedef index_operator_matrix_access_policy < matrix_char_4x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x7 > { typedef dimension<4> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 8> matrix_char_4x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x8,0> matrix_char_4x8_row0; } template <> struct geometric_traits<detail::matrix_char_4x8_row0> { typedef detail::matrix_char_4x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x8,1> matrix_char_4x8_row1; } template <> struct geometric_traits<detail::matrix_char_4x8_row1> { typedef detail::matrix_char_4x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x8,2> matrix_char_4x8_row2; } template <> struct geometric_traits<detail::matrix_char_4x8_row2> { typedef detail::matrix_char_4x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x8,3> matrix_char_4x8_row3; } template <> struct geometric_traits<detail::matrix_char_4x8_row3> { typedef detail::matrix_char_4x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,0> matrix_char_4x8_column0; }template <> struct geometric_traits<detail::matrix_char_4x8_column0> { typedef detail::matrix_char_4x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,1> matrix_char_4x8_column1; }template <> struct geometric_traits<detail::matrix_char_4x8_column1> { typedef detail::matrix_char_4x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,2> matrix_char_4x8_column2; }template <> struct geometric_traits<detail::matrix_char_4x8_column2> { typedef detail::matrix_char_4x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,3> matrix_char_4x8_column3; }template <> struct geometric_traits<detail::matrix_char_4x8_column3> { typedef detail::matrix_char_4x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,4> matrix_char_4x8_column4; }template <> struct geometric_traits<detail::matrix_char_4x8_column4> { typedef detail::matrix_char_4x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,5> matrix_char_4x8_column5; }template <> struct geometric_traits<detail::matrix_char_4x8_column5> { typedef detail::matrix_char_4x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,6> matrix_char_4x8_column6; }template <> struct geometric_traits<detail::matrix_char_4x8_column6> { typedef detail::matrix_char_4x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x8,7> matrix_char_4x8_column7; }template <> struct geometric_traits<detail::matrix_char_4x8_column7> { typedef detail::matrix_char_4x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x8>::type > : index_operator_matrix_access_policy < matrix_char_4x8 > { typedef index_operator_matrix_access_policy < matrix_char_4x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x8 > { typedef dimension<4> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 9> matrix_char_4x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x9,0> matrix_char_4x9_row0; } template <> struct geometric_traits<detail::matrix_char_4x9_row0> { typedef detail::matrix_char_4x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x9,1> matrix_char_4x9_row1; } template <> struct geometric_traits<detail::matrix_char_4x9_row1> { typedef detail::matrix_char_4x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x9,2> matrix_char_4x9_row2; } template <> struct geometric_traits<detail::matrix_char_4x9_row2> { typedef detail::matrix_char_4x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x9,3> matrix_char_4x9_row3; } template <> struct geometric_traits<detail::matrix_char_4x9_row3> { typedef detail::matrix_char_4x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,0> matrix_char_4x9_column0; }template <> struct geometric_traits<detail::matrix_char_4x9_column0> { typedef detail::matrix_char_4x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,1> matrix_char_4x9_column1; }template <> struct geometric_traits<detail::matrix_char_4x9_column1> { typedef detail::matrix_char_4x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,2> matrix_char_4x9_column2; }template <> struct geometric_traits<detail::matrix_char_4x9_column2> { typedef detail::matrix_char_4x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,3> matrix_char_4x9_column3; }template <> struct geometric_traits<detail::matrix_char_4x9_column3> { typedef detail::matrix_char_4x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,4> matrix_char_4x9_column4; }template <> struct geometric_traits<detail::matrix_char_4x9_column4> { typedef detail::matrix_char_4x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,5> matrix_char_4x9_column5; }template <> struct geometric_traits<detail::matrix_char_4x9_column5> { typedef detail::matrix_char_4x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,6> matrix_char_4x9_column6; }template <> struct geometric_traits<detail::matrix_char_4x9_column6> { typedef detail::matrix_char_4x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,7> matrix_char_4x9_column7; }template <> struct geometric_traits<detail::matrix_char_4x9_column7> { typedef detail::matrix_char_4x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x9,8> matrix_char_4x9_column8; }template <> struct geometric_traits<detail::matrix_char_4x9_column8> { typedef detail::matrix_char_4x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x9>::type > : index_operator_matrix_access_policy < matrix_char_4x9 > { typedef index_operator_matrix_access_policy < matrix_char_4x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x9 > { typedef dimension<4> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 4, 10> matrix_char_4x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x10,0> matrix_char_4x10_row0; } template <> struct geometric_traits<detail::matrix_char_4x10_row0> { typedef detail::matrix_char_4x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x10,1> matrix_char_4x10_row1; } template <> struct geometric_traits<detail::matrix_char_4x10_row1> { typedef detail::matrix_char_4x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x10,2> matrix_char_4x10_row2; } template <> struct geometric_traits<detail::matrix_char_4x10_row2> { typedef detail::matrix_char_4x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_4x10,3> matrix_char_4x10_row3; } template <> struct geometric_traits<detail::matrix_char_4x10_row3> { typedef detail::matrix_char_4x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,0> matrix_char_4x10_column0; }template <> struct geometric_traits<detail::matrix_char_4x10_column0> { typedef detail::matrix_char_4x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,1> matrix_char_4x10_column1; }template <> struct geometric_traits<detail::matrix_char_4x10_column1> { typedef detail::matrix_char_4x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,2> matrix_char_4x10_column2; }template <> struct geometric_traits<detail::matrix_char_4x10_column2> { typedef detail::matrix_char_4x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,3> matrix_char_4x10_column3; }template <> struct geometric_traits<detail::matrix_char_4x10_column3> { typedef detail::matrix_char_4x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,4> matrix_char_4x10_column4; }template <> struct geometric_traits<detail::matrix_char_4x10_column4> { typedef detail::matrix_char_4x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,5> matrix_char_4x10_column5; }template <> struct geometric_traits<detail::matrix_char_4x10_column5> { typedef detail::matrix_char_4x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,6> matrix_char_4x10_column6; }template <> struct geometric_traits<detail::matrix_char_4x10_column6> { typedef detail::matrix_char_4x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,7> matrix_char_4x10_column7; }template <> struct geometric_traits<detail::matrix_char_4x10_column7> { typedef detail::matrix_char_4x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,8> matrix_char_4x10_column8; }template <> struct geometric_traits<detail::matrix_char_4x10_column8> { typedef detail::matrix_char_4x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_4x10,9> matrix_char_4x10_column9; }template <> struct geometric_traits<detail::matrix_char_4x10_column9> { typedef detail::matrix_char_4x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_4x10>::type > : index_operator_matrix_access_policy < matrix_char_4x10 > { typedef index_operator_matrix_access_policy < matrix_char_4x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_4x10 > { typedef dimension<4> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 1> matrix_char_5x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x1,0> matrix_char_5x1_row0; } template <> struct geometric_traits<detail::matrix_char_5x1_row0> { typedef detail::matrix_char_5x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x1,1> matrix_char_5x1_row1; } template <> struct geometric_traits<detail::matrix_char_5x1_row1> { typedef detail::matrix_char_5x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x1,2> matrix_char_5x1_row2; } template <> struct geometric_traits<detail::matrix_char_5x1_row2> { typedef detail::matrix_char_5x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x1,3> matrix_char_5x1_row3; } template <> struct geometric_traits<detail::matrix_char_5x1_row3> { typedef detail::matrix_char_5x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x1,4> matrix_char_5x1_row4; } template <> struct geometric_traits<detail::matrix_char_5x1_row4> { typedef detail::matrix_char_5x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x1,0> matrix_char_5x1_column0; }template <> struct geometric_traits<detail::matrix_char_5x1_column0> { typedef detail::matrix_char_5x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x1>::type > : index_operator_matrix_access_policy < matrix_char_5x1 > { typedef index_operator_matrix_access_policy < matrix_char_5x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x1 > { typedef dimension<5> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 2> matrix_char_5x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x2,0> matrix_char_5x2_row0; } template <> struct geometric_traits<detail::matrix_char_5x2_row0> { typedef detail::matrix_char_5x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x2,1> matrix_char_5x2_row1; } template <> struct geometric_traits<detail::matrix_char_5x2_row1> { typedef detail::matrix_char_5x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x2,2> matrix_char_5x2_row2; } template <> struct geometric_traits<detail::matrix_char_5x2_row2> { typedef detail::matrix_char_5x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x2,3> matrix_char_5x2_row3; } template <> struct geometric_traits<detail::matrix_char_5x2_row3> { typedef detail::matrix_char_5x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x2,4> matrix_char_5x2_row4; } template <> struct geometric_traits<detail::matrix_char_5x2_row4> { typedef detail::matrix_char_5x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x2,0> matrix_char_5x2_column0; }template <> struct geometric_traits<detail::matrix_char_5x2_column0> { typedef detail::matrix_char_5x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x2,1> matrix_char_5x2_column1; }template <> struct geometric_traits<detail::matrix_char_5x2_column1> { typedef detail::matrix_char_5x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x2>::type > : index_operator_matrix_access_policy < matrix_char_5x2 > { typedef index_operator_matrix_access_policy < matrix_char_5x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x2 > { typedef dimension<5> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 3> matrix_char_5x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x3,0> matrix_char_5x3_row0; } template <> struct geometric_traits<detail::matrix_char_5x3_row0> { typedef detail::matrix_char_5x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x3,1> matrix_char_5x3_row1; } template <> struct geometric_traits<detail::matrix_char_5x3_row1> { typedef detail::matrix_char_5x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x3,2> matrix_char_5x3_row2; } template <> struct geometric_traits<detail::matrix_char_5x3_row2> { typedef detail::matrix_char_5x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x3,3> matrix_char_5x3_row3; } template <> struct geometric_traits<detail::matrix_char_5x3_row3> { typedef detail::matrix_char_5x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x3,4> matrix_char_5x3_row4; } template <> struct geometric_traits<detail::matrix_char_5x3_row4> { typedef detail::matrix_char_5x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x3,0> matrix_char_5x3_column0; }template <> struct geometric_traits<detail::matrix_char_5x3_column0> { typedef detail::matrix_char_5x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x3,1> matrix_char_5x3_column1; }template <> struct geometric_traits<detail::matrix_char_5x3_column1> { typedef detail::matrix_char_5x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x3,2> matrix_char_5x3_column2; }template <> struct geometric_traits<detail::matrix_char_5x3_column2> { typedef detail::matrix_char_5x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x3>::type > : index_operator_matrix_access_policy < matrix_char_5x3 > { typedef index_operator_matrix_access_policy < matrix_char_5x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x3 > { typedef dimension<5> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 4> matrix_char_5x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x4,0> matrix_char_5x4_row0; } template <> struct geometric_traits<detail::matrix_char_5x4_row0> { typedef detail::matrix_char_5x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x4,1> matrix_char_5x4_row1; } template <> struct geometric_traits<detail::matrix_char_5x4_row1> { typedef detail::matrix_char_5x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x4,2> matrix_char_5x4_row2; } template <> struct geometric_traits<detail::matrix_char_5x4_row2> { typedef detail::matrix_char_5x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x4,3> matrix_char_5x4_row3; } template <> struct geometric_traits<detail::matrix_char_5x4_row3> { typedef detail::matrix_char_5x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x4,4> matrix_char_5x4_row4; } template <> struct geometric_traits<detail::matrix_char_5x4_row4> { typedef detail::matrix_char_5x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x4,0> matrix_char_5x4_column0; }template <> struct geometric_traits<detail::matrix_char_5x4_column0> { typedef detail::matrix_char_5x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x4,1> matrix_char_5x4_column1; }template <> struct geometric_traits<detail::matrix_char_5x4_column1> { typedef detail::matrix_char_5x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x4,2> matrix_char_5x4_column2; }template <> struct geometric_traits<detail::matrix_char_5x4_column2> { typedef detail::matrix_char_5x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x4,3> matrix_char_5x4_column3; }template <> struct geometric_traits<detail::matrix_char_5x4_column3> { typedef detail::matrix_char_5x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x4>::type > : index_operator_matrix_access_policy < matrix_char_5x4 > { typedef index_operator_matrix_access_policy < matrix_char_5x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x4 > { typedef dimension<5> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 5> matrix_char_5x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x5,0> matrix_char_5x5_row0; } template <> struct geometric_traits<detail::matrix_char_5x5_row0> { typedef detail::matrix_char_5x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x5,1> matrix_char_5x5_row1; } template <> struct geometric_traits<detail::matrix_char_5x5_row1> { typedef detail::matrix_char_5x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x5,2> matrix_char_5x5_row2; } template <> struct geometric_traits<detail::matrix_char_5x5_row2> { typedef detail::matrix_char_5x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x5,3> matrix_char_5x5_row3; } template <> struct geometric_traits<detail::matrix_char_5x5_row3> { typedef detail::matrix_char_5x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x5,4> matrix_char_5x5_row4; } template <> struct geometric_traits<detail::matrix_char_5x5_row4> { typedef detail::matrix_char_5x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x5,0> matrix_char_5x5_column0; }template <> struct geometric_traits<detail::matrix_char_5x5_column0> { typedef detail::matrix_char_5x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x5,1> matrix_char_5x5_column1; }template <> struct geometric_traits<detail::matrix_char_5x5_column1> { typedef detail::matrix_char_5x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x5,2> matrix_char_5x5_column2; }template <> struct geometric_traits<detail::matrix_char_5x5_column2> { typedef detail::matrix_char_5x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x5,3> matrix_char_5x5_column3; }template <> struct geometric_traits<detail::matrix_char_5x5_column3> { typedef detail::matrix_char_5x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x5,4> matrix_char_5x5_column4; }template <> struct geometric_traits<detail::matrix_char_5x5_column4> { typedef detail::matrix_char_5x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x5>::type > : index_operator_matrix_access_policy < matrix_char_5x5 > { typedef index_operator_matrix_access_policy < matrix_char_5x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x5 > { typedef dimension<5> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 6> matrix_char_5x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x6,0> matrix_char_5x6_row0; } template <> struct geometric_traits<detail::matrix_char_5x6_row0> { typedef detail::matrix_char_5x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x6,1> matrix_char_5x6_row1; } template <> struct geometric_traits<detail::matrix_char_5x6_row1> { typedef detail::matrix_char_5x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x6,2> matrix_char_5x6_row2; } template <> struct geometric_traits<detail::matrix_char_5x6_row2> { typedef detail::matrix_char_5x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x6,3> matrix_char_5x6_row3; } template <> struct geometric_traits<detail::matrix_char_5x6_row3> { typedef detail::matrix_char_5x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x6,4> matrix_char_5x6_row4; } template <> struct geometric_traits<detail::matrix_char_5x6_row4> { typedef detail::matrix_char_5x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,0> matrix_char_5x6_column0; }template <> struct geometric_traits<detail::matrix_char_5x6_column0> { typedef detail::matrix_char_5x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,1> matrix_char_5x6_column1; }template <> struct geometric_traits<detail::matrix_char_5x6_column1> { typedef detail::matrix_char_5x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,2> matrix_char_5x6_column2; }template <> struct geometric_traits<detail::matrix_char_5x6_column2> { typedef detail::matrix_char_5x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,3> matrix_char_5x6_column3; }template <> struct geometric_traits<detail::matrix_char_5x6_column3> { typedef detail::matrix_char_5x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,4> matrix_char_5x6_column4; }template <> struct geometric_traits<detail::matrix_char_5x6_column4> { typedef detail::matrix_char_5x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x6,5> matrix_char_5x6_column5; }template <> struct geometric_traits<detail::matrix_char_5x6_column5> { typedef detail::matrix_char_5x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x6>::type > : index_operator_matrix_access_policy < matrix_char_5x6 > { typedef index_operator_matrix_access_policy < matrix_char_5x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x6 > { typedef dimension<5> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 7> matrix_char_5x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x7,0> matrix_char_5x7_row0; } template <> struct geometric_traits<detail::matrix_char_5x7_row0> { typedef detail::matrix_char_5x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x7,1> matrix_char_5x7_row1; } template <> struct geometric_traits<detail::matrix_char_5x7_row1> { typedef detail::matrix_char_5x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x7,2> matrix_char_5x7_row2; } template <> struct geometric_traits<detail::matrix_char_5x7_row2> { typedef detail::matrix_char_5x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x7,3> matrix_char_5x7_row3; } template <> struct geometric_traits<detail::matrix_char_5x7_row3> { typedef detail::matrix_char_5x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x7,4> matrix_char_5x7_row4; } template <> struct geometric_traits<detail::matrix_char_5x7_row4> { typedef detail::matrix_char_5x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,0> matrix_char_5x7_column0; }template <> struct geometric_traits<detail::matrix_char_5x7_column0> { typedef detail::matrix_char_5x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,1> matrix_char_5x7_column1; }template <> struct geometric_traits<detail::matrix_char_5x7_column1> { typedef detail::matrix_char_5x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,2> matrix_char_5x7_column2; }template <> struct geometric_traits<detail::matrix_char_5x7_column2> { typedef detail::matrix_char_5x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,3> matrix_char_5x7_column3; }template <> struct geometric_traits<detail::matrix_char_5x7_column3> { typedef detail::matrix_char_5x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,4> matrix_char_5x7_column4; }template <> struct geometric_traits<detail::matrix_char_5x7_column4> { typedef detail::matrix_char_5x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,5> matrix_char_5x7_column5; }template <> struct geometric_traits<detail::matrix_char_5x7_column5> { typedef detail::matrix_char_5x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x7,6> matrix_char_5x7_column6; }template <> struct geometric_traits<detail::matrix_char_5x7_column6> { typedef detail::matrix_char_5x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x7>::type > : index_operator_matrix_access_policy < matrix_char_5x7 > { typedef index_operator_matrix_access_policy < matrix_char_5x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x7 > { typedef dimension<5> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 8> matrix_char_5x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x8,0> matrix_char_5x8_row0; } template <> struct geometric_traits<detail::matrix_char_5x8_row0> { typedef detail::matrix_char_5x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x8,1> matrix_char_5x8_row1; } template <> struct geometric_traits<detail::matrix_char_5x8_row1> { typedef detail::matrix_char_5x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x8,2> matrix_char_5x8_row2; } template <> struct geometric_traits<detail::matrix_char_5x8_row2> { typedef detail::matrix_char_5x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x8,3> matrix_char_5x8_row3; } template <> struct geometric_traits<detail::matrix_char_5x8_row3> { typedef detail::matrix_char_5x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x8,4> matrix_char_5x8_row4; } template <> struct geometric_traits<detail::matrix_char_5x8_row4> { typedef detail::matrix_char_5x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,0> matrix_char_5x8_column0; }template <> struct geometric_traits<detail::matrix_char_5x8_column0> { typedef detail::matrix_char_5x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,1> matrix_char_5x8_column1; }template <> struct geometric_traits<detail::matrix_char_5x8_column1> { typedef detail::matrix_char_5x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,2> matrix_char_5x8_column2; }template <> struct geometric_traits<detail::matrix_char_5x8_column2> { typedef detail::matrix_char_5x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,3> matrix_char_5x8_column3; }template <> struct geometric_traits<detail::matrix_char_5x8_column3> { typedef detail::matrix_char_5x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,4> matrix_char_5x8_column4; }template <> struct geometric_traits<detail::matrix_char_5x8_column4> { typedef detail::matrix_char_5x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,5> matrix_char_5x8_column5; }template <> struct geometric_traits<detail::matrix_char_5x8_column5> { typedef detail::matrix_char_5x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,6> matrix_char_5x8_column6; }template <> struct geometric_traits<detail::matrix_char_5x8_column6> { typedef detail::matrix_char_5x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x8,7> matrix_char_5x8_column7; }template <> struct geometric_traits<detail::matrix_char_5x8_column7> { typedef detail::matrix_char_5x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x8>::type > : index_operator_matrix_access_policy < matrix_char_5x8 > { typedef index_operator_matrix_access_policy < matrix_char_5x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x8 > { typedef dimension<5> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 9> matrix_char_5x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x9,0> matrix_char_5x9_row0; } template <> struct geometric_traits<detail::matrix_char_5x9_row0> { typedef detail::matrix_char_5x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x9,1> matrix_char_5x9_row1; } template <> struct geometric_traits<detail::matrix_char_5x9_row1> { typedef detail::matrix_char_5x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x9,2> matrix_char_5x9_row2; } template <> struct geometric_traits<detail::matrix_char_5x9_row2> { typedef detail::matrix_char_5x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x9,3> matrix_char_5x9_row3; } template <> struct geometric_traits<detail::matrix_char_5x9_row3> { typedef detail::matrix_char_5x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x9,4> matrix_char_5x9_row4; } template <> struct geometric_traits<detail::matrix_char_5x9_row4> { typedef detail::matrix_char_5x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,0> matrix_char_5x9_column0; }template <> struct geometric_traits<detail::matrix_char_5x9_column0> { typedef detail::matrix_char_5x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,1> matrix_char_5x9_column1; }template <> struct geometric_traits<detail::matrix_char_5x9_column1> { typedef detail::matrix_char_5x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,2> matrix_char_5x9_column2; }template <> struct geometric_traits<detail::matrix_char_5x9_column2> { typedef detail::matrix_char_5x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,3> matrix_char_5x9_column3; }template <> struct geometric_traits<detail::matrix_char_5x9_column3> { typedef detail::matrix_char_5x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,4> matrix_char_5x9_column4; }template <> struct geometric_traits<detail::matrix_char_5x9_column4> { typedef detail::matrix_char_5x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,5> matrix_char_5x9_column5; }template <> struct geometric_traits<detail::matrix_char_5x9_column5> { typedef detail::matrix_char_5x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,6> matrix_char_5x9_column6; }template <> struct geometric_traits<detail::matrix_char_5x9_column6> { typedef detail::matrix_char_5x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,7> matrix_char_5x9_column7; }template <> struct geometric_traits<detail::matrix_char_5x9_column7> { typedef detail::matrix_char_5x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x9,8> matrix_char_5x9_column8; }template <> struct geometric_traits<detail::matrix_char_5x9_column8> { typedef detail::matrix_char_5x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x9>::type > : index_operator_matrix_access_policy < matrix_char_5x9 > { typedef index_operator_matrix_access_policy < matrix_char_5x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x9 > { typedef dimension<5> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 5, 10> matrix_char_5x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x10,0> matrix_char_5x10_row0; } template <> struct geometric_traits<detail::matrix_char_5x10_row0> { typedef detail::matrix_char_5x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x10,1> matrix_char_5x10_row1; } template <> struct geometric_traits<detail::matrix_char_5x10_row1> { typedef detail::matrix_char_5x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x10,2> matrix_char_5x10_row2; } template <> struct geometric_traits<detail::matrix_char_5x10_row2> { typedef detail::matrix_char_5x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x10,3> matrix_char_5x10_row3; } template <> struct geometric_traits<detail::matrix_char_5x10_row3> { typedef detail::matrix_char_5x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_5x10,4> matrix_char_5x10_row4; } template <> struct geometric_traits<detail::matrix_char_5x10_row4> { typedef detail::matrix_char_5x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,0> matrix_char_5x10_column0; }template <> struct geometric_traits<detail::matrix_char_5x10_column0> { typedef detail::matrix_char_5x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,1> matrix_char_5x10_column1; }template <> struct geometric_traits<detail::matrix_char_5x10_column1> { typedef detail::matrix_char_5x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,2> matrix_char_5x10_column2; }template <> struct geometric_traits<detail::matrix_char_5x10_column2> { typedef detail::matrix_char_5x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,3> matrix_char_5x10_column3; }template <> struct geometric_traits<detail::matrix_char_5x10_column3> { typedef detail::matrix_char_5x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,4> matrix_char_5x10_column4; }template <> struct geometric_traits<detail::matrix_char_5x10_column4> { typedef detail::matrix_char_5x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,5> matrix_char_5x10_column5; }template <> struct geometric_traits<detail::matrix_char_5x10_column5> { typedef detail::matrix_char_5x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,6> matrix_char_5x10_column6; }template <> struct geometric_traits<detail::matrix_char_5x10_column6> { typedef detail::matrix_char_5x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,7> matrix_char_5x10_column7; }template <> struct geometric_traits<detail::matrix_char_5x10_column7> { typedef detail::matrix_char_5x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,8> matrix_char_5x10_column8; }template <> struct geometric_traits<detail::matrix_char_5x10_column8> { typedef detail::matrix_char_5x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_5x10,9> matrix_char_5x10_column9; }template <> struct geometric_traits<detail::matrix_char_5x10_column9> { typedef detail::matrix_char_5x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_5x10>::type > : index_operator_matrix_access_policy < matrix_char_5x10 > { typedef index_operator_matrix_access_policy < matrix_char_5x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_5x10 > { typedef dimension<5> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 1> matrix_char_6x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,0> matrix_char_6x1_row0; } template <> struct geometric_traits<detail::matrix_char_6x1_row0> { typedef detail::matrix_char_6x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,1> matrix_char_6x1_row1; } template <> struct geometric_traits<detail::matrix_char_6x1_row1> { typedef detail::matrix_char_6x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,2> matrix_char_6x1_row2; } template <> struct geometric_traits<detail::matrix_char_6x1_row2> { typedef detail::matrix_char_6x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,3> matrix_char_6x1_row3; } template <> struct geometric_traits<detail::matrix_char_6x1_row3> { typedef detail::matrix_char_6x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,4> matrix_char_6x1_row4; } template <> struct geometric_traits<detail::matrix_char_6x1_row4> { typedef detail::matrix_char_6x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x1,5> matrix_char_6x1_row5; } template <> struct geometric_traits<detail::matrix_char_6x1_row5> { typedef detail::matrix_char_6x1_row5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x1,0> matrix_char_6x1_column0; }template <> struct geometric_traits<detail::matrix_char_6x1_column0> { typedef detail::matrix_char_6x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x1>::type > : index_operator_matrix_access_policy < matrix_char_6x1 > { typedef index_operator_matrix_access_policy < matrix_char_6x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x1 > { typedef dimension<6> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 2> matrix_char_6x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,0> matrix_char_6x2_row0; } template <> struct geometric_traits<detail::matrix_char_6x2_row0> { typedef detail::matrix_char_6x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,1> matrix_char_6x2_row1; } template <> struct geometric_traits<detail::matrix_char_6x2_row1> { typedef detail::matrix_char_6x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,2> matrix_char_6x2_row2; } template <> struct geometric_traits<detail::matrix_char_6x2_row2> { typedef detail::matrix_char_6x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,3> matrix_char_6x2_row3; } template <> struct geometric_traits<detail::matrix_char_6x2_row3> { typedef detail::matrix_char_6x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,4> matrix_char_6x2_row4; } template <> struct geometric_traits<detail::matrix_char_6x2_row4> { typedef detail::matrix_char_6x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x2,5> matrix_char_6x2_row5; } template <> struct geometric_traits<detail::matrix_char_6x2_row5> { typedef detail::matrix_char_6x2_row5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x2,0> matrix_char_6x2_column0; }template <> struct geometric_traits<detail::matrix_char_6x2_column0> { typedef detail::matrix_char_6x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x2,1> matrix_char_6x2_column1; }template <> struct geometric_traits<detail::matrix_char_6x2_column1> { typedef detail::matrix_char_6x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x2>::type > : index_operator_matrix_access_policy < matrix_char_6x2 > { typedef index_operator_matrix_access_policy < matrix_char_6x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x2 > { typedef dimension<6> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 3> matrix_char_6x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,0> matrix_char_6x3_row0; } template <> struct geometric_traits<detail::matrix_char_6x3_row0> { typedef detail::matrix_char_6x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,1> matrix_char_6x3_row1; } template <> struct geometric_traits<detail::matrix_char_6x3_row1> { typedef detail::matrix_char_6x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,2> matrix_char_6x3_row2; } template <> struct geometric_traits<detail::matrix_char_6x3_row2> { typedef detail::matrix_char_6x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,3> matrix_char_6x3_row3; } template <> struct geometric_traits<detail::matrix_char_6x3_row3> { typedef detail::matrix_char_6x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,4> matrix_char_6x3_row4; } template <> struct geometric_traits<detail::matrix_char_6x3_row4> { typedef detail::matrix_char_6x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x3,5> matrix_char_6x3_row5; } template <> struct geometric_traits<detail::matrix_char_6x3_row5> { typedef detail::matrix_char_6x3_row5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x3,0> matrix_char_6x3_column0; }template <> struct geometric_traits<detail::matrix_char_6x3_column0> { typedef detail::matrix_char_6x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x3,1> matrix_char_6x3_column1; }template <> struct geometric_traits<detail::matrix_char_6x3_column1> { typedef detail::matrix_char_6x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x3,2> matrix_char_6x3_column2; }template <> struct geometric_traits<detail::matrix_char_6x3_column2> { typedef detail::matrix_char_6x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x3>::type > : index_operator_matrix_access_policy < matrix_char_6x3 > { typedef index_operator_matrix_access_policy < matrix_char_6x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x3 > { typedef dimension<6> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 4> matrix_char_6x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,0> matrix_char_6x4_row0; } template <> struct geometric_traits<detail::matrix_char_6x4_row0> { typedef detail::matrix_char_6x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,1> matrix_char_6x4_row1; } template <> struct geometric_traits<detail::matrix_char_6x4_row1> { typedef detail::matrix_char_6x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,2> matrix_char_6x4_row2; } template <> struct geometric_traits<detail::matrix_char_6x4_row2> { typedef detail::matrix_char_6x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,3> matrix_char_6x4_row3; } template <> struct geometric_traits<detail::matrix_char_6x4_row3> { typedef detail::matrix_char_6x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,4> matrix_char_6x4_row4; } template <> struct geometric_traits<detail::matrix_char_6x4_row4> { typedef detail::matrix_char_6x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x4,5> matrix_char_6x4_row5; } template <> struct geometric_traits<detail::matrix_char_6x4_row5> { typedef detail::matrix_char_6x4_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x4,0> matrix_char_6x4_column0; }template <> struct geometric_traits<detail::matrix_char_6x4_column0> { typedef detail::matrix_char_6x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x4,1> matrix_char_6x4_column1; }template <> struct geometric_traits<detail::matrix_char_6x4_column1> { typedef detail::matrix_char_6x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x4,2> matrix_char_6x4_column2; }template <> struct geometric_traits<detail::matrix_char_6x4_column2> { typedef detail::matrix_char_6x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x4,3> matrix_char_6x4_column3; }template <> struct geometric_traits<detail::matrix_char_6x4_column3> { typedef detail::matrix_char_6x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x4>::type > : index_operator_matrix_access_policy < matrix_char_6x4 > { typedef index_operator_matrix_access_policy < matrix_char_6x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x4 > { typedef dimension<6> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 5> matrix_char_6x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,0> matrix_char_6x5_row0; } template <> struct geometric_traits<detail::matrix_char_6x5_row0> { typedef detail::matrix_char_6x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,1> matrix_char_6x5_row1; } template <> struct geometric_traits<detail::matrix_char_6x5_row1> { typedef detail::matrix_char_6x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,2> matrix_char_6x5_row2; } template <> struct geometric_traits<detail::matrix_char_6x5_row2> { typedef detail::matrix_char_6x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,3> matrix_char_6x5_row3; } template <> struct geometric_traits<detail::matrix_char_6x5_row3> { typedef detail::matrix_char_6x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,4> matrix_char_6x5_row4; } template <> struct geometric_traits<detail::matrix_char_6x5_row4> { typedef detail::matrix_char_6x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x5,5> matrix_char_6x5_row5; } template <> struct geometric_traits<detail::matrix_char_6x5_row5> { typedef detail::matrix_char_6x5_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x5,0> matrix_char_6x5_column0; }template <> struct geometric_traits<detail::matrix_char_6x5_column0> { typedef detail::matrix_char_6x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x5,1> matrix_char_6x5_column1; }template <> struct geometric_traits<detail::matrix_char_6x5_column1> { typedef detail::matrix_char_6x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x5,2> matrix_char_6x5_column2; }template <> struct geometric_traits<detail::matrix_char_6x5_column2> { typedef detail::matrix_char_6x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x5,3> matrix_char_6x5_column3; }template <> struct geometric_traits<detail::matrix_char_6x5_column3> { typedef detail::matrix_char_6x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x5,4> matrix_char_6x5_column4; }template <> struct geometric_traits<detail::matrix_char_6x5_column4> { typedef detail::matrix_char_6x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x5>::type > : index_operator_matrix_access_policy < matrix_char_6x5 > { typedef index_operator_matrix_access_policy < matrix_char_6x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x5 > { typedef dimension<6> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 6> matrix_char_6x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,0> matrix_char_6x6_row0; } template <> struct geometric_traits<detail::matrix_char_6x6_row0> { typedef detail::matrix_char_6x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,1> matrix_char_6x6_row1; } template <> struct geometric_traits<detail::matrix_char_6x6_row1> { typedef detail::matrix_char_6x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,2> matrix_char_6x6_row2; } template <> struct geometric_traits<detail::matrix_char_6x6_row2> { typedef detail::matrix_char_6x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,3> matrix_char_6x6_row3; } template <> struct geometric_traits<detail::matrix_char_6x6_row3> { typedef detail::matrix_char_6x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,4> matrix_char_6x6_row4; } template <> struct geometric_traits<detail::matrix_char_6x6_row4> { typedef detail::matrix_char_6x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x6,5> matrix_char_6x6_row5; } template <> struct geometric_traits<detail::matrix_char_6x6_row5> { typedef detail::matrix_char_6x6_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,0> matrix_char_6x6_column0; }template <> struct geometric_traits<detail::matrix_char_6x6_column0> { typedef detail::matrix_char_6x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,1> matrix_char_6x6_column1; }template <> struct geometric_traits<detail::matrix_char_6x6_column1> { typedef detail::matrix_char_6x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,2> matrix_char_6x6_column2; }template <> struct geometric_traits<detail::matrix_char_6x6_column2> { typedef detail::matrix_char_6x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,3> matrix_char_6x6_column3; }template <> struct geometric_traits<detail::matrix_char_6x6_column3> { typedef detail::matrix_char_6x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,4> matrix_char_6x6_column4; }template <> struct geometric_traits<detail::matrix_char_6x6_column4> { typedef detail::matrix_char_6x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x6,5> matrix_char_6x6_column5; }template <> struct geometric_traits<detail::matrix_char_6x6_column5> { typedef detail::matrix_char_6x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x6>::type > : index_operator_matrix_access_policy < matrix_char_6x6 > { typedef index_operator_matrix_access_policy < matrix_char_6x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x6 > { typedef dimension<6> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 7> matrix_char_6x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,0> matrix_char_6x7_row0; } template <> struct geometric_traits<detail::matrix_char_6x7_row0> { typedef detail::matrix_char_6x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,1> matrix_char_6x7_row1; } template <> struct geometric_traits<detail::matrix_char_6x7_row1> { typedef detail::matrix_char_6x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,2> matrix_char_6x7_row2; } template <> struct geometric_traits<detail::matrix_char_6x7_row2> { typedef detail::matrix_char_6x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,3> matrix_char_6x7_row3; } template <> struct geometric_traits<detail::matrix_char_6x7_row3> { typedef detail::matrix_char_6x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,4> matrix_char_6x7_row4; } template <> struct geometric_traits<detail::matrix_char_6x7_row4> { typedef detail::matrix_char_6x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x7,5> matrix_char_6x7_row5; } template <> struct geometric_traits<detail::matrix_char_6x7_row5> { typedef detail::matrix_char_6x7_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,0> matrix_char_6x7_column0; }template <> struct geometric_traits<detail::matrix_char_6x7_column0> { typedef detail::matrix_char_6x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,1> matrix_char_6x7_column1; }template <> struct geometric_traits<detail::matrix_char_6x7_column1> { typedef detail::matrix_char_6x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,2> matrix_char_6x7_column2; }template <> struct geometric_traits<detail::matrix_char_6x7_column2> { typedef detail::matrix_char_6x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,3> matrix_char_6x7_column3; }template <> struct geometric_traits<detail::matrix_char_6x7_column3> { typedef detail::matrix_char_6x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,4> matrix_char_6x7_column4; }template <> struct geometric_traits<detail::matrix_char_6x7_column4> { typedef detail::matrix_char_6x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,5> matrix_char_6x7_column5; }template <> struct geometric_traits<detail::matrix_char_6x7_column5> { typedef detail::matrix_char_6x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x7,6> matrix_char_6x7_column6; }template <> struct geometric_traits<detail::matrix_char_6x7_column6> { typedef detail::matrix_char_6x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x7>::type > : index_operator_matrix_access_policy < matrix_char_6x7 > { typedef index_operator_matrix_access_policy < matrix_char_6x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x7 > { typedef dimension<6> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 8> matrix_char_6x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,0> matrix_char_6x8_row0; } template <> struct geometric_traits<detail::matrix_char_6x8_row0> { typedef detail::matrix_char_6x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,1> matrix_char_6x8_row1; } template <> struct geometric_traits<detail::matrix_char_6x8_row1> { typedef detail::matrix_char_6x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,2> matrix_char_6x8_row2; } template <> struct geometric_traits<detail::matrix_char_6x8_row2> { typedef detail::matrix_char_6x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,3> matrix_char_6x8_row3; } template <> struct geometric_traits<detail::matrix_char_6x8_row3> { typedef detail::matrix_char_6x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,4> matrix_char_6x8_row4; } template <> struct geometric_traits<detail::matrix_char_6x8_row4> { typedef detail::matrix_char_6x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x8,5> matrix_char_6x8_row5; } template <> struct geometric_traits<detail::matrix_char_6x8_row5> { typedef detail::matrix_char_6x8_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,0> matrix_char_6x8_column0; }template <> struct geometric_traits<detail::matrix_char_6x8_column0> { typedef detail::matrix_char_6x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,1> matrix_char_6x8_column1; }template <> struct geometric_traits<detail::matrix_char_6x8_column1> { typedef detail::matrix_char_6x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,2> matrix_char_6x8_column2; }template <> struct geometric_traits<detail::matrix_char_6x8_column2> { typedef detail::matrix_char_6x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,3> matrix_char_6x8_column3; }template <> struct geometric_traits<detail::matrix_char_6x8_column3> { typedef detail::matrix_char_6x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,4> matrix_char_6x8_column4; }template <> struct geometric_traits<detail::matrix_char_6x8_column4> { typedef detail::matrix_char_6x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,5> matrix_char_6x8_column5; }template <> struct geometric_traits<detail::matrix_char_6x8_column5> { typedef detail::matrix_char_6x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,6> matrix_char_6x8_column6; }template <> struct geometric_traits<detail::matrix_char_6x8_column6> { typedef detail::matrix_char_6x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x8,7> matrix_char_6x8_column7; }template <> struct geometric_traits<detail::matrix_char_6x8_column7> { typedef detail::matrix_char_6x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x8>::type > : index_operator_matrix_access_policy < matrix_char_6x8 > { typedef index_operator_matrix_access_policy < matrix_char_6x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x8 > { typedef dimension<6> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 9> matrix_char_6x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,0> matrix_char_6x9_row0; } template <> struct geometric_traits<detail::matrix_char_6x9_row0> { typedef detail::matrix_char_6x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,1> matrix_char_6x9_row1; } template <> struct geometric_traits<detail::matrix_char_6x9_row1> { typedef detail::matrix_char_6x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,2> matrix_char_6x9_row2; } template <> struct geometric_traits<detail::matrix_char_6x9_row2> { typedef detail::matrix_char_6x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,3> matrix_char_6x9_row3; } template <> struct geometric_traits<detail::matrix_char_6x9_row3> { typedef detail::matrix_char_6x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,4> matrix_char_6x9_row4; } template <> struct geometric_traits<detail::matrix_char_6x9_row4> { typedef detail::matrix_char_6x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x9,5> matrix_char_6x9_row5; } template <> struct geometric_traits<detail::matrix_char_6x9_row5> { typedef detail::matrix_char_6x9_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,0> matrix_char_6x9_column0; }template <> struct geometric_traits<detail::matrix_char_6x9_column0> { typedef detail::matrix_char_6x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,1> matrix_char_6x9_column1; }template <> struct geometric_traits<detail::matrix_char_6x9_column1> { typedef detail::matrix_char_6x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,2> matrix_char_6x9_column2; }template <> struct geometric_traits<detail::matrix_char_6x9_column2> { typedef detail::matrix_char_6x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,3> matrix_char_6x9_column3; }template <> struct geometric_traits<detail::matrix_char_6x9_column3> { typedef detail::matrix_char_6x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,4> matrix_char_6x9_column4; }template <> struct geometric_traits<detail::matrix_char_6x9_column4> { typedef detail::matrix_char_6x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,5> matrix_char_6x9_column5; }template <> struct geometric_traits<detail::matrix_char_6x9_column5> { typedef detail::matrix_char_6x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,6> matrix_char_6x9_column6; }template <> struct geometric_traits<detail::matrix_char_6x9_column6> { typedef detail::matrix_char_6x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,7> matrix_char_6x9_column7; }template <> struct geometric_traits<detail::matrix_char_6x9_column7> { typedef detail::matrix_char_6x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x9,8> matrix_char_6x9_column8; }template <> struct geometric_traits<detail::matrix_char_6x9_column8> { typedef detail::matrix_char_6x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x9>::type > : index_operator_matrix_access_policy < matrix_char_6x9 > { typedef index_operator_matrix_access_policy < matrix_char_6x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x9 > { typedef dimension<6> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 6, 10> matrix_char_6x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,0> matrix_char_6x10_row0; } template <> struct geometric_traits<detail::matrix_char_6x10_row0> { typedef detail::matrix_char_6x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,1> matrix_char_6x10_row1; } template <> struct geometric_traits<detail::matrix_char_6x10_row1> { typedef detail::matrix_char_6x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,2> matrix_char_6x10_row2; } template <> struct geometric_traits<detail::matrix_char_6x10_row2> { typedef detail::matrix_char_6x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,3> matrix_char_6x10_row3; } template <> struct geometric_traits<detail::matrix_char_6x10_row3> { typedef detail::matrix_char_6x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,4> matrix_char_6x10_row4; } template <> struct geometric_traits<detail::matrix_char_6x10_row4> { typedef detail::matrix_char_6x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_6x10,5> matrix_char_6x10_row5; } template <> struct geometric_traits<detail::matrix_char_6x10_row5> { typedef detail::matrix_char_6x10_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,0> matrix_char_6x10_column0; }template <> struct geometric_traits<detail::matrix_char_6x10_column0> { typedef detail::matrix_char_6x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,1> matrix_char_6x10_column1; }template <> struct geometric_traits<detail::matrix_char_6x10_column1> { typedef detail::matrix_char_6x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,2> matrix_char_6x10_column2; }template <> struct geometric_traits<detail::matrix_char_6x10_column2> { typedef detail::matrix_char_6x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,3> matrix_char_6x10_column3; }template <> struct geometric_traits<detail::matrix_char_6x10_column3> { typedef detail::matrix_char_6x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,4> matrix_char_6x10_column4; }template <> struct geometric_traits<detail::matrix_char_6x10_column4> { typedef detail::matrix_char_6x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,5> matrix_char_6x10_column5; }template <> struct geometric_traits<detail::matrix_char_6x10_column5> { typedef detail::matrix_char_6x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,6> matrix_char_6x10_column6; }template <> struct geometric_traits<detail::matrix_char_6x10_column6> { typedef detail::matrix_char_6x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,7> matrix_char_6x10_column7; }template <> struct geometric_traits<detail::matrix_char_6x10_column7> { typedef detail::matrix_char_6x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,8> matrix_char_6x10_column8; }template <> struct geometric_traits<detail::matrix_char_6x10_column8> { typedef detail::matrix_char_6x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_6x10,9> matrix_char_6x10_column9; }template <> struct geometric_traits<detail::matrix_char_6x10_column9> { typedef detail::matrix_char_6x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_6x10>::type > : index_operator_matrix_access_policy < matrix_char_6x10 > { typedef index_operator_matrix_access_policy < matrix_char_6x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_6x10 > { typedef dimension<6> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 1> matrix_char_7x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,0> matrix_char_7x1_row0; } template <> struct geometric_traits<detail::matrix_char_7x1_row0> { typedef detail::matrix_char_7x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,1> matrix_char_7x1_row1; } template <> struct geometric_traits<detail::matrix_char_7x1_row1> { typedef detail::matrix_char_7x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,2> matrix_char_7x1_row2; } template <> struct geometric_traits<detail::matrix_char_7x1_row2> { typedef detail::matrix_char_7x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,3> matrix_char_7x1_row3; } template <> struct geometric_traits<detail::matrix_char_7x1_row3> { typedef detail::matrix_char_7x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,4> matrix_char_7x1_row4; } template <> struct geometric_traits<detail::matrix_char_7x1_row4> { typedef detail::matrix_char_7x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,5> matrix_char_7x1_row5; } template <> struct geometric_traits<detail::matrix_char_7x1_row5> { typedef detail::matrix_char_7x1_row5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x1,6> matrix_char_7x1_row6; } template <> struct geometric_traits<detail::matrix_char_7x1_row6> { typedef detail::matrix_char_7x1_row6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x1,0> matrix_char_7x1_column0; }template <> struct geometric_traits<detail::matrix_char_7x1_column0> { typedef detail::matrix_char_7x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x1>::type > : index_operator_matrix_access_policy < matrix_char_7x1 > { typedef index_operator_matrix_access_policy < matrix_char_7x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x1 > { typedef dimension<7> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 2> matrix_char_7x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,0> matrix_char_7x2_row0; } template <> struct geometric_traits<detail::matrix_char_7x2_row0> { typedef detail::matrix_char_7x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,1> matrix_char_7x2_row1; } template <> struct geometric_traits<detail::matrix_char_7x2_row1> { typedef detail::matrix_char_7x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,2> matrix_char_7x2_row2; } template <> struct geometric_traits<detail::matrix_char_7x2_row2> { typedef detail::matrix_char_7x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,3> matrix_char_7x2_row3; } template <> struct geometric_traits<detail::matrix_char_7x2_row3> { typedef detail::matrix_char_7x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,4> matrix_char_7x2_row4; } template <> struct geometric_traits<detail::matrix_char_7x2_row4> { typedef detail::matrix_char_7x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,5> matrix_char_7x2_row5; } template <> struct geometric_traits<detail::matrix_char_7x2_row5> { typedef detail::matrix_char_7x2_row5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x2,6> matrix_char_7x2_row6; } template <> struct geometric_traits<detail::matrix_char_7x2_row6> { typedef detail::matrix_char_7x2_row6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x2,0> matrix_char_7x2_column0; }template <> struct geometric_traits<detail::matrix_char_7x2_column0> { typedef detail::matrix_char_7x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x2,1> matrix_char_7x2_column1; }template <> struct geometric_traits<detail::matrix_char_7x2_column1> { typedef detail::matrix_char_7x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x2>::type > : index_operator_matrix_access_policy < matrix_char_7x2 > { typedef index_operator_matrix_access_policy < matrix_char_7x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x2 > { typedef dimension<7> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 3> matrix_char_7x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,0> matrix_char_7x3_row0; } template <> struct geometric_traits<detail::matrix_char_7x3_row0> { typedef detail::matrix_char_7x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,1> matrix_char_7x3_row1; } template <> struct geometric_traits<detail::matrix_char_7x3_row1> { typedef detail::matrix_char_7x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,2> matrix_char_7x3_row2; } template <> struct geometric_traits<detail::matrix_char_7x3_row2> { typedef detail::matrix_char_7x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,3> matrix_char_7x3_row3; } template <> struct geometric_traits<detail::matrix_char_7x3_row3> { typedef detail::matrix_char_7x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,4> matrix_char_7x3_row4; } template <> struct geometric_traits<detail::matrix_char_7x3_row4> { typedef detail::matrix_char_7x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,5> matrix_char_7x3_row5; } template <> struct geometric_traits<detail::matrix_char_7x3_row5> { typedef detail::matrix_char_7x3_row5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x3,6> matrix_char_7x3_row6; } template <> struct geometric_traits<detail::matrix_char_7x3_row6> { typedef detail::matrix_char_7x3_row6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x3,0> matrix_char_7x3_column0; }template <> struct geometric_traits<detail::matrix_char_7x3_column0> { typedef detail::matrix_char_7x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x3,1> matrix_char_7x3_column1; }template <> struct geometric_traits<detail::matrix_char_7x3_column1> { typedef detail::matrix_char_7x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x3,2> matrix_char_7x3_column2; }template <> struct geometric_traits<detail::matrix_char_7x3_column2> { typedef detail::matrix_char_7x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x3>::type > : index_operator_matrix_access_policy < matrix_char_7x3 > { typedef index_operator_matrix_access_policy < matrix_char_7x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x3 > { typedef dimension<7> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 4> matrix_char_7x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,0> matrix_char_7x4_row0; } template <> struct geometric_traits<detail::matrix_char_7x4_row0> { typedef detail::matrix_char_7x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,1> matrix_char_7x4_row1; } template <> struct geometric_traits<detail::matrix_char_7x4_row1> { typedef detail::matrix_char_7x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,2> matrix_char_7x4_row2; } template <> struct geometric_traits<detail::matrix_char_7x4_row2> { typedef detail::matrix_char_7x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,3> matrix_char_7x4_row3; } template <> struct geometric_traits<detail::matrix_char_7x4_row3> { typedef detail::matrix_char_7x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,4> matrix_char_7x4_row4; } template <> struct geometric_traits<detail::matrix_char_7x4_row4> { typedef detail::matrix_char_7x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,5> matrix_char_7x4_row5; } template <> struct geometric_traits<detail::matrix_char_7x4_row5> { typedef detail::matrix_char_7x4_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x4,6> matrix_char_7x4_row6; } template <> struct geometric_traits<detail::matrix_char_7x4_row6> { typedef detail::matrix_char_7x4_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x4,0> matrix_char_7x4_column0; }template <> struct geometric_traits<detail::matrix_char_7x4_column0> { typedef detail::matrix_char_7x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x4,1> matrix_char_7x4_column1; }template <> struct geometric_traits<detail::matrix_char_7x4_column1> { typedef detail::matrix_char_7x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x4,2> matrix_char_7x4_column2; }template <> struct geometric_traits<detail::matrix_char_7x4_column2> { typedef detail::matrix_char_7x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x4,3> matrix_char_7x4_column3; }template <> struct geometric_traits<detail::matrix_char_7x4_column3> { typedef detail::matrix_char_7x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x4>::type > : index_operator_matrix_access_policy < matrix_char_7x4 > { typedef index_operator_matrix_access_policy < matrix_char_7x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x4 > { typedef dimension<7> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 5> matrix_char_7x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,0> matrix_char_7x5_row0; } template <> struct geometric_traits<detail::matrix_char_7x5_row0> { typedef detail::matrix_char_7x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,1> matrix_char_7x5_row1; } template <> struct geometric_traits<detail::matrix_char_7x5_row1> { typedef detail::matrix_char_7x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,2> matrix_char_7x5_row2; } template <> struct geometric_traits<detail::matrix_char_7x5_row2> { typedef detail::matrix_char_7x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,3> matrix_char_7x5_row3; } template <> struct geometric_traits<detail::matrix_char_7x5_row3> { typedef detail::matrix_char_7x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,4> matrix_char_7x5_row4; } template <> struct geometric_traits<detail::matrix_char_7x5_row4> { typedef detail::matrix_char_7x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,5> matrix_char_7x5_row5; } template <> struct geometric_traits<detail::matrix_char_7x5_row5> { typedef detail::matrix_char_7x5_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x5,6> matrix_char_7x5_row6; } template <> struct geometric_traits<detail::matrix_char_7x5_row6> { typedef detail::matrix_char_7x5_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x5,0> matrix_char_7x5_column0; }template <> struct geometric_traits<detail::matrix_char_7x5_column0> { typedef detail::matrix_char_7x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x5,1> matrix_char_7x5_column1; }template <> struct geometric_traits<detail::matrix_char_7x5_column1> { typedef detail::matrix_char_7x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x5,2> matrix_char_7x5_column2; }template <> struct geometric_traits<detail::matrix_char_7x5_column2> { typedef detail::matrix_char_7x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x5,3> matrix_char_7x5_column3; }template <> struct geometric_traits<detail::matrix_char_7x5_column3> { typedef detail::matrix_char_7x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x5,4> matrix_char_7x5_column4; }template <> struct geometric_traits<detail::matrix_char_7x5_column4> { typedef detail::matrix_char_7x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x5>::type > : index_operator_matrix_access_policy < matrix_char_7x5 > { typedef index_operator_matrix_access_policy < matrix_char_7x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x5 > { typedef dimension<7> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 6> matrix_char_7x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,0> matrix_char_7x6_row0; } template <> struct geometric_traits<detail::matrix_char_7x6_row0> { typedef detail::matrix_char_7x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,1> matrix_char_7x6_row1; } template <> struct geometric_traits<detail::matrix_char_7x6_row1> { typedef detail::matrix_char_7x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,2> matrix_char_7x6_row2; } template <> struct geometric_traits<detail::matrix_char_7x6_row2> { typedef detail::matrix_char_7x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,3> matrix_char_7x6_row3; } template <> struct geometric_traits<detail::matrix_char_7x6_row3> { typedef detail::matrix_char_7x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,4> matrix_char_7x6_row4; } template <> struct geometric_traits<detail::matrix_char_7x6_row4> { typedef detail::matrix_char_7x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,5> matrix_char_7x6_row5; } template <> struct geometric_traits<detail::matrix_char_7x6_row5> { typedef detail::matrix_char_7x6_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x6,6> matrix_char_7x6_row6; } template <> struct geometric_traits<detail::matrix_char_7x6_row6> { typedef detail::matrix_char_7x6_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,0> matrix_char_7x6_column0; }template <> struct geometric_traits<detail::matrix_char_7x6_column0> { typedef detail::matrix_char_7x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,1> matrix_char_7x6_column1; }template <> struct geometric_traits<detail::matrix_char_7x6_column1> { typedef detail::matrix_char_7x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,2> matrix_char_7x6_column2; }template <> struct geometric_traits<detail::matrix_char_7x6_column2> { typedef detail::matrix_char_7x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,3> matrix_char_7x6_column3; }template <> struct geometric_traits<detail::matrix_char_7x6_column3> { typedef detail::matrix_char_7x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,4> matrix_char_7x6_column4; }template <> struct geometric_traits<detail::matrix_char_7x6_column4> { typedef detail::matrix_char_7x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x6,5> matrix_char_7x6_column5; }template <> struct geometric_traits<detail::matrix_char_7x6_column5> { typedef detail::matrix_char_7x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x6>::type > : index_operator_matrix_access_policy < matrix_char_7x6 > { typedef index_operator_matrix_access_policy < matrix_char_7x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x6 > { typedef dimension<7> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 7> matrix_char_7x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,0> matrix_char_7x7_row0; } template <> struct geometric_traits<detail::matrix_char_7x7_row0> { typedef detail::matrix_char_7x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,1> matrix_char_7x7_row1; } template <> struct geometric_traits<detail::matrix_char_7x7_row1> { typedef detail::matrix_char_7x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,2> matrix_char_7x7_row2; } template <> struct geometric_traits<detail::matrix_char_7x7_row2> { typedef detail::matrix_char_7x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,3> matrix_char_7x7_row3; } template <> struct geometric_traits<detail::matrix_char_7x7_row3> { typedef detail::matrix_char_7x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,4> matrix_char_7x7_row4; } template <> struct geometric_traits<detail::matrix_char_7x7_row4> { typedef detail::matrix_char_7x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,5> matrix_char_7x7_row5; } template <> struct geometric_traits<detail::matrix_char_7x7_row5> { typedef detail::matrix_char_7x7_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x7,6> matrix_char_7x7_row6; } template <> struct geometric_traits<detail::matrix_char_7x7_row6> { typedef detail::matrix_char_7x7_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,0> matrix_char_7x7_column0; }template <> struct geometric_traits<detail::matrix_char_7x7_column0> { typedef detail::matrix_char_7x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,1> matrix_char_7x7_column1; }template <> struct geometric_traits<detail::matrix_char_7x7_column1> { typedef detail::matrix_char_7x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,2> matrix_char_7x7_column2; }template <> struct geometric_traits<detail::matrix_char_7x7_column2> { typedef detail::matrix_char_7x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,3> matrix_char_7x7_column3; }template <> struct geometric_traits<detail::matrix_char_7x7_column3> { typedef detail::matrix_char_7x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,4> matrix_char_7x7_column4; }template <> struct geometric_traits<detail::matrix_char_7x7_column4> { typedef detail::matrix_char_7x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,5> matrix_char_7x7_column5; }template <> struct geometric_traits<detail::matrix_char_7x7_column5> { typedef detail::matrix_char_7x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x7,6> matrix_char_7x7_column6; }template <> struct geometric_traits<detail::matrix_char_7x7_column6> { typedef detail::matrix_char_7x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x7>::type > : index_operator_matrix_access_policy < matrix_char_7x7 > { typedef index_operator_matrix_access_policy < matrix_char_7x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x7 > { typedef dimension<7> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 8> matrix_char_7x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,0> matrix_char_7x8_row0; } template <> struct geometric_traits<detail::matrix_char_7x8_row0> { typedef detail::matrix_char_7x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,1> matrix_char_7x8_row1; } template <> struct geometric_traits<detail::matrix_char_7x8_row1> { typedef detail::matrix_char_7x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,2> matrix_char_7x8_row2; } template <> struct geometric_traits<detail::matrix_char_7x8_row2> { typedef detail::matrix_char_7x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,3> matrix_char_7x8_row3; } template <> struct geometric_traits<detail::matrix_char_7x8_row3> { typedef detail::matrix_char_7x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,4> matrix_char_7x8_row4; } template <> struct geometric_traits<detail::matrix_char_7x8_row4> { typedef detail::matrix_char_7x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,5> matrix_char_7x8_row5; } template <> struct geometric_traits<detail::matrix_char_7x8_row5> { typedef detail::matrix_char_7x8_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x8,6> matrix_char_7x8_row6; } template <> struct geometric_traits<detail::matrix_char_7x8_row6> { typedef detail::matrix_char_7x8_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,0> matrix_char_7x8_column0; }template <> struct geometric_traits<detail::matrix_char_7x8_column0> { typedef detail::matrix_char_7x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,1> matrix_char_7x8_column1; }template <> struct geometric_traits<detail::matrix_char_7x8_column1> { typedef detail::matrix_char_7x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,2> matrix_char_7x8_column2; }template <> struct geometric_traits<detail::matrix_char_7x8_column2> { typedef detail::matrix_char_7x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,3> matrix_char_7x8_column3; }template <> struct geometric_traits<detail::matrix_char_7x8_column3> { typedef detail::matrix_char_7x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,4> matrix_char_7x8_column4; }template <> struct geometric_traits<detail::matrix_char_7x8_column4> { typedef detail::matrix_char_7x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,5> matrix_char_7x8_column5; }template <> struct geometric_traits<detail::matrix_char_7x8_column5> { typedef detail::matrix_char_7x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,6> matrix_char_7x8_column6; }template <> struct geometric_traits<detail::matrix_char_7x8_column6> { typedef detail::matrix_char_7x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x8,7> matrix_char_7x8_column7; }template <> struct geometric_traits<detail::matrix_char_7x8_column7> { typedef detail::matrix_char_7x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x8>::type > : index_operator_matrix_access_policy < matrix_char_7x8 > { typedef index_operator_matrix_access_policy < matrix_char_7x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x8 > { typedef dimension<7> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 9> matrix_char_7x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,0> matrix_char_7x9_row0; } template <> struct geometric_traits<detail::matrix_char_7x9_row0> { typedef detail::matrix_char_7x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,1> matrix_char_7x9_row1; } template <> struct geometric_traits<detail::matrix_char_7x9_row1> { typedef detail::matrix_char_7x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,2> matrix_char_7x9_row2; } template <> struct geometric_traits<detail::matrix_char_7x9_row2> { typedef detail::matrix_char_7x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,3> matrix_char_7x9_row3; } template <> struct geometric_traits<detail::matrix_char_7x9_row3> { typedef detail::matrix_char_7x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,4> matrix_char_7x9_row4; } template <> struct geometric_traits<detail::matrix_char_7x9_row4> { typedef detail::matrix_char_7x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,5> matrix_char_7x9_row5; } template <> struct geometric_traits<detail::matrix_char_7x9_row5> { typedef detail::matrix_char_7x9_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x9,6> matrix_char_7x9_row6; } template <> struct geometric_traits<detail::matrix_char_7x9_row6> { typedef detail::matrix_char_7x9_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,0> matrix_char_7x9_column0; }template <> struct geometric_traits<detail::matrix_char_7x9_column0> { typedef detail::matrix_char_7x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,1> matrix_char_7x9_column1; }template <> struct geometric_traits<detail::matrix_char_7x9_column1> { typedef detail::matrix_char_7x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,2> matrix_char_7x9_column2; }template <> struct geometric_traits<detail::matrix_char_7x9_column2> { typedef detail::matrix_char_7x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,3> matrix_char_7x9_column3; }template <> struct geometric_traits<detail::matrix_char_7x9_column3> { typedef detail::matrix_char_7x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,4> matrix_char_7x9_column4; }template <> struct geometric_traits<detail::matrix_char_7x9_column4> { typedef detail::matrix_char_7x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,5> matrix_char_7x9_column5; }template <> struct geometric_traits<detail::matrix_char_7x9_column5> { typedef detail::matrix_char_7x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,6> matrix_char_7x9_column6; }template <> struct geometric_traits<detail::matrix_char_7x9_column6> { typedef detail::matrix_char_7x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,7> matrix_char_7x9_column7; }template <> struct geometric_traits<detail::matrix_char_7x9_column7> { typedef detail::matrix_char_7x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x9,8> matrix_char_7x9_column8; }template <> struct geometric_traits<detail::matrix_char_7x9_column8> { typedef detail::matrix_char_7x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x9>::type > : index_operator_matrix_access_policy < matrix_char_7x9 > { typedef index_operator_matrix_access_policy < matrix_char_7x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x9 > { typedef dimension<7> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 7, 10> matrix_char_7x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,0> matrix_char_7x10_row0; } template <> struct geometric_traits<detail::matrix_char_7x10_row0> { typedef detail::matrix_char_7x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,1> matrix_char_7x10_row1; } template <> struct geometric_traits<detail::matrix_char_7x10_row1> { typedef detail::matrix_char_7x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,2> matrix_char_7x10_row2; } template <> struct geometric_traits<detail::matrix_char_7x10_row2> { typedef detail::matrix_char_7x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,3> matrix_char_7x10_row3; } template <> struct geometric_traits<detail::matrix_char_7x10_row3> { typedef detail::matrix_char_7x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,4> matrix_char_7x10_row4; } template <> struct geometric_traits<detail::matrix_char_7x10_row4> { typedef detail::matrix_char_7x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,5> matrix_char_7x10_row5; } template <> struct geometric_traits<detail::matrix_char_7x10_row5> { typedef detail::matrix_char_7x10_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_7x10,6> matrix_char_7x10_row6; } template <> struct geometric_traits<detail::matrix_char_7x10_row6> { typedef detail::matrix_char_7x10_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,0> matrix_char_7x10_column0; }template <> struct geometric_traits<detail::matrix_char_7x10_column0> { typedef detail::matrix_char_7x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,1> matrix_char_7x10_column1; }template <> struct geometric_traits<detail::matrix_char_7x10_column1> { typedef detail::matrix_char_7x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,2> matrix_char_7x10_column2; }template <> struct geometric_traits<detail::matrix_char_7x10_column2> { typedef detail::matrix_char_7x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,3> matrix_char_7x10_column3; }template <> struct geometric_traits<detail::matrix_char_7x10_column3> { typedef detail::matrix_char_7x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,4> matrix_char_7x10_column4; }template <> struct geometric_traits<detail::matrix_char_7x10_column4> { typedef detail::matrix_char_7x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,5> matrix_char_7x10_column5; }template <> struct geometric_traits<detail::matrix_char_7x10_column5> { typedef detail::matrix_char_7x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,6> matrix_char_7x10_column6; }template <> struct geometric_traits<detail::matrix_char_7x10_column6> { typedef detail::matrix_char_7x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,7> matrix_char_7x10_column7; }template <> struct geometric_traits<detail::matrix_char_7x10_column7> { typedef detail::matrix_char_7x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,8> matrix_char_7x10_column8; }template <> struct geometric_traits<detail::matrix_char_7x10_column8> { typedef detail::matrix_char_7x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_7x10,9> matrix_char_7x10_column9; }template <> struct geometric_traits<detail::matrix_char_7x10_column9> { typedef detail::matrix_char_7x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_7x10>::type > : index_operator_matrix_access_policy < matrix_char_7x10 > { typedef index_operator_matrix_access_policy < matrix_char_7x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_7x10 > { typedef dimension<7> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 1> matrix_char_8x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,0> matrix_char_8x1_row0; } template <> struct geometric_traits<detail::matrix_char_8x1_row0> { typedef detail::matrix_char_8x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,1> matrix_char_8x1_row1; } template <> struct geometric_traits<detail::matrix_char_8x1_row1> { typedef detail::matrix_char_8x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,2> matrix_char_8x1_row2; } template <> struct geometric_traits<detail::matrix_char_8x1_row2> { typedef detail::matrix_char_8x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,3> matrix_char_8x1_row3; } template <> struct geometric_traits<detail::matrix_char_8x1_row3> { typedef detail::matrix_char_8x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,4> matrix_char_8x1_row4; } template <> struct geometric_traits<detail::matrix_char_8x1_row4> { typedef detail::matrix_char_8x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,5> matrix_char_8x1_row5; } template <> struct geometric_traits<detail::matrix_char_8x1_row5> { typedef detail::matrix_char_8x1_row5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,6> matrix_char_8x1_row6; } template <> struct geometric_traits<detail::matrix_char_8x1_row6> { typedef detail::matrix_char_8x1_row6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x1,7> matrix_char_8x1_row7; } template <> struct geometric_traits<detail::matrix_char_8x1_row7> { typedef detail::matrix_char_8x1_row7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x1,0> matrix_char_8x1_column0; }template <> struct geometric_traits<detail::matrix_char_8x1_column0> { typedef detail::matrix_char_8x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x1>::type > : index_operator_matrix_access_policy < matrix_char_8x1 > { typedef index_operator_matrix_access_policy < matrix_char_8x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x1 > { typedef dimension<8> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 2> matrix_char_8x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,0> matrix_char_8x2_row0; } template <> struct geometric_traits<detail::matrix_char_8x2_row0> { typedef detail::matrix_char_8x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,1> matrix_char_8x2_row1; } template <> struct geometric_traits<detail::matrix_char_8x2_row1> { typedef detail::matrix_char_8x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,2> matrix_char_8x2_row2; } template <> struct geometric_traits<detail::matrix_char_8x2_row2> { typedef detail::matrix_char_8x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,3> matrix_char_8x2_row3; } template <> struct geometric_traits<detail::matrix_char_8x2_row3> { typedef detail::matrix_char_8x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,4> matrix_char_8x2_row4; } template <> struct geometric_traits<detail::matrix_char_8x2_row4> { typedef detail::matrix_char_8x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,5> matrix_char_8x2_row5; } template <> struct geometric_traits<detail::matrix_char_8x2_row5> { typedef detail::matrix_char_8x2_row5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,6> matrix_char_8x2_row6; } template <> struct geometric_traits<detail::matrix_char_8x2_row6> { typedef detail::matrix_char_8x2_row6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x2,7> matrix_char_8x2_row7; } template <> struct geometric_traits<detail::matrix_char_8x2_row7> { typedef detail::matrix_char_8x2_row7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x2,0> matrix_char_8x2_column0; }template <> struct geometric_traits<detail::matrix_char_8x2_column0> { typedef detail::matrix_char_8x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x2,1> matrix_char_8x2_column1; }template <> struct geometric_traits<detail::matrix_char_8x2_column1> { typedef detail::matrix_char_8x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x2>::type > : index_operator_matrix_access_policy < matrix_char_8x2 > { typedef index_operator_matrix_access_policy < matrix_char_8x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x2 > { typedef dimension<8> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 3> matrix_char_8x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,0> matrix_char_8x3_row0; } template <> struct geometric_traits<detail::matrix_char_8x3_row0> { typedef detail::matrix_char_8x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,1> matrix_char_8x3_row1; } template <> struct geometric_traits<detail::matrix_char_8x3_row1> { typedef detail::matrix_char_8x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,2> matrix_char_8x3_row2; } template <> struct geometric_traits<detail::matrix_char_8x3_row2> { typedef detail::matrix_char_8x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,3> matrix_char_8x3_row3; } template <> struct geometric_traits<detail::matrix_char_8x3_row3> { typedef detail::matrix_char_8x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,4> matrix_char_8x3_row4; } template <> struct geometric_traits<detail::matrix_char_8x3_row4> { typedef detail::matrix_char_8x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,5> matrix_char_8x3_row5; } template <> struct geometric_traits<detail::matrix_char_8x3_row5> { typedef detail::matrix_char_8x3_row5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,6> matrix_char_8x3_row6; } template <> struct geometric_traits<detail::matrix_char_8x3_row6> { typedef detail::matrix_char_8x3_row6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x3,7> matrix_char_8x3_row7; } template <> struct geometric_traits<detail::matrix_char_8x3_row7> { typedef detail::matrix_char_8x3_row7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x3,0> matrix_char_8x3_column0; }template <> struct geometric_traits<detail::matrix_char_8x3_column0> { typedef detail::matrix_char_8x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x3,1> matrix_char_8x3_column1; }template <> struct geometric_traits<detail::matrix_char_8x3_column1> { typedef detail::matrix_char_8x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x3,2> matrix_char_8x3_column2; }template <> struct geometric_traits<detail::matrix_char_8x3_column2> { typedef detail::matrix_char_8x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x3>::type > : index_operator_matrix_access_policy < matrix_char_8x3 > { typedef index_operator_matrix_access_policy < matrix_char_8x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x3 > { typedef dimension<8> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 4> matrix_char_8x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,0> matrix_char_8x4_row0; } template <> struct geometric_traits<detail::matrix_char_8x4_row0> { typedef detail::matrix_char_8x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,1> matrix_char_8x4_row1; } template <> struct geometric_traits<detail::matrix_char_8x4_row1> { typedef detail::matrix_char_8x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,2> matrix_char_8x4_row2; } template <> struct geometric_traits<detail::matrix_char_8x4_row2> { typedef detail::matrix_char_8x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,3> matrix_char_8x4_row3; } template <> struct geometric_traits<detail::matrix_char_8x4_row3> { typedef detail::matrix_char_8x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,4> matrix_char_8x4_row4; } template <> struct geometric_traits<detail::matrix_char_8x4_row4> { typedef detail::matrix_char_8x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,5> matrix_char_8x4_row5; } template <> struct geometric_traits<detail::matrix_char_8x4_row5> { typedef detail::matrix_char_8x4_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,6> matrix_char_8x4_row6; } template <> struct geometric_traits<detail::matrix_char_8x4_row6> { typedef detail::matrix_char_8x4_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x4,7> matrix_char_8x4_row7; } template <> struct geometric_traits<detail::matrix_char_8x4_row7> { typedef detail::matrix_char_8x4_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x4,0> matrix_char_8x4_column0; }template <> struct geometric_traits<detail::matrix_char_8x4_column0> { typedef detail::matrix_char_8x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x4,1> matrix_char_8x4_column1; }template <> struct geometric_traits<detail::matrix_char_8x4_column1> { typedef detail::matrix_char_8x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x4,2> matrix_char_8x4_column2; }template <> struct geometric_traits<detail::matrix_char_8x4_column2> { typedef detail::matrix_char_8x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x4,3> matrix_char_8x4_column3; }template <> struct geometric_traits<detail::matrix_char_8x4_column3> { typedef detail::matrix_char_8x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x4>::type > : index_operator_matrix_access_policy < matrix_char_8x4 > { typedef index_operator_matrix_access_policy < matrix_char_8x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x4 > { typedef dimension<8> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 5> matrix_char_8x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,0> matrix_char_8x5_row0; } template <> struct geometric_traits<detail::matrix_char_8x5_row0> { typedef detail::matrix_char_8x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,1> matrix_char_8x5_row1; } template <> struct geometric_traits<detail::matrix_char_8x5_row1> { typedef detail::matrix_char_8x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,2> matrix_char_8x5_row2; } template <> struct geometric_traits<detail::matrix_char_8x5_row2> { typedef detail::matrix_char_8x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,3> matrix_char_8x5_row3; } template <> struct geometric_traits<detail::matrix_char_8x5_row3> { typedef detail::matrix_char_8x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,4> matrix_char_8x5_row4; } template <> struct geometric_traits<detail::matrix_char_8x5_row4> { typedef detail::matrix_char_8x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,5> matrix_char_8x5_row5; } template <> struct geometric_traits<detail::matrix_char_8x5_row5> { typedef detail::matrix_char_8x5_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,6> matrix_char_8x5_row6; } template <> struct geometric_traits<detail::matrix_char_8x5_row6> { typedef detail::matrix_char_8x5_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x5,7> matrix_char_8x5_row7; } template <> struct geometric_traits<detail::matrix_char_8x5_row7> { typedef detail::matrix_char_8x5_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x5,0> matrix_char_8x5_column0; }template <> struct geometric_traits<detail::matrix_char_8x5_column0> { typedef detail::matrix_char_8x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x5,1> matrix_char_8x5_column1; }template <> struct geometric_traits<detail::matrix_char_8x5_column1> { typedef detail::matrix_char_8x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x5,2> matrix_char_8x5_column2; }template <> struct geometric_traits<detail::matrix_char_8x5_column2> { typedef detail::matrix_char_8x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x5,3> matrix_char_8x5_column3; }template <> struct geometric_traits<detail::matrix_char_8x5_column3> { typedef detail::matrix_char_8x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x5,4> matrix_char_8x5_column4; }template <> struct geometric_traits<detail::matrix_char_8x5_column4> { typedef detail::matrix_char_8x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x5>::type > : index_operator_matrix_access_policy < matrix_char_8x5 > { typedef index_operator_matrix_access_policy < matrix_char_8x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x5 > { typedef dimension<8> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 6> matrix_char_8x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,0> matrix_char_8x6_row0; } template <> struct geometric_traits<detail::matrix_char_8x6_row0> { typedef detail::matrix_char_8x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,1> matrix_char_8x6_row1; } template <> struct geometric_traits<detail::matrix_char_8x6_row1> { typedef detail::matrix_char_8x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,2> matrix_char_8x6_row2; } template <> struct geometric_traits<detail::matrix_char_8x6_row2> { typedef detail::matrix_char_8x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,3> matrix_char_8x6_row3; } template <> struct geometric_traits<detail::matrix_char_8x6_row3> { typedef detail::matrix_char_8x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,4> matrix_char_8x6_row4; } template <> struct geometric_traits<detail::matrix_char_8x6_row4> { typedef detail::matrix_char_8x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,5> matrix_char_8x6_row5; } template <> struct geometric_traits<detail::matrix_char_8x6_row5> { typedef detail::matrix_char_8x6_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,6> matrix_char_8x6_row6; } template <> struct geometric_traits<detail::matrix_char_8x6_row6> { typedef detail::matrix_char_8x6_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x6,7> matrix_char_8x6_row7; } template <> struct geometric_traits<detail::matrix_char_8x6_row7> { typedef detail::matrix_char_8x6_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,0> matrix_char_8x6_column0; }template <> struct geometric_traits<detail::matrix_char_8x6_column0> { typedef detail::matrix_char_8x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,1> matrix_char_8x6_column1; }template <> struct geometric_traits<detail::matrix_char_8x6_column1> { typedef detail::matrix_char_8x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,2> matrix_char_8x6_column2; }template <> struct geometric_traits<detail::matrix_char_8x6_column2> { typedef detail::matrix_char_8x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,3> matrix_char_8x6_column3; }template <> struct geometric_traits<detail::matrix_char_8x6_column3> { typedef detail::matrix_char_8x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,4> matrix_char_8x6_column4; }template <> struct geometric_traits<detail::matrix_char_8x6_column4> { typedef detail::matrix_char_8x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x6,5> matrix_char_8x6_column5; }template <> struct geometric_traits<detail::matrix_char_8x6_column5> { typedef detail::matrix_char_8x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x6>::type > : index_operator_matrix_access_policy < matrix_char_8x6 > { typedef index_operator_matrix_access_policy < matrix_char_8x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x6 > { typedef dimension<8> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 7> matrix_char_8x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,0> matrix_char_8x7_row0; } template <> struct geometric_traits<detail::matrix_char_8x7_row0> { typedef detail::matrix_char_8x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,1> matrix_char_8x7_row1; } template <> struct geometric_traits<detail::matrix_char_8x7_row1> { typedef detail::matrix_char_8x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,2> matrix_char_8x7_row2; } template <> struct geometric_traits<detail::matrix_char_8x7_row2> { typedef detail::matrix_char_8x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,3> matrix_char_8x7_row3; } template <> struct geometric_traits<detail::matrix_char_8x7_row3> { typedef detail::matrix_char_8x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,4> matrix_char_8x7_row4; } template <> struct geometric_traits<detail::matrix_char_8x7_row4> { typedef detail::matrix_char_8x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,5> matrix_char_8x7_row5; } template <> struct geometric_traits<detail::matrix_char_8x7_row5> { typedef detail::matrix_char_8x7_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,6> matrix_char_8x7_row6; } template <> struct geometric_traits<detail::matrix_char_8x7_row6> { typedef detail::matrix_char_8x7_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x7,7> matrix_char_8x7_row7; } template <> struct geometric_traits<detail::matrix_char_8x7_row7> { typedef detail::matrix_char_8x7_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,0> matrix_char_8x7_column0; }template <> struct geometric_traits<detail::matrix_char_8x7_column0> { typedef detail::matrix_char_8x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,1> matrix_char_8x7_column1; }template <> struct geometric_traits<detail::matrix_char_8x7_column1> { typedef detail::matrix_char_8x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,2> matrix_char_8x7_column2; }template <> struct geometric_traits<detail::matrix_char_8x7_column2> { typedef detail::matrix_char_8x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,3> matrix_char_8x7_column3; }template <> struct geometric_traits<detail::matrix_char_8x7_column3> { typedef detail::matrix_char_8x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,4> matrix_char_8x7_column4; }template <> struct geometric_traits<detail::matrix_char_8x7_column4> { typedef detail::matrix_char_8x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,5> matrix_char_8x7_column5; }template <> struct geometric_traits<detail::matrix_char_8x7_column5> { typedef detail::matrix_char_8x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x7,6> matrix_char_8x7_column6; }template <> struct geometric_traits<detail::matrix_char_8x7_column6> { typedef detail::matrix_char_8x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x7>::type > : index_operator_matrix_access_policy < matrix_char_8x7 > { typedef index_operator_matrix_access_policy < matrix_char_8x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x7 > { typedef dimension<8> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 8> matrix_char_8x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,0> matrix_char_8x8_row0; } template <> struct geometric_traits<detail::matrix_char_8x8_row0> { typedef detail::matrix_char_8x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,1> matrix_char_8x8_row1; } template <> struct geometric_traits<detail::matrix_char_8x8_row1> { typedef detail::matrix_char_8x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,2> matrix_char_8x8_row2; } template <> struct geometric_traits<detail::matrix_char_8x8_row2> { typedef detail::matrix_char_8x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,3> matrix_char_8x8_row3; } template <> struct geometric_traits<detail::matrix_char_8x8_row3> { typedef detail::matrix_char_8x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,4> matrix_char_8x8_row4; } template <> struct geometric_traits<detail::matrix_char_8x8_row4> { typedef detail::matrix_char_8x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,5> matrix_char_8x8_row5; } template <> struct geometric_traits<detail::matrix_char_8x8_row5> { typedef detail::matrix_char_8x8_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,6> matrix_char_8x8_row6; } template <> struct geometric_traits<detail::matrix_char_8x8_row6> { typedef detail::matrix_char_8x8_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x8,7> matrix_char_8x8_row7; } template <> struct geometric_traits<detail::matrix_char_8x8_row7> { typedef detail::matrix_char_8x8_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,0> matrix_char_8x8_column0; }template <> struct geometric_traits<detail::matrix_char_8x8_column0> { typedef detail::matrix_char_8x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,1> matrix_char_8x8_column1; }template <> struct geometric_traits<detail::matrix_char_8x8_column1> { typedef detail::matrix_char_8x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,2> matrix_char_8x8_column2; }template <> struct geometric_traits<detail::matrix_char_8x8_column2> { typedef detail::matrix_char_8x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,3> matrix_char_8x8_column3; }template <> struct geometric_traits<detail::matrix_char_8x8_column3> { typedef detail::matrix_char_8x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,4> matrix_char_8x8_column4; }template <> struct geometric_traits<detail::matrix_char_8x8_column4> { typedef detail::matrix_char_8x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,5> matrix_char_8x8_column5; }template <> struct geometric_traits<detail::matrix_char_8x8_column5> { typedef detail::matrix_char_8x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,6> matrix_char_8x8_column6; }template <> struct geometric_traits<detail::matrix_char_8x8_column6> { typedef detail::matrix_char_8x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x8,7> matrix_char_8x8_column7; }template <> struct geometric_traits<detail::matrix_char_8x8_column7> { typedef detail::matrix_char_8x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x8>::type > : index_operator_matrix_access_policy < matrix_char_8x8 > { typedef index_operator_matrix_access_policy < matrix_char_8x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x8 > { typedef dimension<8> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 9> matrix_char_8x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,0> matrix_char_8x9_row0; } template <> struct geometric_traits<detail::matrix_char_8x9_row0> { typedef detail::matrix_char_8x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,1> matrix_char_8x9_row1; } template <> struct geometric_traits<detail::matrix_char_8x9_row1> { typedef detail::matrix_char_8x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,2> matrix_char_8x9_row2; } template <> struct geometric_traits<detail::matrix_char_8x9_row2> { typedef detail::matrix_char_8x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,3> matrix_char_8x9_row3; } template <> struct geometric_traits<detail::matrix_char_8x9_row3> { typedef detail::matrix_char_8x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,4> matrix_char_8x9_row4; } template <> struct geometric_traits<detail::matrix_char_8x9_row4> { typedef detail::matrix_char_8x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,5> matrix_char_8x9_row5; } template <> struct geometric_traits<detail::matrix_char_8x9_row5> { typedef detail::matrix_char_8x9_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,6> matrix_char_8x9_row6; } template <> struct geometric_traits<detail::matrix_char_8x9_row6> { typedef detail::matrix_char_8x9_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x9,7> matrix_char_8x9_row7; } template <> struct geometric_traits<detail::matrix_char_8x9_row7> { typedef detail::matrix_char_8x9_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,0> matrix_char_8x9_column0; }template <> struct geometric_traits<detail::matrix_char_8x9_column0> { typedef detail::matrix_char_8x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,1> matrix_char_8x9_column1; }template <> struct geometric_traits<detail::matrix_char_8x9_column1> { typedef detail::matrix_char_8x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,2> matrix_char_8x9_column2; }template <> struct geometric_traits<detail::matrix_char_8x9_column2> { typedef detail::matrix_char_8x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,3> matrix_char_8x9_column3; }template <> struct geometric_traits<detail::matrix_char_8x9_column3> { typedef detail::matrix_char_8x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,4> matrix_char_8x9_column4; }template <> struct geometric_traits<detail::matrix_char_8x9_column4> { typedef detail::matrix_char_8x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,5> matrix_char_8x9_column5; }template <> struct geometric_traits<detail::matrix_char_8x9_column5> { typedef detail::matrix_char_8x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,6> matrix_char_8x9_column6; }template <> struct geometric_traits<detail::matrix_char_8x9_column6> { typedef detail::matrix_char_8x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,7> matrix_char_8x9_column7; }template <> struct geometric_traits<detail::matrix_char_8x9_column7> { typedef detail::matrix_char_8x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x9,8> matrix_char_8x9_column8; }template <> struct geometric_traits<detail::matrix_char_8x9_column8> { typedef detail::matrix_char_8x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x9>::type > : index_operator_matrix_access_policy < matrix_char_8x9 > { typedef index_operator_matrix_access_policy < matrix_char_8x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x9 > { typedef dimension<8> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 8, 10> matrix_char_8x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,0> matrix_char_8x10_row0; } template <> struct geometric_traits<detail::matrix_char_8x10_row0> { typedef detail::matrix_char_8x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,1> matrix_char_8x10_row1; } template <> struct geometric_traits<detail::matrix_char_8x10_row1> { typedef detail::matrix_char_8x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,2> matrix_char_8x10_row2; } template <> struct geometric_traits<detail::matrix_char_8x10_row2> { typedef detail::matrix_char_8x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,3> matrix_char_8x10_row3; } template <> struct geometric_traits<detail::matrix_char_8x10_row3> { typedef detail::matrix_char_8x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,4> matrix_char_8x10_row4; } template <> struct geometric_traits<detail::matrix_char_8x10_row4> { typedef detail::matrix_char_8x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,5> matrix_char_8x10_row5; } template <> struct geometric_traits<detail::matrix_char_8x10_row5> { typedef detail::matrix_char_8x10_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,6> matrix_char_8x10_row6; } template <> struct geometric_traits<detail::matrix_char_8x10_row6> { typedef detail::matrix_char_8x10_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_8x10,7> matrix_char_8x10_row7; } template <> struct geometric_traits<detail::matrix_char_8x10_row7> { typedef detail::matrix_char_8x10_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,0> matrix_char_8x10_column0; }template <> struct geometric_traits<detail::matrix_char_8x10_column0> { typedef detail::matrix_char_8x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,1> matrix_char_8x10_column1; }template <> struct geometric_traits<detail::matrix_char_8x10_column1> { typedef detail::matrix_char_8x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,2> matrix_char_8x10_column2; }template <> struct geometric_traits<detail::matrix_char_8x10_column2> { typedef detail::matrix_char_8x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,3> matrix_char_8x10_column3; }template <> struct geometric_traits<detail::matrix_char_8x10_column3> { typedef detail::matrix_char_8x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,4> matrix_char_8x10_column4; }template <> struct geometric_traits<detail::matrix_char_8x10_column4> { typedef detail::matrix_char_8x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,5> matrix_char_8x10_column5; }template <> struct geometric_traits<detail::matrix_char_8x10_column5> { typedef detail::matrix_char_8x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,6> matrix_char_8x10_column6; }template <> struct geometric_traits<detail::matrix_char_8x10_column6> { typedef detail::matrix_char_8x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,7> matrix_char_8x10_column7; }template <> struct geometric_traits<detail::matrix_char_8x10_column7> { typedef detail::matrix_char_8x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,8> matrix_char_8x10_column8; }template <> struct geometric_traits<detail::matrix_char_8x10_column8> { typedef detail::matrix_char_8x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_8x10,9> matrix_char_8x10_column9; }template <> struct geometric_traits<detail::matrix_char_8x10_column9> { typedef detail::matrix_char_8x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_8x10>::type > : index_operator_matrix_access_policy < matrix_char_8x10 > { typedef index_operator_matrix_access_policy < matrix_char_8x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_8x10 > { typedef dimension<8> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 1> matrix_char_9x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,0> matrix_char_9x1_row0; } template <> struct geometric_traits<detail::matrix_char_9x1_row0> { typedef detail::matrix_char_9x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,1> matrix_char_9x1_row1; } template <> struct geometric_traits<detail::matrix_char_9x1_row1> { typedef detail::matrix_char_9x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,2> matrix_char_9x1_row2; } template <> struct geometric_traits<detail::matrix_char_9x1_row2> { typedef detail::matrix_char_9x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,3> matrix_char_9x1_row3; } template <> struct geometric_traits<detail::matrix_char_9x1_row3> { typedef detail::matrix_char_9x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,4> matrix_char_9x1_row4; } template <> struct geometric_traits<detail::matrix_char_9x1_row4> { typedef detail::matrix_char_9x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,5> matrix_char_9x1_row5; } template <> struct geometric_traits<detail::matrix_char_9x1_row5> { typedef detail::matrix_char_9x1_row5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,6> matrix_char_9x1_row6; } template <> struct geometric_traits<detail::matrix_char_9x1_row6> { typedef detail::matrix_char_9x1_row6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,7> matrix_char_9x1_row7; } template <> struct geometric_traits<detail::matrix_char_9x1_row7> { typedef detail::matrix_char_9x1_row7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x1,8> matrix_char_9x1_row8; } template <> struct geometric_traits<detail::matrix_char_9x1_row8> { typedef detail::matrix_char_9x1_row8 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x1,0> matrix_char_9x1_column0; }template <> struct geometric_traits<detail::matrix_char_9x1_column0> { typedef detail::matrix_char_9x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x1>::type > : index_operator_matrix_access_policy < matrix_char_9x1 > { typedef index_operator_matrix_access_policy < matrix_char_9x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x1 > { typedef dimension<9> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 2> matrix_char_9x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,0> matrix_char_9x2_row0; } template <> struct geometric_traits<detail::matrix_char_9x2_row0> { typedef detail::matrix_char_9x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,1> matrix_char_9x2_row1; } template <> struct geometric_traits<detail::matrix_char_9x2_row1> { typedef detail::matrix_char_9x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,2> matrix_char_9x2_row2; } template <> struct geometric_traits<detail::matrix_char_9x2_row2> { typedef detail::matrix_char_9x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,3> matrix_char_9x2_row3; } template <> struct geometric_traits<detail::matrix_char_9x2_row3> { typedef detail::matrix_char_9x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,4> matrix_char_9x2_row4; } template <> struct geometric_traits<detail::matrix_char_9x2_row4> { typedef detail::matrix_char_9x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,5> matrix_char_9x2_row5; } template <> struct geometric_traits<detail::matrix_char_9x2_row5> { typedef detail::matrix_char_9x2_row5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,6> matrix_char_9x2_row6; } template <> struct geometric_traits<detail::matrix_char_9x2_row6> { typedef detail::matrix_char_9x2_row6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,7> matrix_char_9x2_row7; } template <> struct geometric_traits<detail::matrix_char_9x2_row7> { typedef detail::matrix_char_9x2_row7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x2,8> matrix_char_9x2_row8; } template <> struct geometric_traits<detail::matrix_char_9x2_row8> { typedef detail::matrix_char_9x2_row8 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x2,0> matrix_char_9x2_column0; }template <> struct geometric_traits<detail::matrix_char_9x2_column0> { typedef detail::matrix_char_9x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x2,1> matrix_char_9x2_column1; }template <> struct geometric_traits<detail::matrix_char_9x2_column1> { typedef detail::matrix_char_9x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x2>::type > : index_operator_matrix_access_policy < matrix_char_9x2 > { typedef index_operator_matrix_access_policy < matrix_char_9x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x2 > { typedef dimension<9> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 3> matrix_char_9x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,0> matrix_char_9x3_row0; } template <> struct geometric_traits<detail::matrix_char_9x3_row0> { typedef detail::matrix_char_9x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,1> matrix_char_9x3_row1; } template <> struct geometric_traits<detail::matrix_char_9x3_row1> { typedef detail::matrix_char_9x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,2> matrix_char_9x3_row2; } template <> struct geometric_traits<detail::matrix_char_9x3_row2> { typedef detail::matrix_char_9x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,3> matrix_char_9x3_row3; } template <> struct geometric_traits<detail::matrix_char_9x3_row3> { typedef detail::matrix_char_9x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,4> matrix_char_9x3_row4; } template <> struct geometric_traits<detail::matrix_char_9x3_row4> { typedef detail::matrix_char_9x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,5> matrix_char_9x3_row5; } template <> struct geometric_traits<detail::matrix_char_9x3_row5> { typedef detail::matrix_char_9x3_row5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,6> matrix_char_9x3_row6; } template <> struct geometric_traits<detail::matrix_char_9x3_row6> { typedef detail::matrix_char_9x3_row6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,7> matrix_char_9x3_row7; } template <> struct geometric_traits<detail::matrix_char_9x3_row7> { typedef detail::matrix_char_9x3_row7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x3,8> matrix_char_9x3_row8; } template <> struct geometric_traits<detail::matrix_char_9x3_row8> { typedef detail::matrix_char_9x3_row8 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x3,0> matrix_char_9x3_column0; }template <> struct geometric_traits<detail::matrix_char_9x3_column0> { typedef detail::matrix_char_9x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x3,1> matrix_char_9x3_column1; }template <> struct geometric_traits<detail::matrix_char_9x3_column1> { typedef detail::matrix_char_9x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x3,2> matrix_char_9x3_column2; }template <> struct geometric_traits<detail::matrix_char_9x3_column2> { typedef detail::matrix_char_9x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x3>::type > : index_operator_matrix_access_policy < matrix_char_9x3 > { typedef index_operator_matrix_access_policy < matrix_char_9x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x3 > { typedef dimension<9> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 4> matrix_char_9x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,0> matrix_char_9x4_row0; } template <> struct geometric_traits<detail::matrix_char_9x4_row0> { typedef detail::matrix_char_9x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,1> matrix_char_9x4_row1; } template <> struct geometric_traits<detail::matrix_char_9x4_row1> { typedef detail::matrix_char_9x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,2> matrix_char_9x4_row2; } template <> struct geometric_traits<detail::matrix_char_9x4_row2> { typedef detail::matrix_char_9x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,3> matrix_char_9x4_row3; } template <> struct geometric_traits<detail::matrix_char_9x4_row3> { typedef detail::matrix_char_9x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,4> matrix_char_9x4_row4; } template <> struct geometric_traits<detail::matrix_char_9x4_row4> { typedef detail::matrix_char_9x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,5> matrix_char_9x4_row5; } template <> struct geometric_traits<detail::matrix_char_9x4_row5> { typedef detail::matrix_char_9x4_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,6> matrix_char_9x4_row6; } template <> struct geometric_traits<detail::matrix_char_9x4_row6> { typedef detail::matrix_char_9x4_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,7> matrix_char_9x4_row7; } template <> struct geometric_traits<detail::matrix_char_9x4_row7> { typedef detail::matrix_char_9x4_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x4,8> matrix_char_9x4_row8; } template <> struct geometric_traits<detail::matrix_char_9x4_row8> { typedef detail::matrix_char_9x4_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x4,0> matrix_char_9x4_column0; }template <> struct geometric_traits<detail::matrix_char_9x4_column0> { typedef detail::matrix_char_9x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x4,1> matrix_char_9x4_column1; }template <> struct geometric_traits<detail::matrix_char_9x4_column1> { typedef detail::matrix_char_9x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x4,2> matrix_char_9x4_column2; }template <> struct geometric_traits<detail::matrix_char_9x4_column2> { typedef detail::matrix_char_9x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x4,3> matrix_char_9x4_column3; }template <> struct geometric_traits<detail::matrix_char_9x4_column3> { typedef detail::matrix_char_9x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x4>::type > : index_operator_matrix_access_policy < matrix_char_9x4 > { typedef index_operator_matrix_access_policy < matrix_char_9x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x4 > { typedef dimension<9> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 5> matrix_char_9x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,0> matrix_char_9x5_row0; } template <> struct geometric_traits<detail::matrix_char_9x5_row0> { typedef detail::matrix_char_9x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,1> matrix_char_9x5_row1; } template <> struct geometric_traits<detail::matrix_char_9x5_row1> { typedef detail::matrix_char_9x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,2> matrix_char_9x5_row2; } template <> struct geometric_traits<detail::matrix_char_9x5_row2> { typedef detail::matrix_char_9x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,3> matrix_char_9x5_row3; } template <> struct geometric_traits<detail::matrix_char_9x5_row3> { typedef detail::matrix_char_9x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,4> matrix_char_9x5_row4; } template <> struct geometric_traits<detail::matrix_char_9x5_row4> { typedef detail::matrix_char_9x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,5> matrix_char_9x5_row5; } template <> struct geometric_traits<detail::matrix_char_9x5_row5> { typedef detail::matrix_char_9x5_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,6> matrix_char_9x5_row6; } template <> struct geometric_traits<detail::matrix_char_9x5_row6> { typedef detail::matrix_char_9x5_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,7> matrix_char_9x5_row7; } template <> struct geometric_traits<detail::matrix_char_9x5_row7> { typedef detail::matrix_char_9x5_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x5,8> matrix_char_9x5_row8; } template <> struct geometric_traits<detail::matrix_char_9x5_row8> { typedef detail::matrix_char_9x5_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x5,0> matrix_char_9x5_column0; }template <> struct geometric_traits<detail::matrix_char_9x5_column0> { typedef detail::matrix_char_9x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x5,1> matrix_char_9x5_column1; }template <> struct geometric_traits<detail::matrix_char_9x5_column1> { typedef detail::matrix_char_9x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x5,2> matrix_char_9x5_column2; }template <> struct geometric_traits<detail::matrix_char_9x5_column2> { typedef detail::matrix_char_9x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x5,3> matrix_char_9x5_column3; }template <> struct geometric_traits<detail::matrix_char_9x5_column3> { typedef detail::matrix_char_9x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x5,4> matrix_char_9x5_column4; }template <> struct geometric_traits<detail::matrix_char_9x5_column4> { typedef detail::matrix_char_9x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x5>::type > : index_operator_matrix_access_policy < matrix_char_9x5 > { typedef index_operator_matrix_access_policy < matrix_char_9x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x5 > { typedef dimension<9> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 6> matrix_char_9x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,0> matrix_char_9x6_row0; } template <> struct geometric_traits<detail::matrix_char_9x6_row0> { typedef detail::matrix_char_9x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,1> matrix_char_9x6_row1; } template <> struct geometric_traits<detail::matrix_char_9x6_row1> { typedef detail::matrix_char_9x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,2> matrix_char_9x6_row2; } template <> struct geometric_traits<detail::matrix_char_9x6_row2> { typedef detail::matrix_char_9x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,3> matrix_char_9x6_row3; } template <> struct geometric_traits<detail::matrix_char_9x6_row3> { typedef detail::matrix_char_9x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,4> matrix_char_9x6_row4; } template <> struct geometric_traits<detail::matrix_char_9x6_row4> { typedef detail::matrix_char_9x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,5> matrix_char_9x6_row5; } template <> struct geometric_traits<detail::matrix_char_9x6_row5> { typedef detail::matrix_char_9x6_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,6> matrix_char_9x6_row6; } template <> struct geometric_traits<detail::matrix_char_9x6_row6> { typedef detail::matrix_char_9x6_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,7> matrix_char_9x6_row7; } template <> struct geometric_traits<detail::matrix_char_9x6_row7> { typedef detail::matrix_char_9x6_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x6,8> matrix_char_9x6_row8; } template <> struct geometric_traits<detail::matrix_char_9x6_row8> { typedef detail::matrix_char_9x6_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,0> matrix_char_9x6_column0; }template <> struct geometric_traits<detail::matrix_char_9x6_column0> { typedef detail::matrix_char_9x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,1> matrix_char_9x6_column1; }template <> struct geometric_traits<detail::matrix_char_9x6_column1> { typedef detail::matrix_char_9x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,2> matrix_char_9x6_column2; }template <> struct geometric_traits<detail::matrix_char_9x6_column2> { typedef detail::matrix_char_9x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,3> matrix_char_9x6_column3; }template <> struct geometric_traits<detail::matrix_char_9x6_column3> { typedef detail::matrix_char_9x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,4> matrix_char_9x6_column4; }template <> struct geometric_traits<detail::matrix_char_9x6_column4> { typedef detail::matrix_char_9x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x6,5> matrix_char_9x6_column5; }template <> struct geometric_traits<detail::matrix_char_9x6_column5> { typedef detail::matrix_char_9x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x6>::type > : index_operator_matrix_access_policy < matrix_char_9x6 > { typedef index_operator_matrix_access_policy < matrix_char_9x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x6 > { typedef dimension<9> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 7> matrix_char_9x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,0> matrix_char_9x7_row0; } template <> struct geometric_traits<detail::matrix_char_9x7_row0> { typedef detail::matrix_char_9x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,1> matrix_char_9x7_row1; } template <> struct geometric_traits<detail::matrix_char_9x7_row1> { typedef detail::matrix_char_9x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,2> matrix_char_9x7_row2; } template <> struct geometric_traits<detail::matrix_char_9x7_row2> { typedef detail::matrix_char_9x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,3> matrix_char_9x7_row3; } template <> struct geometric_traits<detail::matrix_char_9x7_row3> { typedef detail::matrix_char_9x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,4> matrix_char_9x7_row4; } template <> struct geometric_traits<detail::matrix_char_9x7_row4> { typedef detail::matrix_char_9x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,5> matrix_char_9x7_row5; } template <> struct geometric_traits<detail::matrix_char_9x7_row5> { typedef detail::matrix_char_9x7_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,6> matrix_char_9x7_row6; } template <> struct geometric_traits<detail::matrix_char_9x7_row6> { typedef detail::matrix_char_9x7_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,7> matrix_char_9x7_row7; } template <> struct geometric_traits<detail::matrix_char_9x7_row7> { typedef detail::matrix_char_9x7_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x7,8> matrix_char_9x7_row8; } template <> struct geometric_traits<detail::matrix_char_9x7_row8> { typedef detail::matrix_char_9x7_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,0> matrix_char_9x7_column0; }template <> struct geometric_traits<detail::matrix_char_9x7_column0> { typedef detail::matrix_char_9x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,1> matrix_char_9x7_column1; }template <> struct geometric_traits<detail::matrix_char_9x7_column1> { typedef detail::matrix_char_9x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,2> matrix_char_9x7_column2; }template <> struct geometric_traits<detail::matrix_char_9x7_column2> { typedef detail::matrix_char_9x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,3> matrix_char_9x7_column3; }template <> struct geometric_traits<detail::matrix_char_9x7_column3> { typedef detail::matrix_char_9x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,4> matrix_char_9x7_column4; }template <> struct geometric_traits<detail::matrix_char_9x7_column4> { typedef detail::matrix_char_9x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,5> matrix_char_9x7_column5; }template <> struct geometric_traits<detail::matrix_char_9x7_column5> { typedef detail::matrix_char_9x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x7,6> matrix_char_9x7_column6; }template <> struct geometric_traits<detail::matrix_char_9x7_column6> { typedef detail::matrix_char_9x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x7>::type > : index_operator_matrix_access_policy < matrix_char_9x7 > { typedef index_operator_matrix_access_policy < matrix_char_9x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x7 > { typedef dimension<9> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 8> matrix_char_9x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,0> matrix_char_9x8_row0; } template <> struct geometric_traits<detail::matrix_char_9x8_row0> { typedef detail::matrix_char_9x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,1> matrix_char_9x8_row1; } template <> struct geometric_traits<detail::matrix_char_9x8_row1> { typedef detail::matrix_char_9x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,2> matrix_char_9x8_row2; } template <> struct geometric_traits<detail::matrix_char_9x8_row2> { typedef detail::matrix_char_9x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,3> matrix_char_9x8_row3; } template <> struct geometric_traits<detail::matrix_char_9x8_row3> { typedef detail::matrix_char_9x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,4> matrix_char_9x8_row4; } template <> struct geometric_traits<detail::matrix_char_9x8_row4> { typedef detail::matrix_char_9x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,5> matrix_char_9x8_row5; } template <> struct geometric_traits<detail::matrix_char_9x8_row5> { typedef detail::matrix_char_9x8_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,6> matrix_char_9x8_row6; } template <> struct geometric_traits<detail::matrix_char_9x8_row6> { typedef detail::matrix_char_9x8_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,7> matrix_char_9x8_row7; } template <> struct geometric_traits<detail::matrix_char_9x8_row7> { typedef detail::matrix_char_9x8_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x8,8> matrix_char_9x8_row8; } template <> struct geometric_traits<detail::matrix_char_9x8_row8> { typedef detail::matrix_char_9x8_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,0> matrix_char_9x8_column0; }template <> struct geometric_traits<detail::matrix_char_9x8_column0> { typedef detail::matrix_char_9x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,1> matrix_char_9x8_column1; }template <> struct geometric_traits<detail::matrix_char_9x8_column1> { typedef detail::matrix_char_9x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,2> matrix_char_9x8_column2; }template <> struct geometric_traits<detail::matrix_char_9x8_column2> { typedef detail::matrix_char_9x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,3> matrix_char_9x8_column3; }template <> struct geometric_traits<detail::matrix_char_9x8_column3> { typedef detail::matrix_char_9x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,4> matrix_char_9x8_column4; }template <> struct geometric_traits<detail::matrix_char_9x8_column4> { typedef detail::matrix_char_9x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,5> matrix_char_9x8_column5; }template <> struct geometric_traits<detail::matrix_char_9x8_column5> { typedef detail::matrix_char_9x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,6> matrix_char_9x8_column6; }template <> struct geometric_traits<detail::matrix_char_9x8_column6> { typedef detail::matrix_char_9x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x8,7> matrix_char_9x8_column7; }template <> struct geometric_traits<detail::matrix_char_9x8_column7> { typedef detail::matrix_char_9x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x8>::type > : index_operator_matrix_access_policy < matrix_char_9x8 > { typedef index_operator_matrix_access_policy < matrix_char_9x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x8 > { typedef dimension<9> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 9> matrix_char_9x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,0> matrix_char_9x9_row0; } template <> struct geometric_traits<detail::matrix_char_9x9_row0> { typedef detail::matrix_char_9x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,1> matrix_char_9x9_row1; } template <> struct geometric_traits<detail::matrix_char_9x9_row1> { typedef detail::matrix_char_9x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,2> matrix_char_9x9_row2; } template <> struct geometric_traits<detail::matrix_char_9x9_row2> { typedef detail::matrix_char_9x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,3> matrix_char_9x9_row3; } template <> struct geometric_traits<detail::matrix_char_9x9_row3> { typedef detail::matrix_char_9x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,4> matrix_char_9x9_row4; } template <> struct geometric_traits<detail::matrix_char_9x9_row4> { typedef detail::matrix_char_9x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,5> matrix_char_9x9_row5; } template <> struct geometric_traits<detail::matrix_char_9x9_row5> { typedef detail::matrix_char_9x9_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,6> matrix_char_9x9_row6; } template <> struct geometric_traits<detail::matrix_char_9x9_row6> { typedef detail::matrix_char_9x9_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,7> matrix_char_9x9_row7; } template <> struct geometric_traits<detail::matrix_char_9x9_row7> { typedef detail::matrix_char_9x9_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x9,8> matrix_char_9x9_row8; } template <> struct geometric_traits<detail::matrix_char_9x9_row8> { typedef detail::matrix_char_9x9_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,0> matrix_char_9x9_column0; }template <> struct geometric_traits<detail::matrix_char_9x9_column0> { typedef detail::matrix_char_9x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,1> matrix_char_9x9_column1; }template <> struct geometric_traits<detail::matrix_char_9x9_column1> { typedef detail::matrix_char_9x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,2> matrix_char_9x9_column2; }template <> struct geometric_traits<detail::matrix_char_9x9_column2> { typedef detail::matrix_char_9x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,3> matrix_char_9x9_column3; }template <> struct geometric_traits<detail::matrix_char_9x9_column3> { typedef detail::matrix_char_9x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,4> matrix_char_9x9_column4; }template <> struct geometric_traits<detail::matrix_char_9x9_column4> { typedef detail::matrix_char_9x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,5> matrix_char_9x9_column5; }template <> struct geometric_traits<detail::matrix_char_9x9_column5> { typedef detail::matrix_char_9x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,6> matrix_char_9x9_column6; }template <> struct geometric_traits<detail::matrix_char_9x9_column6> { typedef detail::matrix_char_9x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,7> matrix_char_9x9_column7; }template <> struct geometric_traits<detail::matrix_char_9x9_column7> { typedef detail::matrix_char_9x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x9,8> matrix_char_9x9_column8; }template <> struct geometric_traits<detail::matrix_char_9x9_column8> { typedef detail::matrix_char_9x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x9>::type > : index_operator_matrix_access_policy < matrix_char_9x9 > { typedef index_operator_matrix_access_policy < matrix_char_9x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x9 > { typedef dimension<9> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 9, 10> matrix_char_9x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,0> matrix_char_9x10_row0; } template <> struct geometric_traits<detail::matrix_char_9x10_row0> { typedef detail::matrix_char_9x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,1> matrix_char_9x10_row1; } template <> struct geometric_traits<detail::matrix_char_9x10_row1> { typedef detail::matrix_char_9x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,2> matrix_char_9x10_row2; } template <> struct geometric_traits<detail::matrix_char_9x10_row2> { typedef detail::matrix_char_9x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,3> matrix_char_9x10_row3; } template <> struct geometric_traits<detail::matrix_char_9x10_row3> { typedef detail::matrix_char_9x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,4> matrix_char_9x10_row4; } template <> struct geometric_traits<detail::matrix_char_9x10_row4> { typedef detail::matrix_char_9x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,5> matrix_char_9x10_row5; } template <> struct geometric_traits<detail::matrix_char_9x10_row5> { typedef detail::matrix_char_9x10_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,6> matrix_char_9x10_row6; } template <> struct geometric_traits<detail::matrix_char_9x10_row6> { typedef detail::matrix_char_9x10_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,7> matrix_char_9x10_row7; } template <> struct geometric_traits<detail::matrix_char_9x10_row7> { typedef detail::matrix_char_9x10_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_9x10,8> matrix_char_9x10_row8; } template <> struct geometric_traits<detail::matrix_char_9x10_row8> { typedef detail::matrix_char_9x10_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,0> matrix_char_9x10_column0; }template <> struct geometric_traits<detail::matrix_char_9x10_column0> { typedef detail::matrix_char_9x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,1> matrix_char_9x10_column1; }template <> struct geometric_traits<detail::matrix_char_9x10_column1> { typedef detail::matrix_char_9x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,2> matrix_char_9x10_column2; }template <> struct geometric_traits<detail::matrix_char_9x10_column2> { typedef detail::matrix_char_9x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,3> matrix_char_9x10_column3; }template <> struct geometric_traits<detail::matrix_char_9x10_column3> { typedef detail::matrix_char_9x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,4> matrix_char_9x10_column4; }template <> struct geometric_traits<detail::matrix_char_9x10_column4> { typedef detail::matrix_char_9x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,5> matrix_char_9x10_column5; }template <> struct geometric_traits<detail::matrix_char_9x10_column5> { typedef detail::matrix_char_9x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,6> matrix_char_9x10_column6; }template <> struct geometric_traits<detail::matrix_char_9x10_column6> { typedef detail::matrix_char_9x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,7> matrix_char_9x10_column7; }template <> struct geometric_traits<detail::matrix_char_9x10_column7> { typedef detail::matrix_char_9x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,8> matrix_char_9x10_column8; }template <> struct geometric_traits<detail::matrix_char_9x10_column8> { typedef detail::matrix_char_9x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_9x10,9> matrix_char_9x10_column9; }template <> struct geometric_traits<detail::matrix_char_9x10_column9> { typedef detail::matrix_char_9x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_9x10>::type > : index_operator_matrix_access_policy < matrix_char_9x10 > { typedef index_operator_matrix_access_policy < matrix_char_9x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_9x10 > { typedef dimension<9> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 1> matrix_char_10x1; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,0> matrix_char_10x1_row0; } template <> struct geometric_traits<detail::matrix_char_10x1_row0> { typedef detail::matrix_char_10x1_row0 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,1> matrix_char_10x1_row1; } template <> struct geometric_traits<detail::matrix_char_10x1_row1> { typedef detail::matrix_char_10x1_row1 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,2> matrix_char_10x1_row2; } template <> struct geometric_traits<detail::matrix_char_10x1_row2> { typedef detail::matrix_char_10x1_row2 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,3> matrix_char_10x1_row3; } template <> struct geometric_traits<detail::matrix_char_10x1_row3> { typedef detail::matrix_char_10x1_row3 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,4> matrix_char_10x1_row4; } template <> struct geometric_traits<detail::matrix_char_10x1_row4> { typedef detail::matrix_char_10x1_row4 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,5> matrix_char_10x1_row5; } template <> struct geometric_traits<detail::matrix_char_10x1_row5> { typedef detail::matrix_char_10x1_row5 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,6> matrix_char_10x1_row6; } template <> struct geometric_traits<detail::matrix_char_10x1_row6> { typedef detail::matrix_char_10x1_row6 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,7> matrix_char_10x1_row7; } template <> struct geometric_traits<detail::matrix_char_10x1_row7> { typedef detail::matrix_char_10x1_row7 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,8> matrix_char_10x1_row8; } template <> struct geometric_traits<detail::matrix_char_10x1_row8> { typedef detail::matrix_char_10x1_row8 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x1,9> matrix_char_10x1_row9; } template <> struct geometric_traits<detail::matrix_char_10x1_row9> { typedef detail::matrix_char_10x1_row9 sequence_type; typedef boost::mpl::vector<char> storage_types; typedef dimension<1> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x1,0> matrix_char_10x1_column0; }template <> struct geometric_traits<detail::matrix_char_10x1_column0> { typedef detail::matrix_char_10x1_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x1>::type > : index_operator_matrix_access_policy < matrix_char_10x1 > { typedef index_operator_matrix_access_policy < matrix_char_10x1 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x1 > { typedef dimension<10> row_dimension; typedef dimension<1> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 2> matrix_char_10x2; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,0> matrix_char_10x2_row0; } template <> struct geometric_traits<detail::matrix_char_10x2_row0> { typedef detail::matrix_char_10x2_row0 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,1> matrix_char_10x2_row1; } template <> struct geometric_traits<detail::matrix_char_10x2_row1> { typedef detail::matrix_char_10x2_row1 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,2> matrix_char_10x2_row2; } template <> struct geometric_traits<detail::matrix_char_10x2_row2> { typedef detail::matrix_char_10x2_row2 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,3> matrix_char_10x2_row3; } template <> struct geometric_traits<detail::matrix_char_10x2_row3> { typedef detail::matrix_char_10x2_row3 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,4> matrix_char_10x2_row4; } template <> struct geometric_traits<detail::matrix_char_10x2_row4> { typedef detail::matrix_char_10x2_row4 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,5> matrix_char_10x2_row5; } template <> struct geometric_traits<detail::matrix_char_10x2_row5> { typedef detail::matrix_char_10x2_row5 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,6> matrix_char_10x2_row6; } template <> struct geometric_traits<detail::matrix_char_10x2_row6> { typedef detail::matrix_char_10x2_row6 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,7> matrix_char_10x2_row7; } template <> struct geometric_traits<detail::matrix_char_10x2_row7> { typedef detail::matrix_char_10x2_row7 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,8> matrix_char_10x2_row8; } template <> struct geometric_traits<detail::matrix_char_10x2_row8> { typedef detail::matrix_char_10x2_row8 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x2,9> matrix_char_10x2_row9; } template <> struct geometric_traits<detail::matrix_char_10x2_row9> { typedef detail::matrix_char_10x2_row9 sequence_type; typedef boost::mpl::vector<char, char> storage_types; typedef dimension<2> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x2,0> matrix_char_10x2_column0; }template <> struct geometric_traits<detail::matrix_char_10x2_column0> { typedef detail::matrix_char_10x2_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x2,1> matrix_char_10x2_column1; }template <> struct geometric_traits<detail::matrix_char_10x2_column1> { typedef detail::matrix_char_10x2_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x2>::type > : index_operator_matrix_access_policy < matrix_char_10x2 > { typedef index_operator_matrix_access_policy < matrix_char_10x2 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x2 > { typedef dimension<10> row_dimension; typedef dimension<2> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 3> matrix_char_10x3; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,0> matrix_char_10x3_row0; } template <> struct geometric_traits<detail::matrix_char_10x3_row0> { typedef detail::matrix_char_10x3_row0 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,1> matrix_char_10x3_row1; } template <> struct geometric_traits<detail::matrix_char_10x3_row1> { typedef detail::matrix_char_10x3_row1 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,2> matrix_char_10x3_row2; } template <> struct geometric_traits<detail::matrix_char_10x3_row2> { typedef detail::matrix_char_10x3_row2 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,3> matrix_char_10x3_row3; } template <> struct geometric_traits<detail::matrix_char_10x3_row3> { typedef detail::matrix_char_10x3_row3 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,4> matrix_char_10x3_row4; } template <> struct geometric_traits<detail::matrix_char_10x3_row4> { typedef detail::matrix_char_10x3_row4 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,5> matrix_char_10x3_row5; } template <> struct geometric_traits<detail::matrix_char_10x3_row5> { typedef detail::matrix_char_10x3_row5 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,6> matrix_char_10x3_row6; } template <> struct geometric_traits<detail::matrix_char_10x3_row6> { typedef detail::matrix_char_10x3_row6 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,7> matrix_char_10x3_row7; } template <> struct geometric_traits<detail::matrix_char_10x3_row7> { typedef detail::matrix_char_10x3_row7 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,8> matrix_char_10x3_row8; } template <> struct geometric_traits<detail::matrix_char_10x3_row8> { typedef detail::matrix_char_10x3_row8 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x3,9> matrix_char_10x3_row9; } template <> struct geometric_traits<detail::matrix_char_10x3_row9> { typedef detail::matrix_char_10x3_row9 sequence_type; typedef boost::mpl::vector<char, char, char> storage_types; typedef dimension<3> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x3,0> matrix_char_10x3_column0; }template <> struct geometric_traits<detail::matrix_char_10x3_column0> { typedef detail::matrix_char_10x3_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x3,1> matrix_char_10x3_column1; }template <> struct geometric_traits<detail::matrix_char_10x3_column1> { typedef detail::matrix_char_10x3_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x3,2> matrix_char_10x3_column2; }template <> struct geometric_traits<detail::matrix_char_10x3_column2> { typedef detail::matrix_char_10x3_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x3>::type > : index_operator_matrix_access_policy < matrix_char_10x3 > { typedef index_operator_matrix_access_policy < matrix_char_10x3 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x3 > { typedef dimension<10> row_dimension; typedef dimension<3> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 4> matrix_char_10x4; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,0> matrix_char_10x4_row0; } template <> struct geometric_traits<detail::matrix_char_10x4_row0> { typedef detail::matrix_char_10x4_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,1> matrix_char_10x4_row1; } template <> struct geometric_traits<detail::matrix_char_10x4_row1> { typedef detail::matrix_char_10x4_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,2> matrix_char_10x4_row2; } template <> struct geometric_traits<detail::matrix_char_10x4_row2> { typedef detail::matrix_char_10x4_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,3> matrix_char_10x4_row3; } template <> struct geometric_traits<detail::matrix_char_10x4_row3> { typedef detail::matrix_char_10x4_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,4> matrix_char_10x4_row4; } template <> struct geometric_traits<detail::matrix_char_10x4_row4> { typedef detail::matrix_char_10x4_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,5> matrix_char_10x4_row5; } template <> struct geometric_traits<detail::matrix_char_10x4_row5> { typedef detail::matrix_char_10x4_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,6> matrix_char_10x4_row6; } template <> struct geometric_traits<detail::matrix_char_10x4_row6> { typedef detail::matrix_char_10x4_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,7> matrix_char_10x4_row7; } template <> struct geometric_traits<detail::matrix_char_10x4_row7> { typedef detail::matrix_char_10x4_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,8> matrix_char_10x4_row8; } template <> struct geometric_traits<detail::matrix_char_10x4_row8> { typedef detail::matrix_char_10x4_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x4,9> matrix_char_10x4_row9; } template <> struct geometric_traits<detail::matrix_char_10x4_row9> { typedef detail::matrix_char_10x4_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char> storage_types; typedef dimension<4> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x4,0> matrix_char_10x4_column0; }template <> struct geometric_traits<detail::matrix_char_10x4_column0> { typedef detail::matrix_char_10x4_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x4,1> matrix_char_10x4_column1; }template <> struct geometric_traits<detail::matrix_char_10x4_column1> { typedef detail::matrix_char_10x4_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x4,2> matrix_char_10x4_column2; }template <> struct geometric_traits<detail::matrix_char_10x4_column2> { typedef detail::matrix_char_10x4_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x4,3> matrix_char_10x4_column3; }template <> struct geometric_traits<detail::matrix_char_10x4_column3> { typedef detail::matrix_char_10x4_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x4>::type > : index_operator_matrix_access_policy < matrix_char_10x4 > { typedef index_operator_matrix_access_policy < matrix_char_10x4 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x4 > { typedef dimension<10> row_dimension; typedef dimension<4> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 5> matrix_char_10x5; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,0> matrix_char_10x5_row0; } template <> struct geometric_traits<detail::matrix_char_10x5_row0> { typedef detail::matrix_char_10x5_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,1> matrix_char_10x5_row1; } template <> struct geometric_traits<detail::matrix_char_10x5_row1> { typedef detail::matrix_char_10x5_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,2> matrix_char_10x5_row2; } template <> struct geometric_traits<detail::matrix_char_10x5_row2> { typedef detail::matrix_char_10x5_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,3> matrix_char_10x5_row3; } template <> struct geometric_traits<detail::matrix_char_10x5_row3> { typedef detail::matrix_char_10x5_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,4> matrix_char_10x5_row4; } template <> struct geometric_traits<detail::matrix_char_10x5_row4> { typedef detail::matrix_char_10x5_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,5> matrix_char_10x5_row5; } template <> struct geometric_traits<detail::matrix_char_10x5_row5> { typedef detail::matrix_char_10x5_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,6> matrix_char_10x5_row6; } template <> struct geometric_traits<detail::matrix_char_10x5_row6> { typedef detail::matrix_char_10x5_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,7> matrix_char_10x5_row7; } template <> struct geometric_traits<detail::matrix_char_10x5_row7> { typedef detail::matrix_char_10x5_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,8> matrix_char_10x5_row8; } template <> struct geometric_traits<detail::matrix_char_10x5_row8> { typedef detail::matrix_char_10x5_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x5,9> matrix_char_10x5_row9; } template <> struct geometric_traits<detail::matrix_char_10x5_row9> { typedef detail::matrix_char_10x5_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char> storage_types; typedef dimension<5> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x5,0> matrix_char_10x5_column0; }template <> struct geometric_traits<detail::matrix_char_10x5_column0> { typedef detail::matrix_char_10x5_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x5,1> matrix_char_10x5_column1; }template <> struct geometric_traits<detail::matrix_char_10x5_column1> { typedef detail::matrix_char_10x5_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x5,2> matrix_char_10x5_column2; }template <> struct geometric_traits<detail::matrix_char_10x5_column2> { typedef detail::matrix_char_10x5_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x5,3> matrix_char_10x5_column3; }template <> struct geometric_traits<detail::matrix_char_10x5_column3> { typedef detail::matrix_char_10x5_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x5,4> matrix_char_10x5_column4; }template <> struct geometric_traits<detail::matrix_char_10x5_column4> { typedef detail::matrix_char_10x5_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x5>::type > : index_operator_matrix_access_policy < matrix_char_10x5 > { typedef index_operator_matrix_access_policy < matrix_char_10x5 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x5 > { typedef dimension<10> row_dimension; typedef dimension<5> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 6> matrix_char_10x6; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,0> matrix_char_10x6_row0; } template <> struct geometric_traits<detail::matrix_char_10x6_row0> { typedef detail::matrix_char_10x6_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,1> matrix_char_10x6_row1; } template <> struct geometric_traits<detail::matrix_char_10x6_row1> { typedef detail::matrix_char_10x6_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,2> matrix_char_10x6_row2; } template <> struct geometric_traits<detail::matrix_char_10x6_row2> { typedef detail::matrix_char_10x6_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,3> matrix_char_10x6_row3; } template <> struct geometric_traits<detail::matrix_char_10x6_row3> { typedef detail::matrix_char_10x6_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,4> matrix_char_10x6_row4; } template <> struct geometric_traits<detail::matrix_char_10x6_row4> { typedef detail::matrix_char_10x6_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,5> matrix_char_10x6_row5; } template <> struct geometric_traits<detail::matrix_char_10x6_row5> { typedef detail::matrix_char_10x6_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,6> matrix_char_10x6_row6; } template <> struct geometric_traits<detail::matrix_char_10x6_row6> { typedef detail::matrix_char_10x6_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,7> matrix_char_10x6_row7; } template <> struct geometric_traits<detail::matrix_char_10x6_row7> { typedef detail::matrix_char_10x6_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,8> matrix_char_10x6_row8; } template <> struct geometric_traits<detail::matrix_char_10x6_row8> { typedef detail::matrix_char_10x6_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x6,9> matrix_char_10x6_row9; } template <> struct geometric_traits<detail::matrix_char_10x6_row9> { typedef detail::matrix_char_10x6_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char> storage_types; typedef dimension<6> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,0> matrix_char_10x6_column0; }template <> struct geometric_traits<detail::matrix_char_10x6_column0> { typedef detail::matrix_char_10x6_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,1> matrix_char_10x6_column1; }template <> struct geometric_traits<detail::matrix_char_10x6_column1> { typedef detail::matrix_char_10x6_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,2> matrix_char_10x6_column2; }template <> struct geometric_traits<detail::matrix_char_10x6_column2> { typedef detail::matrix_char_10x6_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,3> matrix_char_10x6_column3; }template <> struct geometric_traits<detail::matrix_char_10x6_column3> { typedef detail::matrix_char_10x6_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,4> matrix_char_10x6_column4; }template <> struct geometric_traits<detail::matrix_char_10x6_column4> { typedef detail::matrix_char_10x6_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x6,5> matrix_char_10x6_column5; }template <> struct geometric_traits<detail::matrix_char_10x6_column5> { typedef detail::matrix_char_10x6_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x6>::type > : index_operator_matrix_access_policy < matrix_char_10x6 > { typedef index_operator_matrix_access_policy < matrix_char_10x6 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x6 > { typedef dimension<10> row_dimension; typedef dimension<6> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 7> matrix_char_10x7; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,0> matrix_char_10x7_row0; } template <> struct geometric_traits<detail::matrix_char_10x7_row0> { typedef detail::matrix_char_10x7_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,1> matrix_char_10x7_row1; } template <> struct geometric_traits<detail::matrix_char_10x7_row1> { typedef detail::matrix_char_10x7_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,2> matrix_char_10x7_row2; } template <> struct geometric_traits<detail::matrix_char_10x7_row2> { typedef detail::matrix_char_10x7_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,3> matrix_char_10x7_row3; } template <> struct geometric_traits<detail::matrix_char_10x7_row3> { typedef detail::matrix_char_10x7_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,4> matrix_char_10x7_row4; } template <> struct geometric_traits<detail::matrix_char_10x7_row4> { typedef detail::matrix_char_10x7_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,5> matrix_char_10x7_row5; } template <> struct geometric_traits<detail::matrix_char_10x7_row5> { typedef detail::matrix_char_10x7_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,6> matrix_char_10x7_row6; } template <> struct geometric_traits<detail::matrix_char_10x7_row6> { typedef detail::matrix_char_10x7_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,7> matrix_char_10x7_row7; } template <> struct geometric_traits<detail::matrix_char_10x7_row7> { typedef detail::matrix_char_10x7_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,8> matrix_char_10x7_row8; } template <> struct geometric_traits<detail::matrix_char_10x7_row8> { typedef detail::matrix_char_10x7_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x7,9> matrix_char_10x7_row9; } template <> struct geometric_traits<detail::matrix_char_10x7_row9> { typedef detail::matrix_char_10x7_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char> storage_types; typedef dimension<7> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,0> matrix_char_10x7_column0; }template <> struct geometric_traits<detail::matrix_char_10x7_column0> { typedef detail::matrix_char_10x7_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,1> matrix_char_10x7_column1; }template <> struct geometric_traits<detail::matrix_char_10x7_column1> { typedef detail::matrix_char_10x7_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,2> matrix_char_10x7_column2; }template <> struct geometric_traits<detail::matrix_char_10x7_column2> { typedef detail::matrix_char_10x7_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,3> matrix_char_10x7_column3; }template <> struct geometric_traits<detail::matrix_char_10x7_column3> { typedef detail::matrix_char_10x7_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,4> matrix_char_10x7_column4; }template <> struct geometric_traits<detail::matrix_char_10x7_column4> { typedef detail::matrix_char_10x7_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,5> matrix_char_10x7_column5; }template <> struct geometric_traits<detail::matrix_char_10x7_column5> { typedef detail::matrix_char_10x7_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x7,6> matrix_char_10x7_column6; }template <> struct geometric_traits<detail::matrix_char_10x7_column6> { typedef detail::matrix_char_10x7_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x7>::type > : index_operator_matrix_access_policy < matrix_char_10x7 > { typedef index_operator_matrix_access_policy < matrix_char_10x7 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x7 > { typedef dimension<10> row_dimension; typedef dimension<7> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 8> matrix_char_10x8; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,0> matrix_char_10x8_row0; } template <> struct geometric_traits<detail::matrix_char_10x8_row0> { typedef detail::matrix_char_10x8_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,1> matrix_char_10x8_row1; } template <> struct geometric_traits<detail::matrix_char_10x8_row1> { typedef detail::matrix_char_10x8_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,2> matrix_char_10x8_row2; } template <> struct geometric_traits<detail::matrix_char_10x8_row2> { typedef detail::matrix_char_10x8_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,3> matrix_char_10x8_row3; } template <> struct geometric_traits<detail::matrix_char_10x8_row3> { typedef detail::matrix_char_10x8_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,4> matrix_char_10x8_row4; } template <> struct geometric_traits<detail::matrix_char_10x8_row4> { typedef detail::matrix_char_10x8_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,5> matrix_char_10x8_row5; } template <> struct geometric_traits<detail::matrix_char_10x8_row5> { typedef detail::matrix_char_10x8_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,6> matrix_char_10x8_row6; } template <> struct geometric_traits<detail::matrix_char_10x8_row6> { typedef detail::matrix_char_10x8_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,7> matrix_char_10x8_row7; } template <> struct geometric_traits<detail::matrix_char_10x8_row7> { typedef detail::matrix_char_10x8_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,8> matrix_char_10x8_row8; } template <> struct geometric_traits<detail::matrix_char_10x8_row8> { typedef detail::matrix_char_10x8_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x8,9> matrix_char_10x8_row9; } template <> struct geometric_traits<detail::matrix_char_10x8_row9> { typedef detail::matrix_char_10x8_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char> storage_types; typedef dimension<8> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,0> matrix_char_10x8_column0; }template <> struct geometric_traits<detail::matrix_char_10x8_column0> { typedef detail::matrix_char_10x8_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,1> matrix_char_10x8_column1; }template <> struct geometric_traits<detail::matrix_char_10x8_column1> { typedef detail::matrix_char_10x8_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,2> matrix_char_10x8_column2; }template <> struct geometric_traits<detail::matrix_char_10x8_column2> { typedef detail::matrix_char_10x8_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,3> matrix_char_10x8_column3; }template <> struct geometric_traits<detail::matrix_char_10x8_column3> { typedef detail::matrix_char_10x8_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,4> matrix_char_10x8_column4; }template <> struct geometric_traits<detail::matrix_char_10x8_column4> { typedef detail::matrix_char_10x8_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,5> matrix_char_10x8_column5; }template <> struct geometric_traits<detail::matrix_char_10x8_column5> { typedef detail::matrix_char_10x8_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,6> matrix_char_10x8_column6; }template <> struct geometric_traits<detail::matrix_char_10x8_column6> { typedef detail::matrix_char_10x8_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x8,7> matrix_char_10x8_column7; }template <> struct geometric_traits<detail::matrix_char_10x8_column7> { typedef detail::matrix_char_10x8_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x8>::type > : index_operator_matrix_access_policy < matrix_char_10x8 > { typedef index_operator_matrix_access_policy < matrix_char_10x8 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x8 > { typedef dimension<10> row_dimension; typedef dimension<8> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 9> matrix_char_10x9; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,0> matrix_char_10x9_row0; } template <> struct geometric_traits<detail::matrix_char_10x9_row0> { typedef detail::matrix_char_10x9_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,1> matrix_char_10x9_row1; } template <> struct geometric_traits<detail::matrix_char_10x9_row1> { typedef detail::matrix_char_10x9_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,2> matrix_char_10x9_row2; } template <> struct geometric_traits<detail::matrix_char_10x9_row2> { typedef detail::matrix_char_10x9_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,3> matrix_char_10x9_row3; } template <> struct geometric_traits<detail::matrix_char_10x9_row3> { typedef detail::matrix_char_10x9_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,4> matrix_char_10x9_row4; } template <> struct geometric_traits<detail::matrix_char_10x9_row4> { typedef detail::matrix_char_10x9_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,5> matrix_char_10x9_row5; } template <> struct geometric_traits<detail::matrix_char_10x9_row5> { typedef detail::matrix_char_10x9_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,6> matrix_char_10x9_row6; } template <> struct geometric_traits<detail::matrix_char_10x9_row6> { typedef detail::matrix_char_10x9_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,7> matrix_char_10x9_row7; } template <> struct geometric_traits<detail::matrix_char_10x9_row7> { typedef detail::matrix_char_10x9_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,8> matrix_char_10x9_row8; } template <> struct geometric_traits<detail::matrix_char_10x9_row8> { typedef detail::matrix_char_10x9_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x9,9> matrix_char_10x9_row9; } template <> struct geometric_traits<detail::matrix_char_10x9_row9> { typedef detail::matrix_char_10x9_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<9> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,0> matrix_char_10x9_column0; }template <> struct geometric_traits<detail::matrix_char_10x9_column0> { typedef detail::matrix_char_10x9_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,1> matrix_char_10x9_column1; }template <> struct geometric_traits<detail::matrix_char_10x9_column1> { typedef detail::matrix_char_10x9_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,2> matrix_char_10x9_column2; }template <> struct geometric_traits<detail::matrix_char_10x9_column2> { typedef detail::matrix_char_10x9_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,3> matrix_char_10x9_column3; }template <> struct geometric_traits<detail::matrix_char_10x9_column3> { typedef detail::matrix_char_10x9_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,4> matrix_char_10x9_column4; }template <> struct geometric_traits<detail::matrix_char_10x9_column4> { typedef detail::matrix_char_10x9_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,5> matrix_char_10x9_column5; }template <> struct geometric_traits<detail::matrix_char_10x9_column5> { typedef detail::matrix_char_10x9_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,6> matrix_char_10x9_column6; }template <> struct geometric_traits<detail::matrix_char_10x9_column6> { typedef detail::matrix_char_10x9_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,7> matrix_char_10x9_column7; }template <> struct geometric_traits<detail::matrix_char_10x9_column7> { typedef detail::matrix_char_10x9_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x9,8> matrix_char_10x9_column8; }template <> struct geometric_traits<detail::matrix_char_10x9_column8> { typedef detail::matrix_char_10x9_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x9>::type > : index_operator_matrix_access_policy < matrix_char_10x9 > { typedef index_operator_matrix_access_policy < matrix_char_10x9 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x9 > { typedef dimension<10> row_dimension; typedef dimension<9> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; } namespace geometrix { typedef matrix<char, 10, 10> matrix_char_10x10; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,0> matrix_char_10x10_row0; } template <> struct geometric_traits<detail::matrix_char_10x10_row0> { typedef detail::matrix_char_10x10_row0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,1> matrix_char_10x10_row1; } template <> struct geometric_traits<detail::matrix_char_10x10_row1> { typedef detail::matrix_char_10x10_row1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,2> matrix_char_10x10_row2; } template <> struct geometric_traits<detail::matrix_char_10x10_row2> { typedef detail::matrix_char_10x10_row2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,3> matrix_char_10x10_row3; } template <> struct geometric_traits<detail::matrix_char_10x10_row3> { typedef detail::matrix_char_10x10_row3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,4> matrix_char_10x10_row4; } template <> struct geometric_traits<detail::matrix_char_10x10_row4> { typedef detail::matrix_char_10x10_row4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,5> matrix_char_10x10_row5; } template <> struct geometric_traits<detail::matrix_char_10x10_row5> { typedef detail::matrix_char_10x10_row5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,6> matrix_char_10x10_row6; } template <> struct geometric_traits<detail::matrix_char_10x10_row6> { typedef detail::matrix_char_10x10_row6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,7> matrix_char_10x10_row7; } template <> struct geometric_traits<detail::matrix_char_10x10_row7> { typedef detail::matrix_char_10x10_row7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,8> matrix_char_10x10_row8; } template <> struct geometric_traits<detail::matrix_char_10x10_row8> { typedef detail::matrix_char_10x10_row8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef row<matrix_char_10x10,9> matrix_char_10x10_row9; } template <> struct geometric_traits<detail::matrix_char_10x10_row9> { typedef detail::matrix_char_10x10_row9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,0> matrix_char_10x10_column0; }template <> struct geometric_traits<detail::matrix_char_10x10_column0> { typedef detail::matrix_char_10x10_column0 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,1> matrix_char_10x10_column1; }template <> struct geometric_traits<detail::matrix_char_10x10_column1> { typedef detail::matrix_char_10x10_column1 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,2> matrix_char_10x10_column2; }template <> struct geometric_traits<detail::matrix_char_10x10_column2> { typedef detail::matrix_char_10x10_column2 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,3> matrix_char_10x10_column3; }template <> struct geometric_traits<detail::matrix_char_10x10_column3> { typedef detail::matrix_char_10x10_column3 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,4> matrix_char_10x10_column4; }template <> struct geometric_traits<detail::matrix_char_10x10_column4> { typedef detail::matrix_char_10x10_column4 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,5> matrix_char_10x10_column5; }template <> struct geometric_traits<detail::matrix_char_10x10_column5> { typedef detail::matrix_char_10x10_column5 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,6> matrix_char_10x10_column6; }template <> struct geometric_traits<detail::matrix_char_10x10_column6> { typedef detail::matrix_char_10x10_column6 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,7> matrix_char_10x10_column7; }template <> struct geometric_traits<detail::matrix_char_10x10_column7> { typedef detail::matrix_char_10x10_column7 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,8> matrix_char_10x10_column8; }template <> struct geometric_traits<detail::matrix_char_10x10_column8> { typedef detail::matrix_char_10x10_column8 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; } namespace geometrix { namespace detail{ typedef column<matrix_char_10x10,9> matrix_char_10x10_column9; }template <> struct geometric_traits<detail::matrix_char_10x10_column9> { typedef detail::matrix_char_10x10_column9 sequence_type; typedef boost::mpl::vector<char, char, char, char, char, char, char, char, char, char> storage_types; typedef dimension<10> dimension_type; typedef void is_sequence; typedef void is_numeric_sequence; typedef void is_vector; typedef void is_homogeneous; }; }namespace geometrix { template <> struct tensor_traits< typename remove_const_ref<matrix_char_10x10>::type > : index_operator_matrix_access_policy < matrix_char_10x10 > { typedef index_operator_matrix_access_policy < matrix_char_10x10 > access_policy; typedef boost::mpl::int_<2> tensor_order; typedef void rank_2; typedef void is_tensor; typedef void make_fusion_sequence; }; } namespace geometrix { template <> struct geometric_traits< matrix_char_10x10 > { typedef dimension<10> row_dimension; typedef dimension<10> col_dimension; typedef double arithmetic_type; typedef void is_matrix; typedef void is_homogeneous; }; }
