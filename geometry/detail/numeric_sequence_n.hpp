//
//!  Copyright (c) 2008
//!  Brandon Kohn
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

namespace boost
{
namespace numeric
{
namespace geometry
{

#define DIMENSION BOOST_PP_ITERATION()

    //! define the constructors via the preprocessor.
    template <typename T>
    boost::array<T,DIMENSION> make_array( BOOST_PP_ENUM_PARAMS(DIMENSION, const T& a) )        
    {
        boost::array<T,DIMENSION> numericSequence = { BOOST_PP_ENUM_PARAMS(DIMENSION, a) };
        return numericSequence;
    }

/////////////////////////////////////////////////////////////////////////////
//
// CLASS numeric_sequence
//! A template class for specifying numeric_sequence which can be compile time
//! and runtime indexed conforming to random access for both and can support
//! vector and scalar arithmetic.
//!
template <typename NumericType>
class numeric_sequence<NumericType,DIMENSION> : public boost::array< NumericType, DIMENSION >
{
public:

	typedef NumericType                            numeric_type;
	typedef dimension_traits<DIMENSION>            dimension_type;
    typedef boost::array< NumericType, DIMENSION > numeric_array;
    
    numeric_sequence(){}

    //! define the constructors via the preprocessor.
    numeric_sequence( BOOST_PP_ENUM_PARAMS(DIMENSION, const numeric_type& a) )
        : boost::array< NumericType, DIMENSION >( make_array( BOOST_PP_ENUM_PARAMS(DIMENSION, a) ) )
    {
    }

    numeric_sequence( const numeric_array& a )
        : boost::array< NumericType, DIMENSION >( a )
    {}

    template <unsigned int D>
    const numeric_type& get() const
    {
        BOOST_MPL_ASSERT_MSG
        (
           ( dimension_traits< D >::value >= 0 && dimension_traits< D >::value < dimension_type::value )
		   , NUMERIC_SEQUENCE_GET_CALLED_WITH_INDEX_OUT_OF_BOUNDS
		   , ( dimension_traits< D > )
        );

        return boost::array< NumericType, DIMENSION >::operator [](D);
    }

    template <unsigned int D>
    numeric_type& get()
    {        
        BOOST_MPL_ASSERT_MSG
        (
           ( dimension_traits< D >::value >= 0 && dimension_traits< D >::value < dimension_type::value )
		   , NUMERIC_SEQUENCE_GET_CALLED_WITH_INDEX_OUT_OF_BOUNDS
		   , ( dimension_traits< D > )
        );

        return boost::array< NumericType, DIMENSION >::operator [](D);
    }

    const numeric_type& get( size_t i ) const
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return boost::array< NumericType, DIMENSION >::operator [](i);
    }

    numeric_type& get( size_t i )
    {        
        BOOST_ASSERT( i < dimension_type::value );
        return boost::array< NumericType, DIMENSION >::operator [](i)
    }

protected:

    //! Operator interface    
    numeric_sequence& operator+= ( const numeric_sequence& p )
    {
        typedef boost::fusion::vector<numeric_array&, const numeric_array&> sequences;
        boost::fusion::for_each( boost::fusion::zip_view<sequences>( sequences( *(static_cast< numeric_array* >(this)), static_cast< const numeric_array& >(p) ) ), make_fused_procedure( boost::lambda::_1 += boost::lambda::_2 ) );
        return *this;
    }

    // numeric_sequence operator+(numeric_sequence, const numeric_sequence&) automatically
    // generated by addable.

    numeric_sequence& operator-= ( const numeric_sequence& p )
    {
        typedef boost::fusion::vector<numeric_array&, const numeric_array&> sequences;
        boost::fusion::for_each( boost::fusion::zip_view<sequences>( sequences( *(static_cast< numeric_array* >(this)), static_cast< const numeric_array& >(p) ) ), make_fused_procedure( boost::lambda::_1 -= boost::lambda::_2 ) );
        return *this;
    }
    // numeric_sequence operator-(numeric_sequence, const numeric_sequence&) automatically
    // generated by subtractable.

	numeric_sequence& operator*= ( const numeric_type& v )
    {
        boost::fusion::for_each( *(static_cast< numeric_array* >(this)), boost::lambda::_1 *= v );
        return *this;
    }
    // numeric_sequence operator*(numeric_sequence, const T&) and
    // numeric_sequence operator*(const T&, numeric_sequence) auto-generated
    // by multipliable.

	numeric_sequence& operator/= ( const numeric_type& v ) 
    {
        boost::fusion::for_each( *(static_cast< numeric_array* >(this)), boost::lambda::_1 /= v );
        return *this;
    }
    // numeric_sequence operator/(numeric_sequence, const T&) auto-generated
    // by dividable.

};
          
}}}//namespace boost::numeric::geometry

#undef DIMENSION
